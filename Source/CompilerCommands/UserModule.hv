TryAddCreateModule := !(Token^ itm) -> BoxExeObj^
{
	cmd := itm.Down->{TokenIndent^}.Value
	if cmd != "#Module"
		return null

	posArgs := List.{Token^}
	namedArgs := AVLMap.{Str,Token^}

	if not ParseCmdInputs(itm.Down.Right,posArgs,namedArgs)
	{
		CurrentWork?.SetErrorMessage(itm.MakeError("Could not parse inputs"))
		return null
	}

	newModule := new UserModule

	bdy := new TokenSymbol(StringSpan("{}"),0)
	bdy.Down = itm.Down.Right.Down
	bdy.Down?.Up = bdy

	parents := HybridQueue.{Tuple.{Token^,InheritanceType},2}
	//par1 := new TokenIndent("internalHVModuleBase")
	//c := InheritanceType
	//c = "extends"
	// parents.Emplace(par1,c)

	resultClass := new BoxClassBody(false,parents,bdy)
	resultClass.Name = "ModuleName"

	newModule.bodyClass = resultClass

	UserModules.Push(newModule)

	newModule.StartInit()

	return GObjNone
}

GetItemUser := !(Str name) -> BoxExeObj^
{
	for it : UserModules
	{
		// if not it.ExpectFunctionsComplete()
		// 	continue
		if not it.finishedRun
			continue

		imp := it.impClass

		if imp == null
			continue

		res := BoxExeObj^
		res = it.GetItem?(imp,name)?->{BoxExeObj^}
		if res? is in BoxExeObj
			return res
	}
}

UserModules := List.{UserModule^}

UserModule := class
{
	bodyClass := BoxClassBody^
	impClass := internalHVModuleBase^

	GetItem := !(void^,Str)^->void^

	// startedCompile := bool
	finishedRun := bool
	isCompiled := bool
	compileWork := CWorkUserModuleCompilation^

	StartInit := !() -> void
	{
		SubWork(() ==> {


			bodyClass.AwaitReadyState()
			resType := bodyClass.ItType
			tmpl := intGetTemplate("internalHVCreateBase")
			assert(tmpl != null)
			b := Vector.{BoxExeObj^}
			fnc := tmpl.GetFunc(b,![resType])
			assert(fnc != null)

			fPtr := RGetFuncPtr(fnc->{BoxFuncBody^})->{!()^->internalHVModuleBase^}
			impClass = fPtr()


			bodyClass.enterScope(() ==> [this&] {
	
				//TODO check types
				bodyClass.GetMethods("Init",x ==> [this&] {
					for it : x
					{
						fnc := it
	
						if fnc is BuildInVirtualCall
							fnc = fnc.wrappedFunc
						
						if fnc is in BoxFuncBody
						{
							initFunc := RGetFuncPtr(fnc)->{!(void^)^->void}
							initFunc(impClass)
						}
					}
				})
				//TODO check types
				bodyClass.GetMethods("GetItem",x ==> [this&] {
					for it : x
					{
						fnc := it
	
						if fnc is BuildInVirtualCall
							fnc = fnc.wrappedFunc
						
						if fnc is in BoxFuncBody
						{
							// fnc.ParentScope = bodyClass
	
							GetItem = RGetFuncPtr(fnc)->{!(void^,Str)^->void^}
						}
					}
				})

			})

			{
				c := CollectFunctionsCtx(GInterpCntx&)
				c.checkClass(bodyClass)
				c.Collect()
				c.WriteFunctions[^].WaitReadyState()
			}
			// c.UsedClasses[^].WaitReadyState()

			finishedRun = true
		})

	}


	ExpectFunctionsComplete := !() -> bool
	{
		if isCompiled
			return true

		if compileWork == null
		{

			// bodyClass.StartParseBody()

			newWork := new CWorkUserModuleCompilation
			newWork.waitModuleClass = bodyClass
			newWork.AddClassForced(bodyClass)
			WorkBag.AddWork(newWork)
			compileWork = newWork
		}
		if compileWork.IsDone()
		{
			isCompiled = true
			compileWork = null
			return true
		}
		return false
	}
}

CWorkUserModuleCompilation := class extend CWorkUnit
{
	waitFunctions := List.{BoxFuncBody^}
	waitClasses := List.{BoxClass^}
	waitModuleClass := BoxClass^

	this := !(BoxUnit^ startFunction) -> void
	{
		AddUnit(startFunction)
	}
	AddClass := !(BoxClass^ cls) -> void
	{
		if cls.IsComplete()
			return void
		waitClasses.Push(cls)
	}
	AddClassForced := !(BoxClass^ cls) -> void
	{
		waitClasses.Push(cls)
	}
	AddUnit := !(BoxUnit^ newUnit) -> void
	{
		if newUnit is in BoxFuncBody
		{
			bFunc := newUnit->{BoxFuncBody^}
			bFunc.ParseBody()
			if not bFunc.IsComplete()
				waitFunctions.Push(bFunc)
		}else if newUnit is BuildInVirtualCall{
			vCall := newUnit->{BuildInVirtualCall^}
			vCall.TryForceVirtualUse()
			AddUnit(vCall.wrappedFunc)
		}else{
			printf("unknown object to wait in user module %s\n",newUnit.UnitName)
			assert(false)
		}
	}
	DoWork := virtual !() -> CWorkState 
	{
		if IsDone()
		{
			return "Complete"
		}

		if waitModuleClass?.IsComplete()
		{
			waitModuleClass.GetMethods(StringSpan("Init"),x ==> {
				AddUnit(x[^])
			})
			waitModuleClass.GetMethods(StringSpan("GetItem"),x ==> {
				AddUnit(x[^])
			})
			waitModuleClass = null
		}

		if waitClasses.Size() != 0
		{
			frnt := waitClasses[0]
			if frnt.IsComplete()
			{
				waitClasses.Pop()
			}
		}

		while waitFunctions.Size() != 0 and waitFunctions[0].IsComplete()
		{
			frnt := waitFunctions[0]
			waitFunctions.Pop()

			//mc := GInterpCntx.GetMCFunc(frnt)

			//for it : mc.Objects
			//{
			//	if it& is MCConstFunction
			//	{
			//		AddUnit(it&->{MCConstFunction^}.GetValue())
			//	}
			//}
		}

		if IsDone()
			return "Complete"
		return "Failed"
	}
	IsDone := virtual !() -> bool 
	{
		return waitClasses.Size() == 0 and waitFunctions.Size() == 0
	}
	GetErrorMessage := virtual !() -> Str 
	{
	}
}
