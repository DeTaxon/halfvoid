BoxLambdaHolder := class extend BoxExeObj
{
	tmpl := BoxFuncTemplateBody^
	cleanType := Type^
	captureTokens := Token^
	this := !(Token^ brackets, Token^ body,Token^ typeToken,Token^ capturesToken) -> void
	{
		captureTokens = capturesToken

		attr := FuncAttributes
		bPtr := Token^
		itBody := body

		if itBody.GetValue() != "{}"
		{
			itBody = new TokenSymbol(StringSpan("{}"),1)
			dat := new TokenData
			re := new TokenSymbol(StringSpan("return"),1)
			itBody.Down = dat
			dat.Down = re
			re.Right = body
			itBody.Line = body.Line
			re.Line = body.Line
			dat.Line = body.Line
		}

		if brackets.Down?.GetValue() == "()"
		{
			bPtr = brackets.Down
		}else{
			if not (brackets is TokenIndent)
				brackets.EmitError("Unknown input object for lambda") //todo better error
			
			bPtr = new TokenSymbol(StringSpan("()"),1)
			bPtr.Down = new TokenIndent(brackets->{TokenIndent^}.Value)
		}

		rToken := typeToken
		if typeToken == null
		{
			rToken = new TokenIndent
			attr.IsAutoResult = true
			rToken->{TokenIndent^}.Value = StringSpan("void")
		}

		attr.IsLambda = true
		
		tmpl = new BoxFuncTemplateBody(attr,bPtr,null,null,rToken,itBody)
		tmpl.SetName(StringSpan("lambda"))

		ObjType = GTypeNone
	}
	IsOneFunc := !() -> bool
	{
		return tmpl.IsOneFunc()
	}
	CreateOneFuncLambda := !() -> BoxExeObj^
	{
		return createLambd(() ==> {
			return this.tmpl.GetOneFunc()->{BoxFuncBody^}
		})
	}
	CreateLambda := virtual !(Type^ toType) -> BoxExeObj^
	{
		if not (toType is in TypePoint)
			return null
		if not (toType.Base is in TypeClass)
			return null

		cls := toType.Base->{TypeClass^}.ToClass
		if cls.Constants == null or cls.Constants.Constants.Size() != 1
			return null
		cnst1 := cls.Constants.Constants[0]
		if not (cnst1 is ConstType)
			return null
		cnstTyp := cnst1->{ConstType^}.Value
		if not (cnstTyp is in TypePoint)
			return null
		if not (cnstTyp.Base is in TypeFunc)
			return null
		fTyp := cnstTyp.Base->{TypeFunc^}
		return createLambd(() ==> {
			cnsts := List.{BoxExeConstObj^}
			return tmpl.CreateFunc(fTyp,cnsts)->{BoxFuncBody^}
		})
	}

	createLambd := !(!()&->BoxFuncBody^ cb) -> BoxExeObj^
	{
		stackSize := UnitStack.Size()

		newFunc := cb() //Vars captured

		resObj := new LambdaObject
		capturedVars := ref resObj.capturedVars

		vars := ref newFunc.CapturedVars2

		if captureTokens != null
		{
			SyntaxCompress(captureTokens,PriorityData)

			iterC := captureTokens.Down
			while iterC != null
			{
				if iterC.GetValue() != ","
				{
					capName := StringSpan
					capCall := BoxExeObj^
					macroRes := MacroParam^
					isRef := false

					if iterC is TokenIndent
					{
						capName = iterC->{TokenIndent^}.Value

						capCall = TryCheckGetParam(iterC)
						if capCall == null
							iterC.EmitError("Could not get captured value") //todo better error
						macroRes = new MacroParam(capCall.GetType(),true)
						vars.Push(new MemVar(capName,macroRes))
					}else if iterC.Down?.Right?.GetValue() == "&" and iterC.Down is TokenIndent
					{
						capName = iterC.Down->{TokenIndent^}.Value

						capCall = TryCheckGetParam(iterC.Down)
						if capCall == null
							iterC.EmitError("Could not get captured value") //todo better error
						isRef = true
						capCall = new UnrefFuncCall(capCall)
						macroRes = new MacroParam(capCall.GetType(),true)
						vars.Push(new MemVarRef(capName,macroRes))
					}else if iterC.Down?.Right?.GetValue() == "=" and iterC.Down is TokenIndent
					{
						capName = iterC.Down->{TokenIndent^}.Value
						capCall = TryGetExeCall(iterC.Down.Right.Right)
						if capCall == null
							iterC.EmitError("Can not get result of right of operator =")
					}
					capturedVars.Emplace(capName,capCall,macroRes,isRef)
				}
				iterC = iterC.Right
			}
		}

		resObj.baseFunc = CurrentFunc
		resObj.lambdaFunc = newFunc

		emptyConsts := List.{BoxExeConstObj^}
	
		UnitStack.PushFront(resObj)
		newFunc.ParseBodyForced()

		
		fncFnc := new FuncPointerParam(newFunc)
		fncPtr := fncFnc.CreateCall()

		getTupleVar := BoxExeObj^

	
		tplTypes := List.{Type^}	
		for it : capturedVars
		{
			tplTypes.Push(it.1.GetType())
		}

		tplTuple := GetTuple(tplTypes)
		tplType := tplTuple.ItType

		for it,i : capturedVars
		{
			if it.3
			{
			}else{
				mc := it.2
				mc.PopulateCalls2(() ==> {
					asRawPar := new FuncInputParam(GTypeVoidP,false,StringSpan("%par0")) //TODO: way too bad

					objs3 := CheckExeDownList
					objs3.Push(asRawPar.CreateCall())
					cnsts := List.{BoxExeConstObj^}
					cnsts.Push(GetConstType(tplType))
					lGCall := TemplateInternalGetCaptures.GetFunc(objs3,cnsts)
					assert(lGCall != null)

					getPtr := lGCall.CreateCall(objs3)
					assert(getPtr != null)

					objs3.Destroy()

					pth := tplTuple.GetFieldByIndexTuple(i)
					objs3.Push(getPtr)
					r6 := pth.CreateCall(objs3)
					assert(r6 != null)
					asRawPar.PopulateCalls()
					return r6
				})
			}
		}

		objs := CheckExeDownList
		objs.Push(fncPtr)

		lst := List.{BoxExeConstObj^}
		lst.Push(GetConstType(newFunc.GetYieldTuple().ItType))
		lst.Push(GetConstType(tplType))
		
		createLambdaFunc := TemplateInternalCreateLambda.GetFunc(objs,lst)

		step1 := createLambdaFunc.CreateCall(objs)
		step2 := new UnrefFuncCall(step1)

		cleanType = step1.GetType()

		cnsts := List.{BoxExeConstObj^}
		cnsts.Push(GetConstType(newFunc.GetType().GetPoint()))
		InternalsHatch.Await()
		lambdaType := GCLambda.GetClass(cnsts).ItType

		if capturedVars.Size() != 0
		{
			objs3 := CheckExeDownList
			objs3.Push(new ObjResultHolder(step2))
			cnsts := List.{BoxExeConstObj^}
			cnsts.Push(GetConstType(tplType))
			getCaptureListFunc := TemplateInternalGetCaptures.GetFunc(objs3,cnsts)
			cnsts.Destroy()
			getCaptureList := getCaptureListFunc.CreateCall(objs3)
			getCap := new ObjResultHolder(getCaptureList)

			resObj.postCalls.Push(getCaptureList)

			for it,i : capturedVars
			{
				pth := tplTuple.GetFieldByIndexTuple(i)
				objs1 := CheckExeDownList
				objs1.Push(getCap)
				element := pth.CreateCall(objs1)
				assert(element != null)
				objs2 := CheckExeDownList
				objs2.Push(element)
				objs2.Push(it.1)
				resCall := CreateFuncCall(StringSpan("="),objs2)
				assert(resCall != null)

				resObj.postCalls.Push(resCall)
			}
		}


		//assert(step1 is in BoxFuncCall)
		//st := step1->{BoxFuncCall^}
		//for it, i : newFunc.CapturedBySomeVars
		//{
		//	st.ExtraWork.Push(it.2)
		//}

		resObj.mainCall = GetExchange(step2,lambdaType.GetPoint())

		while UnitStack.Size() > stackSize
			UnitStack.Pop()

		return resObj
	}
	CanBeThisType := !(Type^ tp) -> bool
	{ //TODO: check argument count and types
		if not (tp is in TypePoint)
			return false
		if TypeFight(tp.Base,GCILambda.ItType) != GCILambda.ItType
			return false
		return true
	}
}

LambdaObject := class extend PackedExeObj
{
	baseFunc := BoxFuncBody^
	lambdaFunc := BoxFuncBody^
	capturedVars := List.{Tuple.{StringSpan,BoxExeObj^,MacroParam^,bool}}

	//CaptureObject := !(StringSpan name,BoxExeObj^ obj,bool isRef,Token^ errorToken) -> MemVar^
	//{
	//	emptyConsts := List.{BoxExeConstObj^}

	//	locVar := FuncLocalParam^
	//	baseFunc.EnterScope(() ==> {
	//		locVar = new FuncLocalParam(obj.GetType())
	//		CurrentFunc.regularVars.Push(locVar)
	//		locVar.NotifyCaptureUse()
	//	})

	//	objs9 := CheckExeDownList
	//	objs9.Push(locVar.CreateCall())
	//	objs9.Push(obj)

	//	itSet := BoxExeObj^
	//	
	//	if obj.GetType() is in TypePoint
	//	{
	//		itSet = GPointStoreTemplate.GetFunc(objs9,emptyConsts).CreateCall(objs9) 
	//	}else{
	//		itSet = CreateFuncCall(StringSpan("="),objs9,emptyConsts)
	//		if itSet == null
	//			errorToken.EmitError("Could not get operator = for capture variable")
	//	}
	//	objs9.Destroy()
	//	preCalls.Push(itSet)


	//	itMemVar := MemVar^
	//	if isRef
	//	{
	//		itMemVar = new MemVarRef(name,locVar)
	//	}else{
	//		itMemVar = new MemVar(name,locVar)
	//	}
	//	lambdaFunc.CapturedManualy[name] = itMemVar
	//	lambdaFunc.CaptureUsed = true
	//	return itMemVar
	//}
}
