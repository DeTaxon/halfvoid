

CompileAndRunInit := !() -> void
{
	@once {
		startFunc := intGetFunc("CallStartFunctions")
		CompileAndRunCode(startFunc->{BoxFuncBody^})
	}
}
CompileAndRunCode := !(BoxFuncBody^ funcToRun) -> InterpWork^
{
	result = new InterpWork(CurrentTask)
	oldWork := CurrentWork
	CurrentWork = result

	// fnc := GInterpCntx.GetMCFunc(funcToRun)
	// inputs := Vector.{void^}
	// MCInterpFunction(GInterpCntx&,fnc,inputs)
	initFunc := RGetFuncPtr(funcToRun)->{!()^->void}
	initFunc()

	CurrentWork->{InterpWork^}.isDone = true
	CurrentWork = oldWork
}

MCInterpFunction2Resulted := !(MCInterpContext^ iCntx,MCFunction^ interpFunc, Vector.{void^} inputs,void^ resultPtr = null) -> InterpWork^
{
	result = new InterpWork(CurrentTask)
	oldWork := CurrentWork
	CurrentWork = result

	MCInterpFunction2(iCntx,interpFunc,inputs,resultPtr)

	CurrentWork->{InterpWork^}.isDone = true
	CurrentWork = oldWork
}
RGetFuncPtr := !(BoxFunc^ fnc) -> void^
{
	if FastestRunner
		return GX86Cntx.GetFunctionPtr(fnc->{BoxFuncBody^})

	mc := GInterpCntx.GetMCFunc(fnc->{BoxFuncBody^})
	return GInterpCntx.GetFunctionPointer(mc)
}
RGetVTableFuncPtr := !(BoxFuncBody^ fnc,void^^ target) -> void^
{
	if FastestRunner
		return GetLazyVirtualFuncX86(fnc,target)
		// return GX86Cntx.GetFunctionPtr(fnc->{BoxFuncBody^})

	return GInterpCntx.GetVTableFunctionPointer(fnc)
}
