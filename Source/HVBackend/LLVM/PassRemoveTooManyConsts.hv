
PassRemoveTooManyVars := !(MCFunction^ fnc) ->MCFunction^
{
	bldr := MakeGreedyPass(fnc,4,6)

	oPtr := bldr.oPtr
	cPtr := bldr.cPtr

	objsUsed := Vector.{int}
	objsUsed.Resize(fnc.Objects.Size())
	used := objsUsed.GetPointer()

	iCmds := fnc.Lines.GetPointer()
	cmdsSize := fnc.Lines.Size()

	c := ref bldr.cmdsSize

	for k : fnc.Lines.Size()
	{
		line := iCmds[k]
		used[line.var1] += 1
		used[line.var2] += 1
		used[line.var3] += 1
		used[line.var4] += 1
		used[line.var5] += 1
	}

	remakeId := AVLMap.{int,int}

	i := 0
	while i < cmdsSize
	{
		line := iCmds[i]

		canRemove := false

		if false and i < cmdsSize - 1
			and iCmds[i].opcode == "mov" and used[iCmds[i].var1] == 2
			and iCmds[i+1].opcode == "mov"
			and iCmds[i].var1 == iCmds[i+1].var2
		{
			ob1 := ref oPtr[iCmds[i].var2]
			ob2 := ref oPtr[iCmds[i+1].var1]
			cntr := ref oPtr[iCmds[i].var1]
			

			if ob1 == ob2
				and ob1 is MCConstValue
				and cntr is MCVariable
			{
				canRemove = true

				beforeId := iCmds[i+1].var1
				afterId := iCmds[i].var2

				remakeId[beforeId] = afterId
			}

		}

		if false and line.opcode == "cast" and oPtr[line.var1] == oPtr[line.var2] and oPtr[line.var1] is MCConstValue
		{
			line.var2 = remakeId[line.var2]?
			remakeId[line.var1] = line.var2
			i += 1
		} else if canRemove
		{
			i += 2
		}else{
			for j : 4
			{
				id := line.var2&[j]
				id = remakeId[id]?
				line.var2&[j] = id
			}
			cPtr[c++] = line
			i += 1
		}
	}

	return bldr.GenerateFunc()
}
