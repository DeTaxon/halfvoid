
PassRemoveTooManyVars := !(MCFunction^ fnc) ->MCFunction^
{
	bldr := MakeGreedyPass(fnc,4,6)

	oPtr := bldr.oPtr
	cPtr := bldr.cPtr

	objsUsed := Vector.{int}
	objsUsed.Resize(fnc.Objects.Size())
	used := objsUsed.GetPointer()

	used2 := u32[]
	movedFrom := int[]
	used2.Resize(fnc.Objects.Size())
	movedFrom.Resize(used2.Size())
	// used outside, used from move, to move counter

	iCmds := fnc.Lines.GetPointer()
	cmdsSize := fnc.Lines.Size()

	c := ref bldr.cmdsSize

	for k : fnc.Lines.Size()
	{
		line := iCmds[k]
		used[line.var1] += 1
		used[line.var2] += 1
		used[line.var3] += 1
		used[line.var4] += 1
		used[line.var5] += 1

		if line.opcode == "mov"
		{
			used2[line.var1] += 4
			used2[line.var2] = used2[line.var2] or_b 2

			movedFrom[line.var1] = line.var2

			if oPtr[line.var1].GetType() != oPtr[line.var2].GetType()
				used2[line.var1] = 1
			if oPtr[line.var1]& is not in MCVariable
				used2[line.var1] = 1
			if oPtr[line.var2]& is not in MCVariable
				used2[line.var2] = 1
		}else{
			used2[line.var1] = used2[line.var1] or_b 1
			used2[line.var2] = used2[line.var2] or_b 1
			used2[line.var3] = used2[line.var3] or_b 1
			used2[line.var4] = used2[line.var4] or_b 1
			used2[line.var5] = used2[line.var5] or_b 1
		}
	}

	remakeId := AVLMap.{int,int}

	i := 0
	while i < cmdsSize
	{
		line := iCmds[i]

		canRemove := false
		removeOne := false

		possibleReplace := (used[iCmds[i].var1] == 2) or (used2[iCmds[i].var1] == 6)

		if i < cmdsSize - 1
			and iCmds[i].opcode == "mov" and possibleReplace
			and iCmds[i+1].opcode == "mov"
			and iCmds[i].var1 == iCmds[i+1].var2
		{
			ob1 := ref oPtr[iCmds[i].var2]
			ob2 := ref oPtr[iCmds[i+1].var1]
			cntr := ref oPtr[iCmds[i].var1]
			

			if ob1 == ob2
				and ob1 is MCConstValue
				and cntr is MCVariable
			{
				canRemove = true

				beforeId := iCmds[i+1].var1
				afterId := iCmds[i].var2

				afterId = remakeId[afterId]?

				remakeId[beforeId] = afterId
			}
		}else if line.opcode == "mov" and used2[line.var2] == 6 and oPtr[line.var1] is MCConstValue
		{
			removeOne = true
			afterId := movedFrom[line.var2]
			afterId = remakeId[afterId]?
			remakeId[line.var1] = afterId
		}

		if line.opcode == "cast" and oPtr[line.var1] == oPtr[line.var2] and oPtr[line.var1] is MCConstValue
		{
			line.var2 = remakeId[line.var2]?
			remakeId[line.var1] = line.var2
			i += 1
		} else if removeOne{
			i += 1
		} else if canRemove
		{
			i += 2
		}else{
			for j : 5
			{
				id := line.var1&[j]
				if IsOpcodeUsesVar(line.opcode,j)
					id = remakeId[id]?
				line.var1&[j] = id
			}
			cPtr[c++] = line
			i += 1
		}
	}

	return bldr.GenerateFunc()
}
