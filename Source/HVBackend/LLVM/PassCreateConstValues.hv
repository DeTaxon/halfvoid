

PassCreateConstValues := !(MCFunction^ fnc) ->MCFunction^
{
	// i should check if cast needed, but for 99.9% usage it will be true
	@once GenMCTable()
	tbl := ref OpcodeMustConstTable


	ctx := MakeGreedyPass(fnc,4,6)
	cPtr := ctx.cPtr
	c := ref ctx.cmdsSize
	oPtr := ctx.oPtr
	o := ref ctx.objsSize

	iPtr := fnc.Lines.GetPointer()

	toConstVar := (MCObject obj) ==> int
	{
		return ctx.PushConstVar(NormalizeType(obj.GetType()))
	}
	makeConstVar := (int id) ==> int
	{
		obj := ref oPtr[id]
		result = ctx.PushConstVar(NormalizeType(obj.GetType()))
		cPtr[c++] = MCLine("mov",result,id)
	}

	i := 0
	fncLinesSize := fnc.Lines.Size()
	while i < fncLinesSize
	{
		it := ref iPtr[i]
		switch it.opcode
		{
		case "mov"

			ob1 := ref oPtr[it.var1]
			ob2 := ref oPtr[it.var2]

			if IsVarType(ob1) and IsVarType(ob2)
			{
				cnstId := toConstVar(ob2)
				cPtr[c++] = MCLine("mov",cnstId,it.var2)
				cPtr[c++] = MCLine("mov",it.var1,cnstId)
			}else{
				cPtr[c++] = it
			}
			i += 1

		case "call_start"
			stLine := it
			i += 1

			if IsVarType(oPtr[stLine.var2])
			{
				cnstId := makeConstVar(stLine.var2)
				stLine.var2 = cnstId
			}

			varConsts := HybridQueue.{int,16}
			while iPtr[i].opcode != "call_end"
			{
				vr := ref fnc.Lines[i]
				assert(vr.opcode == "load_var")

				obj := ref fnc.Objects[vr.var1]
				if IsObjectVariable(obj)
				{
					cnstId := toConstVar(obj)
					varConsts.Push(cnstId)
					cPtr[c++] = MCLine("mov",cnstId,vr.var1)
				}else{
					varConsts.Push(vr.var1)
				}
				i += 1
			}
			cPtr[c++] = stLine
			cPtr[c++] = MCLine("load_var",varConsts[^])
			cPtr[c++] = MCLine("call_end")
			i += 1
		case "switch_start"
			stLine := it
			i += 1

			if IsVarType(oPtr[stLine.var1])
			{
				cnstId := makeConstVar(stLine.var1)
				stLine.var1 = cnstId
			}
			cPtr[c++] = stLine
			while iPtr[i].opcode != "switch_end"
			{
				cPtr[c++] = iPtr[i]
				i += 1
			}
			cPtr[c++] = iPtr[i]
			i += 1
		case "asm_start"
			stLine := it
			i += 1

			clobObjs := HybridQueue.{int,16}
			varConsts := HybridQueue.{int,16}
			while iPtr[i].opcode != "asm_end"
			{
				vr := ref fnc.Lines[i]
				if vr.opcode == "load_var"
				{
					obj := ref oPtr[vr.var1]
					if IsObjectVariable(obj)
					{
						cnstId := toConstVar(obj)
						varConsts.Push(cnstId)
						cPtr[c++] = MCLine("mov",cnstId,vr.var1)
					}else{
						varConsts.Push(vr.var1)
					}
				}else if vr.opcode == "clob_str"{
					clobObjs.Push(vr.var1)
				}else{
					assert(false)
				}
				i += 1
			}
			cPtr[c++] = stLine
			for it : clobObjs
				cPtr[c++] = MCLine("clob_str",it)
			for it : varConsts
				cPtr[c++] = MCLine("load_var",it)
			cPtr[c++] = MCLine("asm_end")
			i += 1
		case void
			if tbl.Contain(it.opcode)
			{
				inf := ref tbl[it.opcode]

				thisLine := it

				if inf.opcode == "noop"
				{
					cPtr[c++] = thisLine
				}else{
					
					vars := int[5]
					for i : 5
					{
						assert(thisLine.var1&[i] < o)
						ob := ref oPtr[thisLine.var1&[i]]
						if inf.var1&[i] != 0 and IsObjectVariable(ob)
						{
							vars[i] = makeConstVar(thisLine.var1&[i])
						}else{
							vars[i] = thisLine.var1&[i]
						}
					}
					cPtr[c++] = MCLine(thisLine.opcode,vars[0],vars[1],vars[2],vars[3],vars[4])
				}
			}else{
				printf("LLVM there is no const use in table for opcode %s\n",it.opcode.ToCStr())
				assert(false)
			}
			i += 1
		}
	}

	return ctx.GenerateFunc()
}

OpcodeMustConstTable := AVLMap.{MCBaseOpcodes,MCLine}


IsVarType := !(MCObject obj) -> bool
{
	if obj is MCVariable
		return true
	if obj is MCGlobalVariable
		return true
	return false
}
GenMCTable := !() -> void
{
	oldAlc := SwapAllocator(GetDefaultAllocator())
	defer SetAllocator(oldAlc)

	tbl := ref OpcodeMustConstTable
	//tbl["call_start"] = MCLine("noop")
	tbl["load_var"] = MCLine("noop",1)
	tbl["call_end"] = MCLine("noop")

	tbl["jmp"] = MCLine("noop")
	tbl["jmp_if_bool"] = MCLine("noop",0,1)
	tbl["label"] = MCLine("noop")

	tbl["load_element"] = MCLine("noop",0,1,1,1,1)
	tbl["get_pointer"] = MCLine("noop")

	tbl["cast"] = MCLine("noop",0,1)

	tbl["cmp"] = MCLine("noop",0,1,0,1)

	tbl["and"] = MCLine("noop",0,1,1)
	tbl["or"] = MCLine("noop",0,1,1)
	tbl["xor"] = MCLine("noop",0,1,1)
	tbl["not"] = MCLine("noop",0,1)

	tbl["shl"] = MCLine("noop",0,1,1)
	tbl["sshr"] = MCLine("noop",0,1,1)
	tbl["ushr"] = MCLine("noop",0,1,1)

	tbl["add"] = MCLine("noop",0,1,1)
	tbl["sub"] = MCLine("noop",0,1,1)
	tbl["mul"] = MCLine("noop",0,1,1)
	tbl["div"] = MCLine("noop",0,1,1)
	tbl["mod"] = MCLine("noop",0,1,1)

	tbl["atomic_add"] = MCLine("noop",0,0,1)
	tbl["atomic_sub"] = MCLine("noop",0,0,1)
	tbl["atomic_xchg"] = MCLine("noop",0,0,1)

	tbl["sqrt"] = MCLine("noop",0,1)
	tbl["cos"] = MCLine("noop",0,1)
	tbl["sin"] = MCLine("noop",0,1)


	tbl["vec_scalar_mul"] = MCLine("noop",0,1,1)

	tbl["vec_shuffle_begin"] = MCLine("noop",0,1)
	tbl["vec_shuffle_index"] = MCLine("noop",0,1)
	tbl["vec_shuffle_zero"] = MCLine("noop",0)
	tbl["vec_shuffle_end"] = MCLine("noop",0)

	tbl["memset"] = MCLine("noop",1,1,1)
	tbl["clean"] = MCLine("noop")

	tbl["max"] = MCLine("noop",0,1,1)
	tbl["min"] = MCLine("noop",0,1,1)


	tbl["debug_set_file"] = MCLine("noop")
	tbl["debug_set_line"] = MCLine("noop")
	tbl["debug_set_var_name"] = MCLine("noop")
	tbl["assert"] = MCLine("noop",1)

	tbl["va_start"] = MCLine("noop",1)
	tbl["va_arg"] = MCLine("noop",0,1)
	tbl["va_end"] = MCLine("noop",1)

	tbl["store"] = MCLine("noop",1,1)
	tbl["load"] = MCLine("noop",0,1)
	tbl["get_field_ptr"] = MCLine("noop",0,1,1,1,1)
	tbl["get_array_elem_ptr"] = MCLine("noop",0,1,1,1,1)

	tbl["asm_start"] = MCLine("noop")
	tbl["asm_end"] = MCLine("noop")

	for it : tbl
	{
		if it.var1 != 0 or it.var2 != 0 or it.var3 != 0 or it.var4 != 0 or it.var5 != 0
			it.opcode = "mov"
	}
}
