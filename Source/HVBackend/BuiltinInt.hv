AppendClass BuiltInIntEqAndOper
{
	IsMCInlined := virtual true
	WriteFuncCallMC := virtual !(MCBuildContext^ ctx,BoxExeObj^[] indexes) -> WriteMCResult
	{
		var1 := indexes[0].WriteMC(ctx)
		var2 := indexes[1].WriteMC(ctx)
		switch llvm
		{
		case "add"
			ctx.lines.Push(MCLine("add",var1.CreatedId,var1.CreatedId,var2.CreatedId))
		case "sub"
			ctx.lines.Push(MCLine("sub",var1.CreatedId,var1.CreatedId,var2.CreatedId))
		case "mul"
			ctx.lines.Push(MCLine("mul",var1.CreatedId,var1.CreatedId,var2.CreatedId))
		case void
			assert(false) //TODO float
		}
	}
}
AppendClass BuiltInIntBase
{
	IsMCInlined := virtual true
	WriteFuncCallMC := virtual !(MCBuildContext^ ctx,BoxExeObj^[] indexes) -> WriteMCResult
	{
		var1 := indexes[0].WriteMC(ctx)
		var2 := indexes[1].WriteMC(ctx)

		resInd := ctx.CreateVar(GTypeBool)
		result.CreatedId = resInd

		switch llvm
		{
		case "icmp eq"
			ctx.lines.Push(MCLine("cmp",resInd,"==",var1.CreatedId,var2.CreatedId))
		case "icmp ne"
			ctx.lines.Push(MCLine("cmp",resInd,"!=",var1.CreatedId,var2.CreatedId))
		case void
			assert(false) //TODO float, other cmp
		}
	}
}
