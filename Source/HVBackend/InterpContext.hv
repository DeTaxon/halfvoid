
MCInterpContext := class
{
	funcs := AVLMap.{BoxFuncBody^,MCFunction^} 

	loadedDlls := AVLMap.{CLib^,Library^}
	declarePtrs := AVLMap.{void^,void^}

	//VTableFunctions := HVTable2.{BuildInVirtualFunctionCall^,void^}
	
	functionPointers := HVTable2.{MCFunction^,void^}
	closureData := HVTable2.{void^,HV_closure_func_data^}
	
	vtableFunctions := HVTable2.{BoxFuncBody^,void^}

	LoadGlobFromMem := !(void^ mem, BoxExeConstObj^ obj) -> void
	{
		if obj is BoxExeInt
		{
			obj->{BoxExeInt^}.Value = mem->{int^}^
		}else{
			assert(false)
		}
	}

	GetFunctionPointer := !(MCFunction^ fnc) -> void^
	{
		funcPointer := void^
		functionPointers.Key.Get(fnc, (x) ==> { funcPointer = x})
		if funcPointer != null
			return funcPointer

		argsCount := fnc.InputsIndxCount
		newClosure := calloc((HV_closure_func_data->TypeSize + void^->TypeSize*argsCount),1)->{HV_closure_func_data^}

		closure := ffi_closure_alloc(128,newClosure.func_pointer&) //TODO unconst
		PopulateCIF(fnc,newClosure.ffi_cif[0]&,newClosure.closure_types[0]&)

		res := ffi_prep_closure_loc(closure,newClosure.ffi_cif[0]&,HV_closure_func,newClosure,newClosure.func_pointer)

		newClosure.interpCntx = this&
		newClosure.interpFunc = fnc

		funcPointer = newClosure.func_pointer
		functionPointers.Add(fnc,funcPointer)
		closureData.Add(funcPointer,newClosure)
		return funcPointer
	}

	UpdateFunctionPointer := !(BoxFuncBody^ changedFunc) -> void
	{
		if not vtableFunctions.Key.ContainSome(changedFunc)
			return void
		fncPointer := vtableFunctions.Key.GetOne(changedFunc)

		functionPointers.Value.RemoveAll(fncPointer)
		iFunc := GetMCFunc(changedFunc)
		functionPointers.Add(iFunc,fncPointer)

		closure := closureData.Key.GetOne(fncPointer)
		assert(closure != null)
		closure.interpFunc = iFunc
	}

	PopulateCIF := !(MCFunction^ fnc, void^ resCIF,void^^ types) -> void
	{
		resultType := void^
		if fnc.ResultIndex != 0
		{
			resultType = ThisToCif(fnc.Objects[fnc.ResultIndex].GetType())
		}else{
			resultType = ffi_type_void
		}
		hv := fnc.BaseFunction->{BoxFuncBody^}
		fType := hv.GetType()->{TypeFunc^}

		typesSize := 0

		for i : fnc.InputsIndxCount
		{
			j := i + fnc.InputsIndxStart
			types[typesSize] = ThisToCif(fnc.Objects[j].GetType())
			typesSize += 1
		}
		ffi_prep_cif(resCIF,2, typesSize,resultType,types[0]&)
		
	}
	ThisToCif := !(Type^ itType) -> void^
	{
		if itType == GTypeChar.GetPoint() or itType == GTypeStr
		{
			return ffi_type_pointer
		}else if itType is in  TypePoint{
			return ffi_type_pointer
		}else if itType == GTypeDouble{
			return ffi_type_double
		}else if itType == GTypeInt or itType == GTypeTypeId {
			return ffi_type_sint32
		}else if itType == GTypeU32{
			return ffi_type_uint32
		}else if itType == GTypeU64{
			return ffi_type_uint64
		}else if itType == GTypeS64{
			return ffi_type_sint64
		}else if itType == GTypeBool{
			return ffi_type_sint8
		}else if itType == GTypeU8{
			return ffi_type_uint8
		}else if itType == GTypeChar {
			return ffi_type_uint8
		}else if itType is TypeVector {
			return ffi_type_pointer
		}else if itType is TypeEnum {
			return ffi_type_sint32
		}else{
			printf("unknown type %s\n",itType.GetBADStr().Str())
			assert(false)
		}
	}

	GetFuncByPointer := !(void^ ptr) -> MCFunction^
	{
		res := MCFunction^
		functionPointers.Value.Get(ptr,(x) ==> { res = x })
		return res
	}

	GetMCFunc := !(BoxFuncBody^ itm) -> MCFunction^
	{
		cb := () ==> {
			return this.innerGetMCFunc(itm)
		}
		if CurrentThread == GCompileThread
		{
			return cb()
		}else{
			res := MCFunction^
			GCompileThread.CreateTask(() ==> {
				res = cb()
			}).AwaitCompletion()
			return res
		}
	}
	innerGetMCFunc := !(BoxFuncBody^ itm) -> MCFunction^
	{
		return funcs[itm]?

		assert(itm is in BoxFuncBody)

		result = BCFuncs.GetInterpFunc(itm)

		funcs[itm] = result
	}

	Reload := !(HotloadContext^ ctx) -> void
	{
		ReloadFunctions(ctx)
	}
	ReloadFunctions := !(HotloadContext^ ctx) -> void
	{
		HotloadStream << "Reloading funcs " << ctx.ChangedFunctions.Size() << "\n"
		for newFunc : ctx.ChangedFunctions
		{
			if funcs.Contain(newFunc)
			{
				funcs.Remove(newFunc)
			}
		}

		for virtFunc : ctx.ChangedVirtualFunctions
		{
			UpdateFunctionPointer(virtFunc)
		}
	}

	GetClibDll := !(CLib^ cLib, Str funcName) -> Library^
	{
		return loadedDlls[cLib]?

		useLib := Library^
		for it : cLib.dlls
		{
			useLib = GetLibrary(it)
			if useLib != null
				break
		}
		if useLib == null
		{
			printf("could not load library for function %s\n",funcName)
			exit(0)
		}
		loadedDlls[cLib] = useLib
		return  useLib
	}
 	DeclareToPtr := !(BoxFuncDeclare^ dclr) -> void^
	{
		return declarePtrs[dclr]?

		if dclr.GetName() == "tanf" //TODO remove
			return hvr_tanf

		for space : CodeSpaces
		{
			for module : space.Modules
			{
				if module is not CLib
					continue

				cLib := module->{CLib^}
				if not cLib.IsMyFunc(dclr)
					continue
				useLib := GetClibDll(cLib,dclr.GetName())

				fnc := useLib.Get(dclr.GetName().Str())
				if fnc == null
				{
					continue
				}
				declarePtrs[dclr] = fnc
				return fnc
			}
		}
		assert(false)
		printf("could not load function declare\n")
		exit(0)
	}
}

HV_closure_func := !(void^ cif,void^ ret,void^^ args,HV_closure_func_data^ data) -> void
{
	mc := data.interpFunc
	hv := mc.BaseFunction->{BoxFuncBody^}
	fType := hv.GetType()->{TypeFunc^}

	step2 := void^[120]
	thisArgs := MakeVectorOnStack.{void^,20}()
	//printf("closure %i\n",data.interpFunc.InputsIndxCount)
	for i : data.interpFunc.InputsIndxCount
	{
		step2[i] = args[i]
		//thisArgs.Push(step2[i]&)
		thisArgs.Push(args[i])
		//printf("clsr %p\n",args[i])
	}
	MCInterpFunction(data.interpCntx,data.interpFunc,thisArgs,ret)
}

hvr_tanf := !(float inp) -> float
{
	return tanf(inp)
}

HV_closure_func_data := class
{
	func_pointer := void^
	ffi_cif := u8[128]
	interpCntx := MCInterpContext^
	interpFunc := MCFunction^

	closure_types := void^[1] // must be last!
}
