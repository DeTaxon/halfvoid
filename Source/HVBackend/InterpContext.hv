
MCInterpContext := class
{
	funcs := AVLMap.{BoxFuncBody^,MCFunction^} 

	loadedDlls := AVLMap.{CLib^,Library^}
	declarePtrs := AVLMap.{void^,void^}

	globalVariables := AVLMap.{GlobalVar2^,void^}
	vtableToClass := AVLMap.{void^,BoxClass^}

	GetGlobalVarMem := !(GlobalVar2^ vr) -> void^
	{
		return globalVariables[vr]?

		varSize := vr.GetType().GetSize()
		result = calloc(varSize,1)
		globalVariables[vr] = result
	}
	GetGlobalVarFromMem := !(void^ val) -> GlobalVar2^
	{
		for it, ind : globalVariables
		{
			if it == val
				return ind
		}
		return null
	}
	GetClassFromVTable := !(GlobalVar2^ vr) -> BoxClass^
	{
		if vr == null
			return null
		return vtableToClass[vr]?
		return null
	}

	GetMCFunc := !(BoxFuncBody^ itm) -> MCFunction^
	{
		return funcs[itm]?

		itm.ParseBody()
		itm.WaitReadyState()

		buildCtx := MCBuildContext
		buildCtx.Init()
		itm.CreateMCFunction(buildCtx&)
		result = buildCtx.CreateMCFunction()

		funcs[itm] = result
	}

	DeclareToPtr := !(BoxFuncDeclare^ dclr) -> void^
	{
		return declarePtrs[dclr]?

		for space : CodeSpaces
		{
			for module : space.Modules
			{
				if module is not CLib
					continue

				cLib := module->{CLib^}
				if not cLib.IsMyFunc(dclr)
					continue

				if not loadedDlls.Contain(cLib)
				{
					useLib := Library^
					for it : cLib.dlls
					{
						useLib = GetLibrary(it)
						if useLib != null
							break
					}
					if useLib == null
					{
						printf("could not load library for function %s\n",dclr.GetName())
						exit(0)
					}
					loadedDlls[cLib] = useLib
				}
				fnc := loadedDlls[cLib].Get(dclr.GetName())
				if fnc == null
				{
					printf("could not load function %s\n",dclr.GetName())
					exit(0)
				}
				declarePtrs[dclr] = fnc
				return fnc
			}
		}
		assert(false)
		printf("could not load function declare, HOW?\n")
		exit(0)
	}
}

