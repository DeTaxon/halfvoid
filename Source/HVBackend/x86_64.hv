
CompileAndRunCode_x86_64 := !(BoxFuncBody^ funcToRun) -> InterpWork^
{
	result = new InterpWork(CurrentTask)
	oldWork := CurrentWork
	CurrentWork = result

	ctx := MCBuildContext_x86_64

	fnc := GInterpCntx.GetMCFunc(funcToRun)

	ctx.Compile(fnc)

	bigMem := PageMemory
	bigMem.Create(16*1024,"rwe") //TODO unconst

	ptr := bigMem.GetPointer()
	memset(ptr,0,bigMem.Size())

	ctx.ResultData.Read(ptr,ctx.ResultData.Size())

	ctx.FixLabels(ptr)

	createdFunc := ptr->{!()^->void}
	//assert(false)
	createdFunc()

	CurrentWork->{InterpWork^}.isDone = true
	CurrentWork = oldWork
}


MCBuildContext_x86_64 := class
{
	ResultData := TEchoStream

	labelTarget := AVLMap.{int,int} // left, target, right
	labelPos := AVLMap.{int,int}

	doubleValues := List.{Tuple.{double,int,int}} // value, mov position, value position

	Compile := !(MCFunction^ fnc) -> void
	{
		fnc = PassRemoveSpaceship(fnc)
		fnc = PassSimplifyVectors(fnc)
		fnc = PassRemoveVoidParams(fnc)
		fnc = PassRemoveReferences(fnc)

		fnc.Print()

		fnc.ComputeStackFrame()
		stackSize := fnc.StackFrameSize

		Push("rbp")
		ResultData << "\x48\x89\xE5" // mov $rbo,$rsp

		ResultData << "\x48\x81\xEC" // sub %rsp,stackSize
		ResultData.Write(stackSize&,4)

		X86WriteBody(ResultData,fnc)

		ResultData << "\x48\x81\xc4" // add %rsp,stackSize
		ResultData.Write(stackSize&,4)

		Pop("rbp")
		ResultData << "\xC3" // ret

		PrintValues()
	}
	FixLabels := !(void^ ptr) -> void
	{
		for lbl,id : labelTarget
		{
			diff := labelPos[id] - (lbl + 4) // 4 - size of int, ptr offset
			ptr->{u8^}[lbl]&->{int^}^ = diff
		}
		for it : doubleValues
		{
			diff := it.2 - it.1 - 4
			ptr->{u8^}[it.1]&->{int^}^ = diff 
		}
	
	}
	getObjsStackOffset := !(MCFunction^ fnc, int index) -> s32
	{
		assert(fnc.StackOffsets != null)

		plainOffset := fnc.StackOffsets[index]
		return plainOffset - fnc.StackFrameSize
		
	}
	X86WriteBody := !(TEchoStream strm, MCFunction^ fnc) -> void
	{
		objs := fnc.Objects.GetPointer()
		lines := fnc.Lines.GetPointer()
	
		assert(objs != null and lines != null)
	
	
		for i : fnc.Lines.Size()
		{
			line := lines[i]
	
			switch line.opcode
			{
			case "debug_set_file"
			case "debug_set_line"

			case "llvm_getelementptr"
				tp := objs[line.var2].GetType()

				if tp is in TypePoint {
					tpSize := tp.Base.GetSize()
					MovU64ToReg(fnc,"rax",tpSize)
					Mov(fnc,"rdx",line.var3)
					ResultData << "\x48\x0F\xAF\xC2" // imul 
					Mov(fnc,"rdx",line.var2)
					ResultData << "\x48\x01\xD0" // add rax rdx
					Mov(fnc,line.var1,"rax")

				}else{
					assert(false)
				}
			case "llvm_store"

				if objs[line.var1].GetType() == objs[line.var2].GetType() {
					Mov(fnc,"rax",line.var2)
					Mov(fnc,line.var1,"rax")
				}else{
					Mov(fnc,"rcx",line.var1)
					Mov(fnc,"rax",line.var2)
					size := objs[line.var2].GetType().GetSize()

					switch size
					{
					case 1 ResultData << "\x88\x01"
					case 2 ResultData << "\x66\x89\x01"
					case 4 ResultData << "\x89\x01" //TODO
					case 8 ResultData << "\x48\x89\x01" //TODO
					}
					
				}
			case "llvm_load"

				if objs[line.var1].GetType() == objs[line.var2].GetType() {
					Mov(fnc,"rax",line.var2)
					Mov(fnc,line.var1,"rax")
				}else{
					size := objs[line.var2].GetType().GetSize()

					Mov(fnc,"rcx",line.var2)
					switch size
					{
					case 1 ResultData << "\x48\x8A\x01"
					case 2 ResultData << "\x48\x0F\xBF\x01" //TODO
					case 4 ResultData << "\x48\x8B\x01" //TODO
					case 8 ResultData << "\x48\x8B\x01" //TODO
					}
					Mov(fnc,line.var1,"rax")
				}

			case "cmp"
				Mov(fnc,"rdx",line.var2)
				Mov(fnc,"rax",line.var4)
				ResultData << "\x48\x3B\xD0" //cmp

				switch line.V3Cond()
				{
					case "==" ResultData << "\x0F\x94"
					case "!=" ResultData << "\x0F\x95"
					case "<=" ResultData << "\x0F\x9E"
					case "<" ResultData << "\x0F\x9C"
					case ">=" ResultData << "\x0F\x9D"
					case ">" ResultData << "\x0F\x9F"
				}
				ResultData << "\xC0"
				Mov(fnc,line.var1,"rax")

			case in !["add","sub","mul"] //TODO signes aware
				Mov(fnc,"rax",line.var2)
				Mov(fnc,"rdx",line.var3)
				ResultData << "\x48"
				switch line.opcode
				{
				case "add" ResultData << "\x01\xD0"
				case "sub" ResultData << "\x29\xD0"
				case "mul" ResultData << "\x0F\xAF\xC2"
				}
				Mov(fnc,line.var1,"rax")
			case "div"
				Mov(fnc,"rax",line.var2)
				Mov(fnc,"rcx",line.var3)
				MovU64ToReg(fnc,"rdx",0)
				ResultData << "\x48\xF7\xF9"
				Mov(fnc,line.var1,"rax")
			case "mod"
				Mov(fnc,"rax",line.var2)
				Mov(fnc,"rcx",line.var3)
				MovU64ToReg(fnc,"rdx",0)
				ResultData << "\x48\xF7\xF9"
				Mov(fnc,line.var1,"rdx")

			case "jmp_if_bool"
				Mov(fnc,"rax",line.var2)
				x := 0
				ResultData << "\x3C" // cmp al and 0
				ResultData.Write(x&,1)
				ResultData << "\x0F\x85" 
				labelTarget[line.var1] = strm.Size()->{int}
				ResultData.Write(x&,4)
			case "jmp"
				ResultData << "\xE9"
				x := 0
				labelTarget[line.var1] = strm.Size()->{int}
				ResultData.Write(x&,4)
			case "label"
				labelPos[line.var1] = strm.Size()

			case "call_start"
				fncId := line.var2
				resId := line.var1
				i += 1

				usedInts := 0
				usedFloats := 0
				while lines[i].opcode != "call_end"
				{
					vr := lines[i]
					assert(vr.opcode == "load_var")

					tp := objs[vr.var1].GetType()

					if IsInt(tp) or tp is in TypePoint or tp == GTypeBool {
						if (usedInts < 6) {
							switch usedInts
							{
							case 0 Mov(fnc,"rdi",vr.var1)
							case 1 Mov(fnc,"rsi",vr.var1)
							case 2 Mov(fnc,"rdx",vr.var1)
							case 3 Mov(fnc,"rcx",vr.var1)
							}
							//Mov(fnc,!["rdi","rsi","rdx","rcx","R8","R9"][usedInts],vr.var1)

							usedInts += 1
						}else {
							assert(false) //TODO
						}
					}else  if tp == GTypeFloat or tp == GTypeDouble {
						//TODO disable float to double cast
						Mov(fnc,"xmm0",vr.var1) //TODO other registers
						usedFloats += 1
					}else{
						assert(false) //TODO floats
					}

					i += 1
				}
				MovU64ToReg(fnc,"rax",usedFloats)

				fncObj := objs[fncId]

				if fncObj is MCConstFunction {
					fncHV := fncObj.GetValue()
					ptr := GInterpCntx.DeclareToPtr(fncHV->{BoxFuncDeclare^})
					MovPtrToReg(fnc,"rcx",ptr) //TODO use R10 register
					ResultData << "\xFF\xD1" // call *rcx
				}else {
					assert(false) //TODO function pointers
				}

				if resId != 0
				{
					//TODO return float value
					Mov(fnc,resId,"rax")
				}

			case "mov"

				tp := objs[line.var2].GetType()

				if tp == GTypeFloat or tp == GTypeDouble {
					Mov(fnc,"xmm0",line.var2)
					Mov(fnc,line.var1,"xmm0")
				}else{
					Mov(fnc,"rax",line.var2)
					Mov(fnc,line.var1,"rax")
				}
			
			case "cast"
				tpTo := objs[line.var1].GetType()
				tpFrom := objs[line.var2].GetType()

				if tpTo is in TypePoint and tpFrom is in TypePoint
				{
					MovStackToRax(fnc,line.var2)
					MovRaxToStack(fnc,line.var1)
				}else if IsInt(tpTo) and IsInt(tpFrom) {
					//if tpTo == GTypeS64 and tpFrom == GTypeInt {
					//	Mov(fnc,"rax",line.var2)
					//	ResultData << "\x48\x98"
					//	Mov(fnc,line.var1,"rax")
					//}else{ 
						Mov(fnc,"rax",line.var2)
						Mov(fnc,line.var1,"rax")
						//printf("x86_64, unsupported integer cast\n")
						//assert(false)
					//}
				}else if tpTo == GTypeFloat and tpFrom == GTypeDouble{
					Mov(fnc,"xmm0",line.var2)
					ResultData << "\xF2\x0F\x5A\xC8"
					Mov(fnc,line.var1,"xmm1")
				}else if tpTo == GTypeDouble and tpFrom == GTypeFloat{
					Mov(fnc,"xmm0",line.var2)
					ResultData << "\xF3\x0F\x5A\xC8"
					Mov(fnc,line.var1,"xmm1")
				}else{
					printf("x86_64, unsupported cast\n")
					assert(false)
				}
			case "get_pointer"
				assert(objs[line.var2] is MCVariable)
				strm << "\x48\x8D\x85"
				x := getObjsStackOffset(fnc,line.var2)
				strm.Write(x&,4)
				MovRaxToStack(fnc,line.var1)

			case "clean"
				assert(objs[line.var1] is MCVariable)

				MovU64ToReg(fnc,"rax",0)
				Mov(fnc,line.var1,"rax")
			case "memset"

				//Mov(fnc,"rcx",line.var3)
				//Mov(fnc,"rax",line.var2)
				//Mov(fnc,"rdi",line.var1)
				//strm << "\xF3\xAA" // rep stob
				Mov(fnc,"rdi",line.var1)
				Mov(fnc,"rsi",line.var2)
				Mov(fnc,"rdx",line.var3)
				MovPtrToReg(fnc,"rcx",memset)
				ResultData << "\xFF\xD1" // call *rcx
				
				
	
			case void
				printf("x86_64, unsupported opcode %s\n",line.opcode.ToCStr())
				assert(false)
	
			}
		}
	}
	PrintValues := !() -> void
	{
		for it,i : doubleValues
		{
			x := it.0
			it.2 = ResultData.Size()
			ResultData.Write(x&,8)
		}
	}
	Push := !(X86Register reg) -> void
	{
		dt := "\x50"[0] + reg->{int}
		ResultData.Write(dt&,1)
	}
	Pop := !(X86Register reg) -> void
	{
		dt := "\x58"[0] + reg->{int}
		ResultData.Write(dt&,1)
	}
	MovRaxToStack := !(MCFunction^ fnc,int indx) -> void
	{
		Mov(fnc,indx,"rax")
	}
	MovStackToRax := !(MCFunction^ fnc,int indx) -> void
	{
		Mov(fnc,"rax",indx)
	}
	Mov := !(MCFunction^ fnc,int indx,X86Register reg) -> void { Mov(fnc,false,reg,indx) }
	Mov := !(MCFunction^ fnc,X86Register reg,int indx) -> void { Mov(fnc,true,reg,indx) }
	Mov := !(MCFunction^ fnc,bool toReg,X86Register reg, int indx) -> void
	{
		obj := ref fnc.Objects[indx]

		size := obj.GetType().GetSize()

		regIndx := reg->{int} mod 8

		isFloatReg := reg->{int} >= 16

		datas := char[4]
		memcpy(datas[0]&,"\x48\x8B\x85"[0]&,3)
		datas[2] += (regIndx->{int} shl 3)

		if obj is MCVariable or obj is MCConstValue {

			switch size
			{
			case 1 datas[1] = "\x8A\x88"[toReg ?: 0 : 1]
			case 2 datas[1] = "\x8B\x89"[toReg ?: 0 : 1]
			case 4 datas[1] = "\x8B\x89"[toReg ?: 0 : 1]
			case 8 datas[1] = "\x8B\x89"[toReg ?: 0 : 1]
			}
		
			if size == 1 and toReg{
				datas[1] = "\x0F"[0]
				datas[2] = "\xBE"[0]
				datas[3] = "\x85"[0] + (reg->{int} shl 3)
				ResultData.Write(datas[0]&,4)
			} else if size == 2 and toReg{
				datas[1] = "\x0F"[0]
				datas[2] = "\xBF"[0]
				datas[3] = "\x85"[0] + (reg->{int} shl 3)
				ResultData.Write(datas[0]&,4)
			} else if size == 4 and toReg{
				if isFloatReg {
					datas[0] = "\xF3\xF2"[size == 4 ?: 0 : 1]
					datas[1] = "\x0F"[0]
					datas[2] = "\x10\x11"[toReg ?: 0 : 1]
					datas[3] = "\x85"[0] + (regIndx->{int} shl 3)
					ResultData.Write(datas[0]&,4)
				}else{
					datas[1] = "\x63"[0]
					datas[2] = "\x85"[0] + (reg->{int} shl 3)
					ResultData.Write(datas[0]&,3)
				}
			}else if not toReg and size == 1 {
				ResultData.Write(datas[1]&,2)
			}else{
				if isFloatReg {
					datas[0] = "\xF3\xF2"[size == 4 ?: 0 : 1]
					datas[1] = "\x0F"[0]
					datas[2] = "\x10\x11"[toReg ?: 0 : 1]
					datas[3] = "\x85"[0] + (regIndx->{int} shl 3)
					ResultData.Write(datas[0]&,4)
				}else{
					ResultData.Write(datas[0]&,3)
				}
			}
			x := getObjsStackOffset(fnc,indx)
			ResultData.Write(x&,4)
		}else if obj is MCConstInteger {
			assert(toReg)

			datas[1] = "\xC7"[0]
			datas[2] = "\xC0"[0] + reg->{int}

			ResultData.Write(datas[0]&,3)
			x := obj&->{MCConstInteger^}.GetValue()
			ResultData.Write(x&,4)

		}else if obj is MCConstDouble {
			assert(toReg)
			assert(reg >= 16) // float register

			regPos := reg->{int} - 16
			
			ResultData << "\xF2\x0F\x10\x05"

			doubleValues.Emplace(obj.GetValue(),ResultData.Size(),0)

			x := s32
			ResultData.Write(x&,4)

		}else if obj is MCConstString {
			assert(toReg)
			MovPtrToReg(fnc,reg,obj&->{MCConstString^}.GetValue().CStr())
		}else{
			assert(false)
		}

	}
	MovU64ToReg := !(MCFunction^ fnc,X86Register reg, u64 val) -> void
	{
		MovPtrToReg(fnc,reg,val&->{void^^}^)
	}
	MovPtrToReg := !(MCFunction^ fnc,X86Register reg, void^ ptr) -> void
	{
		datas := char[2]
		datas[0] = "\x48"[0]
		datas[1] = "\xB8"[0] + reg->{int}
		ResultData.Write(datas[0]&,2)
		ResultData.Write(ptr&,8)
	}
}

X86Register := enum
{
	"rax","rcx","rdx","rbx","rsp","rbp","rsi","rdi",
	"r8","r9","r10","r11","r12","r13","r14","r15",

	"xmm0","xmm1","xmm2","xmm3","xmm4","xmm5","xmm7",
	"xmm8","xmm9","xmm10","xmm11","xmm12","xmm13","xmm14","xmm15"
}


