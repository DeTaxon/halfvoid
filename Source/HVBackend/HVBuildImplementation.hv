InitRunContext := !() -> void
{
	initedRun := static false
	HV = new HVContextImplementation
}

HVContextImplementation := class extend HV_Context
{
	GetType := virtual !(Str typeName) -> HV_Object^ 
	{
		indnt := TokenIndent(typeName)
		asType := ParseType(indnt&)
		if asType == null
			return null
		return asType
	}
	GetTypeObj := virtual !(TypeId tp) -> HV_Object^
	{
		return TypeFromTypeId(tp)
	}
	GetTypeSize := virtual !(HV_Object^ tp) -> int
	{
		if tp is in Type
			return tp.GetSize()
	}
	GetTypeArraySize := virtual !(HV_Object^ tp) -> int
	{
		if tp is TypeVector
			return tp.vecElementCount
		if tp is not in TypeArr
			return 0
		return tp.len
	}
	GetTypePointer := virtual !(HV_Object^ baseType) -> HV_Object^
	{
		typ := baseType->{Type^}
		return typ.GetPoint()
	}
	GetTypeBase := virtual !(HV_Object^ baseType) -> HV_Object^
	{
		typ := baseType->{Type^}
		if typ.Base == null
			return null
		return typ.Base
	}
	GetFuncType := virtual !(HV_Object^[] types,bool[] isReference, HV_Object^ resultType,bool resultReference,bool isVariadicArguments) -> HV_Object^ 
	{
		typesThis := HybridQueue.{Type^,16}
		typesThis.Push(types[^]->{Type^})
		rType := resultType->{Type^}
		fType := GetFuncType(typesThis,isReference,rType,resultReference,isVariadicArguments)
		return fType
	}
	GetTypeGroup := virtual !(HV_Object^ obj) -> TypeGroups
	{
		if obj is in TypeFunc
			return "Function"
		if obj is in TypePoint
			return "Pointer"
		if obj is in TypeVector
			return "Vector"
		if obj is in TypeClass
			return "Class"
		if obj is in TypeArr
			return "Array"
		if obj is in TypeStandard
			return "Prime"
	}
	GetTypeId := virtual !(HV_Object^ obj) -> TypeId 
	{
		if obj is not in Type
			return void
		return TypeIdFromType(obj)
	}
	GetTypeClass := virtual !(HV_Object^ obj) -> HV_Class^
	{
		if obj is not in TypeClass
			return null
		return obj.ToClass.hvClass&

	}
	CreateClass := virtual !() -> HV_Class^ 
	{
		newClass := new hvr_Class()

		AllClasses.Push(newClass)

		newClass.hvClass.baseClass =  newClass
		return newClass.hvClass&
	}
	CreateFunction := virtual !(Str funcText) -> HV_Object^
	{
		return StrToFunctionTemplate(funcText)
	}

	CreateInt32 := virtual !(int value) -> HV_Object^
	{
		return GetExeInt(value)
	}
	CreateString := virtual !(Str value) -> HV_Object^
	{
		return GetExeString(value)
	}

	EmitError := virtual !(Str errorMessage) -> void
	{
		CurrentWork?.SetErrorMessage(errorMessage)
	}
	GetFunctionAndHisFriends := virtual !(HV_Object^ func) -> HVFunctionUsage 
	{
		if func is not BoxFuncBody
			return void
		func->{BoxFuncBody^}.ParseBody()
		func.WaitReadyState()

		CodeCheckCtx := MCInterpContext

		c := CollectFunctionsCtx(CodeCheckCtx&,func->{BoxFuncBody^})

		// c.Workarounds()
		c.Collect()


		result.Functions.Resize(c.WriteFunctions.Size())
		for it,i : c.WriteFunctions
			result.Functions[i] = it
		result.Globals.Resize(c.WriteGlobals.Size())
		for it,i : c.WriteGlobals
			result.Globals[i] = it
		result.Classes.Resize(c.UsedClasses.Size())
		for it,i : c.UsedClasses
			result.Classes[i] = it.hvClass&
	}

	GetSSAFunc := virtual !(HV_Object^ fnc) -> HVB_Function^
	{
		if fnc is not in BoxFuncBody
			return null

		return SSAConainer.GetFunc(fnc)
	}
}
HV_FunctionTemplateImp := class extend HV_FunctionTemplate
{
	GetFunction := virtual !() -> HV_Function^ {}
}
