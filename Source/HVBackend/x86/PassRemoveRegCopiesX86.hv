
PassRemoveRegCopies := !(MCFunction^ fnc) ->MCFunction^
{
	bldr := MakeGreedyPass(fnc,4,6)

	oPtr := bldr.oPtr
	cPtr := bldr.cPtr

	objsUsed := Vector.{int}
	objsUsed.Resize(fnc.Objects.Size())
	used := objsUsed.GetPointer()

	iCmds := fnc.Lines.GetPointer()
	cmdsSize := fnc.Lines.Size()

	c := ref bldr.cmdsSize

	for k : fnc.Lines.Size()
	{
		line := iCmds[k]
		used[line.var1] += 1
		used[line.var2] += 1
		used[line.var3] += 1
		used[line.var4] += 1
		used[line.var5] += 1
	}

	i := 0
	while i < cmdsSize
	{
		skips := 0



		if iCmds[i].opcode == "mov" and oPtr[iCmds[i].var2]& is MCConstRegisterX86 and oPtr[iCmds[i].var1]& is in MCVariable
		{
			if i == 25
			{
				v := 494
			}

			k := 1
		
			while true
			{
				if (i + k + 1) >= cmdsSize
					break
				ln1 := iCmds[i+k]
				ln2 := iCmds[i+k+1]
				lnPrev := iCmds[i+k-1]
				if ln1.opcode != "mov"
					break

				usd := used[ln1.var2]

				if ln1.var2 != lnPrev.var1 or used[ln1.var2] != 2
					break


				if ln2.opcode != "mov"
					break

				if oPtr[ln1.var1] is not MCConstRegisterX86 or oPtr[ln2.var2] is not MCConstRegisterX86
					break

				if oPtr[ln1.var1].Value != oPtr[ln2.var2].Value
					break

				if oPtr[ln2.var1]& is not in MCVariable
					break

				skips += 2
				k += 2
			}

		}

		if skips != 0
		{
			cPtr[c++] = MCLine("mov",iCmds[i + skips].var1,iCmds[i].var2)
			i += skips + 1
		}else{
			cPtr[c++] = iCmds[i]
			i += 1
		}
	}

	return bldr.GenerateFunc()
}
