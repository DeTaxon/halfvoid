
CompileAndRunCode_x86_64 := !(BoxFuncBody^ funcToRun) -> InterpWork^
{
	result = new InterpWork(CurrentTask)
	oldWork := CurrentWork
	CurrentWork = result

	ctx := GX86Cntx&

	///createdFunc := ctx.GetFunctionPtr(funcToRun)->{!(int,int,int,int,int,int,int,int,int)^->void}
	///// assert(false)
	///createdFunc(1,2,3,5,8,13,21,34,45)
	
	createdFunc := ctx.GetFunctionPtr(funcToRun)->{!()^->void}
	//assert(false)
	createdFunc()

	CurrentWork->{InterpWork^}.isDone = true
	CurrentWork = oldWork
}

//TODO check sse2 sse4_1 support

//linux fastcall x64
//volatile rax,rdi,rsi,rcx,rdx,r8,r9, xmm0-xmm7
//nonvolatile rbx,rsp,rbp,r12-r15

//windows fastcall x64
//volatile rax,rcx,rdx,r8-r11, xmm0-xmm5
//nonvolatile : r12 - r15, rdi,rsi,rbx,rbp,rsp


x86FuncData := class
{
	funcPtr := void^
}

MCBuildContext_x86_64 := class
{
	bigMem := PageMemory
	memIter := void^

	functions := x86FuncData[BoxFuncBody^]

	funcsToCompile := List.{BoxFuncBody^}

	GetFunctionPtr := !(BoxFuncBody^ fnc) -> void^
	{
		if not functions.Contain(fnc)
		{
			funcsToCompile.PushFront(fnc)
			CompileFuncs()
		}
		return functions[fnc].funcPtr
	}

	GetFuncPromise := !(BoxFuncBody^ fnc) -> void^^
	{
		if not functions.Contain(fnc)
			funcsToCompile.PushFront(fnc)
		return functions[fnc].funcPtr&
	}

	CompileFuncs := !() -> void 
	{
		if memIter == null {
			bigMem.Create(64*1024*1024,"rwe")
			memIter = bigMem.GetPointer()
		}
		while funcsToCompile.Size() != 0
		{
			fnc := funcsToCompile.Pop()

			bc := GInterpCntx.GetMCFunc(fnc)
			
			ctx2 := MCBuildFuncContext_x86_64
			ctx2.eng = this&

			ctx2.Compile(bc)

			funcSize := ctx2.ResultData.Size()
			ctx2.ResultData.Read(memIter,funcSize)

			ctx2.FixLabels(memIter)

			functions[fnc].funcPtr = memIter

			funcSize = (funcSize + 15) shr 4 shl 4
			memIter = memIter->{u8^}[funcSize]&
		}
	}
	ReloadFunctions := !(HotloadContext^ ctx) -> void
	{
		for newFunc : ctx.ChangedFunctions
		{
			if functions.Contain(newFunc)
				funcsToCompile.Push(newFunc)
		}
		CompileFuncs()
	}
}

MCBuildFuncContext_x86_64 := class
{
	eng := MCBuildContext_x86_64^

	ResultData := TEchoStream

	labelTarget := AVLMap.{int,List.{int}} // left, target, right
	labelPos := AVLMap.{int,int}

	doubleValues := List.{Tuple.{double,int,int}} // value, mov position, value position

	Compile := !(MCFunction^ fnc) -> void
	{
		fnc = PassRemoveSpaceship(fnc)
		fnc = PassSimplifyVectors(fnc)
		fnc = PassRemoveVoidParams(fnc)
		fnc = PassRemoveReferences(fnc)
		// fnc = PassOptimizeJumpX86(fnc)
		// fnc.Print()
		fnc = PassApplyRegistersX86(fnc)

		// fnc.Print()

		fnc.ComputeStackFrame()
		stackSize := fnc.StackFrameSize

		//align up to 16 byte
		stackSize = (stackSize + 0xF) and_b 0xFFFFFF0 //todo add extra F

		Push("rbp")
		WriteData(0x48,0x89,0xE5) // mov $rbo,$rsp
		SubRsp(stackSize)

		X86WriteBody(ResultData,fnc)

		AddRsp(stackSize)

		Pop("rbp")
		WriteData(0xC3) // ret

		PrintValues()
	}

	FixLabels := !(void^ ptr) -> void
	{
		for lbls,id : labelTarget
		{
			for lbl : lbls
			{
				diff := labelPos[id] - (lbl + 4) // 4 - size of int, ptr offset
				ptr->{u8^}[lbl]&->{int^}^ = diff
			}
		}
		for it : doubleValues
		{
			diff := it.2 - it.1 - 4
			ptr->{u8^}[it.1]&->{int^}^ = diff 
		}
	
	}
	getObjsStackOffset := !(MCFunction^ fnc, int index) -> s32
	{
		obj := ref fnc.Objects[index]
		if obj is MCConstVarX86
			return obj.GetValue()


		assert(fnc.StackOffsets != null)

		plainOffset := fnc.StackOffsets[index]
		return plainOffset - fnc.StackFrameSize
		
	}
	X86WriteBody := !(TEchoStream strm, MCFunction^ fnc) -> void
	{
		objs := fnc.Objects.GetPointer()
		lines := fnc.Lines.GetPointer()
	
		assert(objs != null and lines != null)

		fileName := Str
		fileName = ""
		fileLine := int
	
		for i : fnc.Lines.Size()
		{
			line := lines[i]
	
			switch line.opcode
			{
			case "debug_set_file"	
				fileName = objs[line.var1]&->{MCConstString^}.GetValue()
			case "debug_set_line"
				fileLine = objs[line.var1]&->{MCConstInteger^}.GetValue()

			case "llvm_getelementptr"
				tp := objs[line.var2].GetType()

				printf("wut %s %s %i\n",tp.GetBADStr().Str(),fileName,fileLine)
				assert(false)
			case "llvm_getelementptr0"
				tpPtr := objs[line.var2].GetType()
				assert(tpPtr is in TypePoint)
				tp := tpPtr.Base

				if tp is TypeClass {
					assert(objs[line.var3] is MCConstInteger)
					indx := objs[line.var3]&->{MCConstInteger^}.GetValue()

					cls := tp->{TypeClass^}.ToClass

					offst := cls.GetFieldByIndexRaw(indx).MemOffset

					r := X86Register

					if objs[line.var2] is MCConstRegisterX86 {
						r = objs[line.var2]&->{MCConstRegisterX86^}.GetValue()
					}else{
						r = "rax"
						Mov(fnc,"rax",line.var2)
					}

					WriteData(0x48,0x81,0xC0 + r) //add r imm32
					ResultData.Write(offst&,4)
					Mov(fnc,line.var1,r)
				}else if tp is in TypePoint {

					assert(objs[line.var2] is MCConstRegisterX86)
					reg2 := objs[line.var2]&->{MCConstRegisterX86^}.GetValue()

					assert(reg2 == "rcx")

					tpSize := tp.GetSize()
					MovU64ToReg(fnc,"rax",tpSize)
					Mov(fnc,"rdx",line.var3)
					WriteData(0x48,0x0F,0xAF,0xC2) // imul 
					//Mov(fnc,"rdx",line.var2)
					WriteData(0x48,0x8B,0x09) // mov rcx, (rcx)
					WriteData(0x48,0x01,0xC8) // add rax rcx
					Mov(fnc,line.var1,"rax")
				}else {
					printf("wut %s %s %i\n",tp.GetBADStr().CStr(),fileName,fileLine)
					assert(false)
				}


			case "llvm_store"

				reg1 := objs[line.var1]&->{MCConstRegisterX86^}.GetValue() 
				reg2 := objs[line.var2]&->{MCConstRegisterX86^}.GetValue()

				size := objs[line.var2].GetType().GetSize()


				regData := (reg1 mod 8) + ((reg2 mod 8) shl 3)

				if line.var3 != 0
					regData = regData or_b 0x80

				if reg2 >= 16 {

					switch size
					{
					case 4 WriteData(0x66,0x0F,0x7E,regData)
					case 8 WriteData(0x66,0x48,0x0F,0x7E,regData)
					case 16 WriteData(0x0F,0x29,regData) // mov xmm0, (rcx)
					case void
						assert(false)
					}

				}else{
					upReg := 0
					if reg2 >= 8
					{
						upReg = 0x04

						if size == 2 or size == 4
							WriteData(0x40 + upReg)
					}
					switch size
					{
					case 1 WriteData(0x40 + upReg,0x88,regData)
					case 2 WriteData(0x66,0x89, regData)
					case 4 WriteData(0x89, regData)
					case 8 WriteData(0x48 + upReg,0x89, regData)
					}

				}

				if line.var3 != 0
				{
					obj := objs[line.var3]
					assert(obj is MCConstInteger)

					offst := obj&->{MCConstInteger^}.GetValue()
					ResultData.Write(offst&,4)
				}

			case "llvm_load"

				tp := objs[line.var1].GetType()
				size := tp.GetSize()

				reg1 := objs[line.var1]&->{MCConstRegisterX86^}.GetValue() 
				reg2 := objs[line.var2]&->{MCConstRegisterX86^}.GetValue()

				regData := (reg2 mod 8) + ((reg1 mod 8) shl 3)

				if reg1 >= 16 {

					switch size
					{
					case 4 WriteData(0x66,0x0F,0x6E,regData)
					case 8 WriteData(0x66,0x48,0x0F,0x6E,regData)
					case 16 WriteData(0x0F,0x28,regData) // mov (rcx) , xmm
					case void
						assert(false)
					}

					
				}else{
					if IsInt(tp) and not IsUInt(tp) {
						switch size
						{
						case 1 WriteData(0x48,0x0F,0xBE,regData)
						case 2 WriteData(0x48,0x0F,0xBF,regData)
						case 4 WriteData(0x48,0x63,regData)
						case 8 WriteData(0x48,0x8B,regData)
						}

					}else{
						switch size
						{
						case 1 WriteData(0x48,0x0F,0xB6,regData)
						case 2 WriteData(0x48,0x0F,0xB7,regData)
						case 4 WriteData(0x8B,regData)
						case 8 WriteData(0x48,0x8B,regData)
						}
					}
				}
			case in !["min","max"]
				tp := objs[line.var1].GetType()

				if IsInt(tp) {
					Mov(fnc,"rax",line.var2)
					Mov(fnc,"rcx",line.var3)
					WriteData(0x48,0x39,0xC1) // cmp rax,rcx

					if IsUInt(tp) {
						switch line.opcode
						{
						case "min" WriteData(0x48,0x0F,0x42,0xC1) // cmov rax,rcx
						case "max" WriteData(0x48,0x0F,0x47,0xC1)
						}

					}else{
						switch line.opcode
						{
						case "min" WriteData(0x48,0x0F,0x4C,0xC1) // cmov rax,rcx
						case "max" WriteData(0x48,0x0F,0x4F,0xC1)
						}
					}
					Mov(fnc,line.var1,"rax")

				}else if IsFloat(tp) {
					Mov(fnc,"xmm0",line.var2)
					Mov(fnc,"xmm1",line.var3)
					
					switch tp
					{
					case GTypeFloat WriteData(0xF3)
					case GTypeDouble WriteData(0xF2)
					case void assert(false)
					}
					switch line.opcode
					{
					case "min" WriteData(0x0F,0x5D,0xC1)
					case "max" WriteData(0x0F,0x5F,0xC1)
					}
					Mov(fnc,line.var1,"xmm0")
				}else{
					assert(false)
				}
			case "sqrt"
				tp := objs[line.var1].GetType()
				assert(IsFloat(tp))

				Mov(fnc,"xmm0",line.var2)
				
				switch tp
				{
				case GTypeFloat WriteData(0xF3)
				case GTypeDouble WriteData(0xF2)
				case void assert(false)
				}
				WriteData(0x0F,0x51,0xC0)
				Mov(fnc,line.var1,"xmm0")
			case in !["shl","ushr","sshr"]
				Mov(fnc,"rax",line.var2)
				Mov(fnc,"rcx",line.var3) // MUST BE RCX

				tp := objs[line.var2].GetType()

				switch line.opcode
				{
				case "shl" WriteData(0x48,0xD3,0xE0) // shl rax,rcx
				case "sshr" WriteData(0x48,0xD3,0xF8) // shr rax,rcx
				case "ushr" WriteData(0x48,0xD3,0xE8) // shr rax,rcx
				}
				Mov(fnc,line.var1,"rax")
			case in !["xor","and","or"]
				Mov(fnc,"rax",line.var2)
				Mov(fnc,"rcx",line.var3)
				switch line.opcode
				{
				case "xor" WriteData(0x48,0x33,0xC1) // xor rax,rcx
				case "and" WriteData(0x48,0x23,0xC1) // and rax,rcx
				case "or" WriteData(0x48,0x0B,0xC1) // and rax,rcx
				}
				if objs[line.var2].GetType() == GTypeBool
				{
					WriteData(0x80,0xE0,0x1) // and 0x1, rax
				}
				Mov(fnc,line.var1,"rax")
				
			case "not"
				Mov(fnc,"rax",line.var2)
				WriteData(0x48,0xF7,0xD0) // not rax
				if objs[line.var2].GetType() == GTypeBool
				{
					WriteData(0x80,0xE0,0x1) // and 0x1, rax
				}
				Mov(fnc,line.var1,"rax")

			case "cmp"
				//Mov(fnc,"rdx",line.var2)
				//Mov(fnc,"rax",line.var4)
				reg1 := objs[line.var2]&->{MCConstRegisterX86^}.GetValue()
				reg2 := objs[line.var4]&->{MCConstRegisterX86^}.GetValue()
				resReg := objs[line.var1]&->{MCConstRegisterX86^}.GetValue()
				//ResultData << "\x48\x3B\xD0" //cmp
				
				tp := objs[line.var2].GetType()

				if reg1 >= 16
				{
					assert(resReg < 16)
					assert(reg2 >= 16)
					r1 := reg1 - 16
					r2 := reg2 - 16
					if objs[line.var2].GetType() == GTypeDouble
					{
						ResultData << "\xF2\x0F\xC2"
					}else{
						ResultData << "\xF3\x0F\xC2"
					}
					ResultData.WriteByte("\xC0"[0] + (r1 shl 3) + r2)

					switch line.V3Cond()
					{
						case "==" ResultData.WriteByte(0)
						case "!=" ResultData << "\x04"
						case "<=" ResultData << "\x02"
						case "<" ResultData << "\x01"
						case ">=" ResultData << "\x05"
						case ">" ResultData << "\x06"
					}
					ResultData << "\x66\x0F\x7E" // movd rax xmm0
					ResultData.WriteByte(0xC0 + (r1 shl 3) + resReg)

					WriteData(0x80,0xE0 + resReg,0x01)// and ax 0x1
				}else{
					ResultData << "\x48\x3B"
					ResultData.WriteByte(0xC0 + (reg1 shl 3) + reg2)

					if IsUInt(tp) or IsPtrLikeType(tp) {
						switch line.V3Cond()
						{
							case "==" ResultData << "\x0F\x94"
							case "!=" ResultData << "\x0F\x95"
							case "<=" ResultData << "\x0F\x96"
							case "<" ResultData << "\x0F\x92"
							case ">=" ResultData << "\x0F\x93"
							case ">" ResultData << "\x0F\x97"
						}
					}else{
						switch line.V3Cond()
						{
							case "==" ResultData << "\x0F\x94"
							case "!=" ResultData << "\x0F\x95"
							case "<=" ResultData << "\x0F\x9E"
							case "<" ResultData << "\x0F\x9C"
							case ">=" ResultData << "\x0F\x9D"
							case ">" ResultData << "\x0F\x9F"
						}
					}
					WriteData(0xC0 + resReg)
				}


			case in !["add","sub"]
			
				tp := objs[line.var1].GetType()

				reg1 := objs[line.var1]&->{MCConstRegisterX86^}.GetValue()
				reg2 := objs[line.var2]&->{MCConstRegisterX86^}.GetValue()

				
				if tp is TypeVector
				{
					r1 := reg1 mod 8
					r2 := reg2 mod 8

					if tp.Base == GTypeDouble
					{
						WriteData(0x66)
					}
					WriteData(0x0F)

					if line.opcode == "add"
					{
						WriteData(0x58)
					}else{
						WriteData(0x5C)
					}

					WriteData(0xC0 + (r1 shl 3) + r2)

				}else if reg1 >= 16
				{
					r1 := reg1 - 16
					r2 := reg2 - 16

					if tp == GTypeDouble
					{
						WriteData(0xF2)
					}else{
						WriteData(0xF3)
					}
					WriteData(0x0F)

					if line.opcode == "add"
					{
						WriteData(0x58)
					}else{
						WriteData(0x5C)
					}

					WriteData(0xC0 + (r1 shl 3) + r2)

				}else{
					WriteData(0x48)
					switch line.opcode
					{
					case "add" WriteData(0x01)
					case "sub" WriteData(0x29)
					}
					WriteData(0xC0 + (reg2 shl 3) + reg1)
				}

			case in !["div","mul"]
				reg1 := objs[line.var1]&->{MCConstRegisterX86^}.GetValue()
				reg2 := objs[line.var2]&->{MCConstRegisterX86^}.GetValue()

				tp := objs[line.var1].GetType()

				if tp is TypeVector {
					assert(reg1 >= 16 and reg2 >= 16)

					ri1 := reg1 - 16
					ri2 := reg2 - 16
					
					if tp == GTypeDouble{
						WriteData(0x66)
					}
					WriteData(0x0F)

					if line.opcode == "div" {
						WriteData(0x5E)
					}else{
						WriteData(0x59)
					}

					WriteData(0xC0 + (ri1 shl 3) + ri2)

				}else if IsFloat(tp) {
					assert(reg1 >= 16 and reg2 >= 16)

					ri1 := reg1 - 16
					ri2 := reg2 - 16
					
					if tp == GTypeDouble{
						WriteData(0xF2)
					}else{
						WriteData(0xF3)
					}
					WriteData(0x0F)

					if line.opcode == "div" {
						WriteData(0x5E)
					}else{
						WriteData(0x59)
					}

					WriteData(0xC0 + (ri1 shl 3) + ri2)

				}else {

					assert(reg1 == "rax")

					code := 0
					if line.opcode == "div" {
						if IsUInt(tp)
						{
							code = 6
							MovU64ToReg(fnc,"rdx",0)
						}else{
							code = 7
							WriteData(0x48,0x8B,0xD0) // mov rdx , rax
							WriteData(0x48,0xC1,0xFA,63) // shr rdx,63
						}
					}else{
						assert(line.opcode == "mul")
						code = 5 // 4 if unsigned
					}
					code = code shl 3

					WriteData(0x48,0xF7,0xC0 + reg2 + code)
				}
			case "mod"
				assert(false)

			case "jmp_if_bool"
				Mov(fnc,"rax",line.var2)
				x := 0
				WriteData(0x3C) // cmp al and 0
				ResultData.Write(x&,1)
				WriteData(0x0F,0x85)
				labelTarget[line.var1].Push(strm.Size())
				ResultData.Write(x&,4)
			case "jmp_if_op"

				//TODO cmp floats
				Mov(fnc,"rdx",line.var2)
				Mov(fnc,"rax",line.var4)
				ResultData << "\x48\x3B\xD0" //cmp

				switch line.V3Cond()
				{
					case "==" ResultData << "\x0F\x84"
					case "!=" ResultData << "\x0F\x85"
					case "<=" ResultData << "\x0F\x86"
					case "<" ResultData << "\x0F\x82"
					case ">=" ResultData << "\x0F\x8D"
					case ">" ResultData << "\x0F\x8F"
					case void 
						printf("wut %i\n",line.V3Cond())
						assert(false)
				}
				labelTarget[line.var1].Push(strm.Size())
				x := 0
				ResultData.Write(x&,4)
			case "jmp"
				ResultData << "\xE9"
				x := 0
				labelTarget[line.var1].Push(strm.Size())
				ResultData.Write(x&,4)
			case "label"
				labelPos[line.var1] = strm.Size()

			case "vec_scalar_mul"
				Mov(fnc,"xmm0",line.var2)
				Mov(fnc,"xmm1",line.var3)

				tp := objs[line.var2].GetType()->{TypeVector^}
				assert(tp.Base == GTypeFloat)
				vecSize := tp.vecElementCount
				WriteData(0x66,0x0F,0x3A,0x40,0xC1) //xmm0 = Dot(xmm0,xmm1)
				switch vecSize
				{
				case 2 WriteData(0x31)
				case 3 WriteData(0x71)
				case 4 WriteData(0xF1)
				}
				Mov(fnc,line.var1,"xmm0")
			case "vec_shuffle_begin"
				res := lines[i].var1
				target := lines[i].var2

				Mov(fnc,"xmm0",target)

				vecSizeRes := objs[target].GetType()->{TypeVector^}.vecElementCount

				indx := int
				zeroIndx := int
				j := 0

				i += 1
				while lines[i].opcode != "vec_shuffle_end"
				{
					switch lines[i].opcode 
					{
					case "vec_shuffle_index"
						obj := ref objs[lines[i].var1]
						assert(obj is MCConstInteger)
						val := obj&->{MCConstInteger^}.GetValue()
						indx = indx + (val shl j*2)
					case "vec_shuffle_zero"
						zeroIndx = zeroIndx + (1 shl j)
					}
						
					j += 1
					i += 1
				}

				WriteData(0x66,0x0F,0x70,0xC0)
				WriteData(indx)

				if zeroIndx != 0
				{
					//zeroIndx = not_b zeroIndx
					WriteData(0x0F,0x57,0xC9) // xor xmm1 ,xmm1 ; xmm1 = 0
					WriteData(0x66,0x0F,0x3A,0x0C,0xC1,zeroIndx)
				}

				Mov(fnc,res,"xmm0")

			case "call_start"
				fncId := line.var2
				resId := line.var1
				i += 1

				usedInts := 0
				usedFloats := 0
				stackPassed := HybridStack.{int,20}
				paramIndex := 0
				
				isVargs := false
				paramsCount := 0
				
				{
					fTyp := objs[fncId].GetType()
					if fTyp? is in TypePoint
						fTyp = fTyp.Base
					if fTyp? is TypeFunc
					{
						itType := fTyp->{TypeFunc^}
						isVargs = itType.IsVargs
						paramsCount = itType.Params.Size()
					}
				}


				while lines[i].opcode != "call_end"
				{
					vr := lines[i]
					assert(vr.opcode == "load_var")

					tp := objs[vr.var1].GetType()
					
					isFloat := IsFloat(tp) or tp is TypeVector
					
					if targetWindows and isVargs and paramIndex >= paramsCount
						isFloat = false

					if not isFloat {
						if targetLinux {
							if (usedInts < 6) {
								switch usedInts
								{
								case 0 Mov(fnc,"rdi",vr.var1)
								case 1 Mov(fnc,"rsi",vr.var1)
								case 2 Mov(fnc,"rdx",vr.var1)
								case 3 Mov(fnc,"rcx",vr.var1)
								case 4 Mov(fnc,"r8",vr.var1)
								case 5 Mov(fnc,"r9",vr.var1)
								}

								usedInts += 1
							}else {
								stackPassed.PushFront(vr.var1)
							}
						}else if targetWindows {
							if (paramIndex < 4) {
								switch paramIndex
								{
								case 0 Mov(fnc,"rcx",vr.var1)
								case 1 Mov(fnc,"rdx",vr.var1)
								case 2 Mov(fnc,"r8",vr.var1)
								case 3 Mov(fnc,"r9",vr.var1)
								}
							}else {
								stackPassed.PushFront(vr.var1)
							}
						}else {
							assert(false)
						}
					}else {

						if targetLinux {
							if usedFloats < 8 {
								reg := X86Register
								reg = "xmm0"
								reg&->{int^}^ += usedFloats
								Mov(fnc,reg,vr.var1)
								usedFloats += 1
							}else{
								stackPassed.PushFront(vr.var1)
							}
						}else if targetWindows {
							if paramIndex < 4 {
								reg := X86Register
								reg = "xmm0"
								reg&->{int^}^ += paramIndex
								Mov(fnc,reg,vr.var1)
							}else{
								stackPassed.PushFront(vr.var1)
							}
						}else {
							assert(false)
						}
					}

					paramIndex += 1
					i += 1
				}
				if stackPassed.Size() mod 2 != 0
					Push("rax")
				for it : stackPassed
				{
					Mov(fnc,"rax",it)
					Push("rax")
				}
				if targetWindows
					SubRsp(32)
				MovU64ToReg(fnc,"rax",usedFloats)

				fncObj := objs[fncId]

				if fncObj is MCConstFunction {
					fncHV := fncObj.GetValue()

					if fncHV is ResistFunc {
						fncHV = fncHV.base
					}

					if fncHV is BoxFuncDeclare {
						ptr := GInterpCntx.DeclareToPtr(fncHV->{BoxFuncDeclare^})
						MovPtrToReg(fnc,"r10",ptr)
						WriteData(0x41,0xFF,0xD2) // call *r10
					}else if fncHV is in BoxFuncBody {
						ptr2 := eng.GetFuncPromise(fncHV)
						MovPtrToReg(fnc,"r10",ptr2)
						WriteData(0x4D,0x8B,0x12) // mov r10, (r10)
						WriteData(0x41,0xFF,0xD2) // call *r10
					} else {
						printf("wut %s\n",fncHV.UnitName)
						assert(false)
					}
				}else if fncObj is MCVariable or fncObj is MCConstValue or fncObj is MCConstPointerTyped{
					tp := fncObj.GetType()
					assert(tp is in TypePoint)
					Mov(fnc,"r10",fncId)
					//WriteData(0x4D,0x8B,0x12) // mov r10, (r10)
					WriteData(0x41,0xFF,0xD2) // call *r10
				}else if fncObj is MCGlobalVariable {
					glb := fncObj&->{MCGlobalVariable^}.GetValueObject()
					memPtr := GInterpCntx.GetGlobalVarMem(glb)
					MovPtrToReg(fnc,"r10",memPtr)
					WriteData(0x4D,0x8B,0x12) // mov r10, (r10)
					WriteData(0x41,0xFF,0xD2) // call *r10
				}else{
					printf("wut %s %s %i\n",fncObj.UnitName,fileName,fileLine)
					assert(false)
				}

				if resId != 0
				{
					resTyp := objs[resId].GetType()

					if resTyp == GTypeFloat or resTyp == GTypeDouble or resTyp is TypeVector
					{
						Mov(fnc,resId,"xmm0")
					}else{
						Mov(fnc,resId,"rax")
					}
				}

				callSize := stackPassed.Size() * 8
				if stackPassed.Size() mod 2 != 0
					callSize += 8
				if targetWindows
					callSize += 32
				if callSize != 0
					AddRsp(callSize)

			case "mov"

				tp := objs[line.var2].GetType()

				o1 := ref objs[line.var1]
				isReg1 := o1 is MCConstRegisterX86
				o2 := ref objs[line.var2]
				isReg2 := o2 is MCConstRegisterX86

				if isReg1 or isReg2 {
					if isReg1 {
						Mov(fnc,o1&->{MCConstRegisterX86^}.GetValue(),line.var2)
					}else{
						assert(not isReg1)
						Mov(fnc,line.var1,o2&->{MCConstRegisterX86^}.GetValue())
					}
				}else if tp == GTypeFloat or tp == GTypeDouble or tp is TypeVector{
					Mov(fnc,"xmm0",line.var2)
					Mov(fnc,line.var1,"xmm0")
				}else{
					
					Mov(fnc,"rax",line.var2)
					Mov(fnc,line.var1,"rax")
				}
			
			case "cast"
				tpTo := objs[line.var1].GetType()
				tpFrom := objs[line.var2].GetType()

				if IsRAXCastType(tpTo) and IsRAXCastType(tpFrom)
				{
					Mov(fnc,"rax",line.var2)
					Mov(fnc,line.var1,"rax")
				}else if tpTo == GTypeFloat and tpFrom == GTypeDouble{
					Mov(fnc,"xmm0",line.var2)
					ResultData << "\xF2\x0F\x5A\xC8"
					Mov(fnc,line.var1,"xmm1")
				}else if tpTo == GTypeDouble and tpFrom == GTypeFloat{
					Mov(fnc,"xmm0",line.var2)
					ResultData << "\xF3\x0F\x5A\xC8"
					Mov(fnc,line.var1,"xmm1")
				}else if IsFloat(tpFrom) and IsInt(tpTo) {
					Mov(fnc,"xmm0",line.var2)

					if tpFrom == GTypeFloat {
						WriteData(0xF3)
					}else{
						WriteData(0xF2)
					}
					WriteData(0x48,0x0F,0x2C,0xC0)
					Mov(fnc,line.var1,"rax")
				}else if IsInt(tpFrom) and IsFloat(tpTo) {
					Mov(fnc,"rax",line.var2)

					if tpTo == GTypeFloat {
						WriteData(0xF3)
					}else{
						WriteData(0xF2)
					}
					WriteData(0x48,0x0F,0x2A,0xC0)
					Mov(fnc,line.var1,"xmm0")
				}else{
					printf("x86_64, unsupported cast %s to %s\n",tpFrom.GetBADStr().Str(),tpTo.GetBADStr().Str())
					assert(false)
				}
			case "get_pointer"
				obj := ref objs[line.var2]
				if objs[line.var2] is MCGlobalVariable {

					assert(objs[line.var1] is MCConstRegisterX86)

					glb := obj&->{MCGlobalVariable^}.GetValueObject()
					memPtr := GInterpCntx.GetGlobalVarMem(glb)
					MovPtrToReg(fnc,objs[line.var1]&->{MCConstRegisterX86^}.GetValue(),memPtr)
					//WriteData(0x48,0x8B,0x12) // mov r10, (rax)
				}else if obj is MCVariable {
					assert(objs[line.var1] is MCConstRegisterX86)
					reg := objs[line.var1]&->{MCConstRegisterX86^}.GetValue()
					assert(reg < 16)
					strm << "\x48\x8D"
					c := "\x85"[0] + (reg shl 3)
					ResultData.Write(c&,1)
					x := getObjsStackOffset(fnc,line.var2)
					strm.Write(x&,4)
				}else if obj is MCConstFunction {
					assert(objs[line.var1] is MCConstRegisterX86)
					reg := objs[line.var1]&->{MCConstRegisterX86^}.GetValue()
					assert(reg < 16)

					base := obj.GetValue()

					if base is BoxFuncBody
					{
						ptr := eng.GetFunctionPtr(base->{BoxFuncBody^})
						MovPtrToReg(fnc,reg,ptr)
					}else{
						printf("unknown function %s\n",base.UnitName)
						assert(false)
					}
				}else if obj is MCConstVarX86 {
					offst := objs[line.var2]&->{MCConstVarX86^}.GetValue()
					reg := objs[line.var1]&->{MCConstRegisterX86^}.GetValue()
					WriteData(0x48,0x8D,0x85 + (reg shl 3))
					ResultData.Write(offst&,4)
				}else{
					printf("unknown get_pointer\n")
					obj.PrintObject()
					printf("\n")
					assert(false)
				}

			case "clean"
				assert(objs[line.var1] is MCVariable)

				tp := objs[line.var1].GetType()

				if tp is TypeVector or IsFloat(tp) {
					WriteData(0x0F,0x57,0xC0) // xor xmm0 ,xmm0 ; xmm0 = 0
					Mov(fnc,line.var1,"xmm0")
				}else{
					MovU64ToReg(fnc,"rax",0)
					Mov(fnc,line.var1,"rax")
				}

			case "assert"
				//TODO call only if bool worked
				//WriteData(0xCC) //int3
				WriteData(0x90) //NOP

			case void
				printf("x86_64, unsupported opcode %s at %s %i\n",line.opcode.ToCStr(),fileName,fileLine)
				assert(false)
	
			}
		}
	}
	PrintValues := !() -> void
	{
		for it,i : doubleValues
		{
			x := it.0
			it.2 = ResultData.Size()
			ResultData.Write(x&,8)
		}
	}
	Push := !(X86Register reg) -> void
	{
		dt := "\x50"[0] + reg->{int}
		ResultData.Write(dt&,1)
	}
	Pop := !(X86Register reg) -> void
	{
		dt := "\x58"[0] + reg->{int}
		ResultData.Write(dt&,1)
	}
	Mov := !(MCFunction^ fnc,int indx,X86Register reg) -> void { Mov(fnc,false,reg,indx) }
	Mov := !(MCFunction^ fnc,X86Register reg,int indx) -> void { Mov(fnc,true,reg,indx) }
	Mov := !(MCFunction^ fnc,bool toReg,X86Register reg, int indx) -> void
	{
		obj := ref fnc.Objects[indx]

		size := obj.GetType().GetSize()

		regIndx := reg->{int} mod 8

		isFloatReg := reg->{int} >= 16

		datas := char[4]
		memcpy(datas[0]&,"\x48\x8B\x85"[0]&,3)
		datas[2] += (regIndx->{int} shl 3)

		if obj is MCVariable or obj is MCConstValue or obj is MCConstVarX86 {

			if isFloatReg {

				if obj.GetType()? is TypeVector {
					if toReg {
						if size == 8 {
							WriteData(0x66,0x48,0x0F,0x6E,0x85 + (regIndx shl 3))
						}else if size == 12 or size == 16 {
							WriteData(0x0F,0x28, 0x85 + (regIndx shl 3))
						}else{
							assert(false)
						}

					}else{
						if size == 8 {
							WriteData(0x66,0x48,0x0F,0x7E,0x85 + (regIndx shl 3))
						}else if size == 12 or size == 16 {
							WriteData(0x0F,0x29, 0x85 + (regIndx shl 3))
						}else{
							assert(false)
						}
					}
					x := getObjsStackOffset(fnc,indx)
					ResultData.Write(x&,4)	
				}else{
					if toReg {
						if size == 4 {
							WriteData(0x66,0x0F,0x6E,0x85 + (regIndx shl 3))
						}else{
							WriteData(0x66,0x48,0x0F,0x6E,0x85 + (regIndx shl 3))
						}
					}else{
						if size == 4 {
							WriteData(0x66,0x0F,0x7E,0x85 + (regIndx shl 3))
						}else{
							WriteData(0x66,0x48,0x0F,0x7E,0x85 + (regIndx shl 3))
						}
					}
					x := getObjsStackOffset(fnc,indx)
					ResultData.Write(x&,4)
				} 
			}else {
				regIndx := reg mod 8
				extCode := reg >= 8 ?: 4 : 0

				assert(size <= 8)
					

				if toReg {
					tp := obj.GetType()
					
					if IsUInt(tp) or tp is TypeEnum {
						switch size
						{
						case 1
							WriteData(0x48 + extCode,0x0F,0xB6,0x85 + (regIndx shl 3))
						case 2
							WriteData(0x48 + extCode,0x0F,0xB7,0x85 + (regIndx shl 3))
						case 4
							if extCode != 0
								WriteData(0x40 + extCode)
							WriteData(0x8B,0x85 + (regIndx shl 3))
						case 8
							WriteData(0x48 + extCode,0x8B,0x85 + (regIndx shl 3))
						}

					}else{
						switch size
						{
						case 1
							WriteData(0x48 + extCode,0x0F,0xBE,0x85 + (regIndx shl 3))
						case 2
							WriteData(0x48 + extCode,0x0F,0xBF,0x85 + (regIndx shl 3))
						case 4
							WriteData(0x48 + extCode,0x63,0x85 + (regIndx shl 3))
						case 8
							WriteData(0x48 + extCode,0x8B,0x85 + (regIndx shl 3))
						}
					}

				}else{
					switch size
					{
					case 1
						WriteData(0x40 + extCode,0x88,0x85 + (regIndx shl 3))
					case 2
						if extCode != 0
							WriteData(0x40 + extCode)
						WriteData(0x66,0x89,0x85 + (regIndx shl 3))
					case 4
						if extCode != 0
							WriteData(0x40 + extCode)
						WriteData(0x89,0x85 + (regIndx shl 3))
					case 8
						WriteData(0x48 + extCode,0x89,0x85 + (regIndx shl 3))
					}

				}
		
				x := getObjsStackOffset(fnc,indx)
				ResultData.Write(x&,4)
			}
		}else if obj is MCConstInteger {
			assert(toReg)

			datas[1] = "\xC7"[0]
			datas[2] = "\xC0"[0] + reg->{int}

			ResultData.Write(datas[0]&,3)
			x := obj&->{MCConstInteger^}.GetValue()
			ResultData.Write(x&,4)
		}else if obj is MCConstS64 {
			assert(toReg)

			WriteData(0x48,0xB8 + reg)

			x := obj&->{MCConstS64^}.GetValue()
			ResultData.Write(x&,8)

		}else if obj is MCConstBlob {
			assert(toReg)

			x := obj&->{MCConstBlob^}.GetValue()
			MovPtrToReg(fnc,reg,x)

		}else if obj is MCConstDouble {
			assert(toReg)

			if reg < 16 {
				c := obj.GetValue()
				MovU64ToReg(fnc,reg,c&->{u64^}^)
			}else{
				assert(reg >= 16) // float register

				regPos := reg->{int} - 16
				
				ResultData << "\xF2\x0F\x10"
				ResultData.WriteByte("\x05"[0] + (regPos shl 3) )

				doubleValues.Emplace(obj.GetValue(),ResultData.Size(),0)

				x := s32
				ResultData.Write(x&,4)
			}
		}else if obj is MCGlobalVariable {

			glb := obj.GetValueObject()
			memPtr := GInterpCntx.GetGlobalVarMem(glb)
			if reg >= 16 {
				regIndx := reg mod 8
				MovPtrToReg(fnc,"r10",memPtr)
				if obj.GetType() == GTypeDouble {
					WriteData(0x66,0x49,0x0F,0x6E,(regIndx shl 3) + 2) // mov reg, (r10)
				}else if obj.GetType() == GTypeFloat {
					WriteData(0x66,0x41,0x0F,0x6E,(regIndx shl 3) + 2) // mov reg, (r10)
				}else{
					assert(false)
				}
			}else{
				assert(reg < 8)
				MovPtrToReg(fnc,reg,memPtr)
				WriteData(0x48,0x8B,reg + (reg shl 3)) // mov reg, (reg)
			}
			
		}else if obj is MCConstString {
			assert(toReg)
			MovPtrToReg(fnc,reg,obj&->{MCConstString^}.GetValue().CStr())
		}else if obj is MCConstPointerTyped {
			assert(toReg)
			MovPtrToReg(fnc,reg,obj&->{MCConstPointerTyped^}.GetValue())
		}else if obj is MCConstPointer {
			assert(toReg)
			MovPtrToReg(fnc,reg,obj&->{MCConstPointerTyped^}.GetValue())
		}else if obj is MCConstBool {
			assert(toReg)
			MovU64ToReg(fnc,reg,obj&->{MCConstBool^}.GetValue() ?: 1 : 0)
		}else{
			obj.PrintObject()
			printf("\n")
			assert(false)
		}

	}
	MovU64ToReg := !(MCFunction^ fnc,X86Register reg, u64 val) -> void
	{
		MovPtrToReg(fnc,reg,val&->{void^^}^)
	}
	MovPtrToReg := !(MCFunction^ fnc,X86Register reg, void^ ptr) -> void
	{
		regIndx := reg mod 8
		
		ext := reg >= 8 ?: 1 : 0

		WriteData(0x48 + ext,0xB8 + regIndx)
		ResultData.Write(ptr&,8)
	}

	WriteData := !(int x) -> void
	{
		ResultData.Write(x&,1)
	}
	WriteData := !(int x,int y) -> void
	{
		ResultData.Write(x&,1)
		ResultData.Write(y&,1)
	}
	WriteData := !(int x,int y,int z) -> void
	{
		ResultData.Write(x&,1)
		ResultData.Write(y&,1)
		ResultData.Write(z&,1)
	}
	WriteData := !(int x,int y,int z,int w) -> void
	{
		ResultData.Write(x&,1)
		ResultData.Write(y&,1)
		ResultData.Write(z&,1)
		ResultData.Write(w&,1)
	}
	WriteData := !(int x,int y,int z,int w,int q) -> void
	{
		ResultData.Write(x&,1)
		ResultData.Write(y&,1)
		ResultData.Write(z&,1)
		ResultData.Write(w&,1)
		ResultData.Write(q&,1)
	}
	WriteData := !(int x,int y,int z,int w,int q,int rr) -> void
	{
		ResultData.Write(x&,1)
		ResultData.Write(y&,1)
		ResultData.Write(z&,1)
		ResultData.Write(w&,1)
		ResultData.Write(q&,1)
		ResultData.Write(rr&,1)
	}
	SubRsp := !(int val) -> void
	{
		WriteData(0x48,0x81,0xEC) // %rsp -= val
		ResultData.Write(val&,4)
	}
	AddRsp := !(int val) -> void
	{
		WriteData(0x48,0x81,0xC4) // %rsp += val
		ResultData.Write(val&,4)
	}
}

IsPtrLikeType := !(Type^ tp) -> bool
{
	if tp is in TypePoint
		return true
	if tp is in TypeArrayView
		return true
	if tp == GTypeStr
		return true
	return false
}
IsRAXCastType := !(Type^ tp) -> bool
{
	if IsPtrLikeType(tp)
		return true
	if IsInt(tp)
		return true
	if tp is TypeEnum
		return true
	return false
}

X86Register := enum
{
	"rax","rcx","rdx","rbx","rsp","rbp","rsi","rdi",
	"r8","r9","r10","r11","r12","r13","r14","r15",

	"xmm0","xmm1","xmm2","xmm3","xmm4","xmm5","xmm7",
	"xmm8","xmm9","xmm10","xmm11","xmm12","xmm13","xmm14","xmm15"
}

MCConstRegisterX86 := class extend MCObject
{
	IsConstant := virtual true

	GetValue := !() -> ref X86Register { return Value&->{X86Register^}^}

	PrintObject := virtual !() -> void { printf("Register \"%s\" with type %s",GetValue().ToCStr(), GetType().GetBADStr().CStr()) }
	GetType := virtual !() -> Type^ { return Value2&->{Type^^}^ }

	SetType := virtual !(Type^ newType) -> Type^ { Value2&->{Type^^}^ = newType }
}

MCConstVarX86 := class extend MCObject
{
	IsConstant := virtual true

	GetValue := !() -> ref int { return Value&->{int^}^ }

	PrintObject := virtual !() -> void { printf("Value \"%i\"",GetValue()) }
	GetType := virtual !() -> Type^ { return Value2&->{Type^^}^ }

	SetType := virtual !(Type^ newType) -> Type^ { Value2&->{Type^^}^ = newType }
}
