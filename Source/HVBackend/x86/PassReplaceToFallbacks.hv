
PassSetFallbacksX86 := !(MCFunction^ fnc) ->MCFunction^
{
	ctx := MakeGreedyPass(fnc,4,6)
	cPtr := ctx.cPtr
	c := ref ctx.cmdsSize
	oPtr := ctx.oPtr
	o := ref ctx.objsSize

	iPtr := fnc.Lines.GetPointer()
	iSize := fnc.Lines.Size()

	i := 0
	while i < iSize
	{
		line := iPtr[i]

		if line.opcode == "cos" or line.opcode == "sin"
		{
			tp := oPtr[line.var2].GetType()
			assert(IsFloat(tp))

			newObj := MCConstPointerTyped
			switch tp
			{
			case GTypeFloat
				switch line.opcode
				{
				case "sin" newObj.GetValue() = x86_sinf
				case "cos" newObj.GetValue() = x86_cosf
				}
			case GTypeDouble
				switch line.opcode
				{
				case "sin" newObj.GetValue() = x86_sind
				case "cos" newObj.GetValue() = x86_cosd
				}
			}
			newObj.SetType(GetFuncType(![tp],tp).GetPoint())
			fncId := o
			oPtr[o] = newObj
			o += 1

			cPtr[c] = MCLine("call_start",line.var1,fncId)
			cPtr[c+1] = MCLine("load_var",line.var2)
			cPtr[c+2] = MCLine("call_end")
			c += 3
			i += 1
		}else if (line.opcode == "mul" or line.opcode == "div")
			and oPtr[line.var1].GetType() is TypeVector and oPtr[line.var1].GetType().Base == GTypeInt
		{
			newObj := MCConstPointerTyped
			switch line.opcode
			{
			case "mul" newObj.GetValue() = fallbackMulVecI
			case "div" newObj.GetValue() = fallbackDivVecI

			}
			t := oPtr[line.var1].GetType()

			newObj.SetType(GetFuncType(![t,t],t).GetPoint())
			fncId := o
			oPtr[o++] = newObj

			cPtr[c++] = MCLine("call_start",line.var1,fncId)
			cPtr[c++] = MCLine("load_var",line.var2)
			cPtr[c++] = MCLine("load_var",line.var3)
			cPtr[c++] = MCLine("call_end")
			i += 1
		}else{
			cPtr[c++] = line
			i += 1
		}
	}

	return ctx.GenerateFunc()
}

fallbackMulVecI := !(vec4i a, vec4i b) -> vec4i
{
	result.x = a.x * b.x
	result.y = a.y * b.y
	result.z = a.z * b.z
	result.w = a.w * b.w
}
fallbackDivVecI := !(vec4i a, vec4i b) -> vec4i
{
	if b.x != 0
		result.x = a.x div b.x
	if b.y != 0
		result.y = a.y div b.y
	if b.z != 0
		result.z = a.z div b.z
	if b.w != 0
		result.w = a.w div b.w
}

x86_sinf := !(float x) -> float { return sin(x) }
x86_cosf := !(float x) -> float { return cos(x) }
x86_sind := !(double x) -> double { return sin(x) }
x86_cosd := !(double x) -> double { return cos(x) }
