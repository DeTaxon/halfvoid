
PassApplyRegistersX86 := !(MCFunction^ fnc) ->MCFunction^
{
	bldr := MakeGreedyPass(fnc,4,6)

	oPtr := bldr.objs.GetPointer()
	o := ref bldr.objsSize

	pushVar := (int offset, Type^ varType) ==> int
	{
		newVar := MCConstVarX86

		newVar.GetValue() = offset
		newVar.SetType(varType)

		oPtr[o] = newVar
		result = o
		o += 1
	}
	pushVar2 := (Type^ varType) ==> int
	{
		newVar := MCVariable

		newVar.GetValueType() = varType

		result = o
		oPtr[o++] = newVar
	}

	c := ref bldr.cmdsSize
	cPtr := bldr.cmds.GetPointer()

	regAreaId := 0

	redInts := 0
	redFloats := 0

	if targetLinux
	{// load inputs
		stackIter := 16

		for i : fnc.InputsIndxCount
		{
			indx := i + fnc.InputsIndxStart
			tp := oPtr[indx].GetType()

			reg := X86Register

			loadFromStack := false

			if (IsFloat(tp) or tp is TypeVector) {
				reg = "xmm0"
				if redFloats < 8 {
					reg&->{int^}^ += redFloats
					redFloats += 1
				}else{
					loadFromStack = true
				}
			}else{
				switch redInts
				{
				case 0 reg = "rdi"
				case 1 reg = "rsi"
				case 2 reg = "rdx"
				case 3 reg = "rcx"
				case 4 reg = "r8"
				case 5 reg = "r9"
				case void
					loadFromStack = true
				}
				redInts += 1
			}

			if loadFromStack
			{
				newVar := pushVar(stackIter,tp)
				stackIter += 8
				cPtr[c] = MCLine("mov",indx,newVar)
				c += 1
			}else{
				rt := bldr.PushReg(reg,tp)

				cPtr[c] = MCLine("mov",indx,rt)
				c += 1
			}
		}

		if fnc.IsVArgs
		{
			regArea := GetTypeByName(StringSpan("va_list_registers"))
			assert(regArea != null)
			if regArea != null
			{
				rId := pushVar2(regArea)

				// r1 := bldr.PushReg("rax",GTypeVoidP)
				//
				// cPtr[c++] = MCLine("get_pointer",r1,rId)

				offset := 0

				for i : 6
				{
					reg := X86Register
					switch i
					{
					case 0 reg = "rdi"
					case 1 reg = "rsi"
					case 2 reg = "rdx"
					case 3 reg = "rcx"
					case 4 reg = "r8"
					case 5 reg = "r9"
					}

					// cPtr[c++] = MCLine("store",rId,bldr.PushReg(reg,GTypeSizeT),bldr.PushInt(offset))
					cPtr[c++] = MCLine("store64",bldr.PushReg(reg,GTypeSizeT),rId,bldr.PushInt(offset))
					offset += GTypeSizeT.GetSize()
				}

				for i : 8
				{
					reg := X86Register
					reg = "xmm0"
					reg&->{int^}^ += i
					// cPtr[c++] = MCLine("store",rId,bldr.PushReg(reg,GTypeVec4f),bldr.PushInt(offset))
					cPtr[c++] = MCLine("store64",bldr.PushReg(reg,GTypeVec4f),rId,bldr.PushInt(offset))
					offset += 16

				}

				regAreaId = rId
			}
		}
	}
	if targetWindows
	{// load inputs
		stackIter := 16 + 32 // 16 - ret address + push(rbp), 32 - reserved for first 4 variables

		for i : fnc.InputsIndxCount
		{
			indx := i + fnc.InputsIndxStart
			tp := fnc.Objects[indx].GetType()

			if i < 4 {
				reg := X86Register

				if (IsFloat(tp) or tp is TypeVector) {
					reg = "xmm0"
					reg&->{int^}^ += i
				}else{
					switch i
					{
					case 0 reg = "rcx"
					case 1 reg = "rdx"
					case 2 reg = "r8"
					case 3 reg = "r9"
					}
				}

				rt := bldr.PushReg(reg,tp)
				cPtr[c++] = MCLine("mov",indx,rt)
			}else{
				newVar := pushVar(stackIter,tp)
				stackIter += 8
				cPtr[c] = MCLine("mov",indx,newVar)
				c += 1
			}
		}

		if fnc.IsVArgs and fnc.InputsIndxCount <= 4
		{
			r1 := bldr.PushReg("rax",GTypeVoidP)
			cPtr[c++] = MCLine("get_pointer",r1,pushVar(16,GTypeVoidP))

			for i : 4
			{
				reg := X86Register

				switch i
				{
				case 0 reg = "rcx"
				case 1 reg = "rdx"
				case 2 reg = "r8"
				case 3 reg = "r9"
				}

				cPtr[c++] = MCLine("store",r1,bldr.PushReg(reg,GTypeVoidP),bldr.PushInt(8*i))
			}
		}
	}

	i := 0
	while i < fnc.Lines.Size()
	{
		it := fnc.Lines[i]
		switch it.opcode
		{
		//case "debug_set_file"
		//case "debug_set_line" // delete debug info

		case "call_start"
			resInd := it.var1

			startLine := MCLine("call_start",0,it.var2)
			i += 1

			stackCount := 0
			stackMemUsed := 0
			usedInts := 0
			usedFloats := 0

			usedVars := HybridQueue.{int,30}

			if targetLinux
			{
				stackPassed := HybridStack.{int,20}

				while fnc.Lines[i].opcode != "call_end"
				{
					vr := ref fnc.Lines[i]

					tp := oPtr[vr.var1].GetType()

					if IsFloat(tp) or tp is in TypeVector
					{
						if usedFloats < 8
						{
							reg := X86Register
							reg = "xmm0"
							reg&->{int^}^ += usedFloats

							regId := bldr.PushReg(reg,GTypeSizeT)
							cPtr[c++] = MCLine("mov",regId,vr.var1)
							usedVars.Push(regId)
							usedFloats += 1
						}else{
							stackPassed.PushFront(vr.var1)
						}
					}else{
						if usedInts < 6
						{
							reg := X86Register

							switch usedInts
							{
							case 0 reg = "rdi"
							case 1 reg = "rsi"
							case 2 reg = "rdx"
							case 3 reg = "rcx"
							case 4 reg = "r8"
							case 5 reg = "r9"
							}
							regId := bldr.PushReg(reg,tp)
							cPtr[c++] = MCLine("mov",regId,vr.var1)
							usedVars.Push(regId)
							usedInts += 1
						}else{
							stackPassed.PushFront(vr.var1)
						}
					}
					
					i += 1
				}

				while stackPassed.Size() != 0
				{
					r := stackPassed.Pop()

					tp := oPtr[r].GetType()

					tmp := bldr.PushReg("rax",tp)
					cPtr[c++] = MCLine("mov",tmp,r)
					cPtr[c++] = MCLine("push",tmp)
					stackCount += 1
				}

				if stackCount mod 2 != 0
				{
					tmp := bldr.PushReg("rax",GTypeSizeT)
					cPtr[c++] = MCLine("push",tmp)
					stackCount += 1
				}
				stackMemUsed = stackCount*8
				cPtr[c++] = MCLine("mov",bldr.PushReg("rax",GTypeSizeT),bldr.PushInt(usedFloats))

			}

			if targetWindows
			{
				usedVarsCount := 0

				stackPassed := HybridStack.{int,20}

				while fnc.Lines[i].opcode != "call_end"
				{
					vr := ref fnc.Lines[i]

					tp := oPtr[vr.var1].GetType()

					if usedVarsCount < 4
					{
						reg := X86Register

						if IsFloat(tp) or tp is in TypeVector
						{
							reg = "xmm0"
							reg&->{int^}^ += usedVarsCount
						}else{
							switch usedVars
							{
							casae 0 reg = "rcx"
							casae 1 reg = "rdx"
							casae 2 reg = "r8"
							casae 3 reg = "r9"
							}
						}
						regId := bldr.PushReg(reg,tp)
						cPtr[c++] = MCLine("mov",regId,vr.var1)
						usedVars.Push(regId)
						usedVarsCount += 1
					}else{
						stackPassed.PushFront(vr.var1)
					}
					
					i += 1
				}

				while stackPassed.Size() != 0
				{
					r := stackPassed.Pop()

					tp := oPtr[r].GetType()

					tmp := bldr.PushReg("rax",tp)
					cPtr[c++] = MCLine("mov",tmp,r)
					cPtr[c++] = MCLine("push",tmp)
					stackCount += 1
				}

				if stackCount mod 2 != 0
				{
					tmp := bldr.PushReg("rax",GTypeSizeT)
					cPtr[c++] = MCLine("push",tmp)
					stackCount += 1
				}

				tmp := bldr.PushReg("rsp",GTypeSizeT)
				cPtr[c++] = MCLine("add",tmp,bldr.PushInt(16))

				stackMemUsed = stackCount*8 + 16

			}

			cPtr[c++] = startLine
			cPtr[c++] = MCLine("load_var",usedVars[^])
			cPtr[c++] = MCLine("call_end")

			if stackMemUsed != 0
			{
				tmp := bldr.PushReg("rsp",GTypeSizeT)
				cPtr[c++] = MCLine("add",tmp,bldr.PushInt(stackMemUsed))
			}

			if resInd != 0
			{
				resTyp := oPtr[resInd].GetType()
				resReg := X86Register

				if resTyp == GTypeFloat or resTyp == GTypeDouble or resTyp is TypeVector
				{
					resReg = "xmm0"
				}else{
					resReg = "rax"
				}
				resRegId := bldr.PushReg(resReg,resTyp)
				cPtr[c++] = MCLine("mov",resInd,resRegId)
			}
			
		case "switch_start"
			cmpObj := it.var1
		
			i += 1

			while fnc.Lines[i].opcode != "switch_end"
			{
				ln := fnc.Lines[i]

				cPtr[c] = MCLine("jmp_if_op",ln.var2,cmpObj,"==",ln.var1)
				c += 1
				i += 1
			}
			

		case in !["div","mod","mul"]
			
			tp := oPtr[it.var1].GetType()

			r1 := X86Register
			r2 := X86Register
			r1 = "rax"
			r2 = "rcx"

			if IsFloat(tp) or tp is TypeVector {
				r1 = "xmm0"
				r2 = "xmm1"
			}

			reg1 := bldr.PushReg(r1,tp)
			reg2 := bldr.PushReg(r2,tp)

			cPtr[c] = MCLine("mov",reg1,it.var2)
			cPtr[c+1] = MCLine("mov",reg2,it.var3)

			cPtr[c+2] = MCLine("div",reg1,reg2) //NOTE, EDX used as well
			if it.opcode == "mul"
				cPtr[c+2].opcode = "mul"

			outReg := reg1
			if it.opcode == "mod"  {
				outReg = bldr.PushReg("rdx",tp)
			}
			cPtr[c+3] = MCLine("mov",it.var1,outReg)

			c += 4

		case in !["add","sub","xor","and","or"]
			v1 := ref oPtr[it.var2]
			v2 := ref oPtr[it.var3]
			res := ref oPtr[it.var1]

			tp := v1.GetType()

			r1 := X86Register
			r2 := X86Register

			if tp == GTypeFloat or tp == GTypeDouble or tp is TypeVector {
				r1 = "xmm0"
				r2 = "xmm1"
			}else{
				r1 = "rax"
				r2 = "rdx"
			}

			isInt := false
			if it.opcode == "add" {
				isInt = (v1 is MCConstInteger or v2 is MCConstInteger)
			}else if it.opcode == "sub" {
				isInt = v2 is MCConstInteger
			}

			if isInt and r1 == "rax"
			{
				reg1 := bldr.PushReg(r1,tp)
				valIdx := 0
				if v2 is MCConstInteger
				{
					cPtr[c++] = MCLine("mov",reg1,it.var2)
					valIdx = it.var3
				}else{
					cPtr[c++] = MCLine("mov",reg1,it.var3)
					valIdx = it.var2
				}
				cPtr[c++] = MCLine(it.opcode,reg1,valIdx)
				cPtr[c++] = MCLine("mov",it.var1,reg1)
				
			}else{

				reg1 := bldr.PushReg(r1,tp)
				reg2 := bldr.PushReg(r2,tp)

				cPtr[c] = MCLine("mov",reg1,it.var2)
				cPtr[c+1] = MCLine("mov",reg2,it.var3)
				cPtr[c+2] = MCLine(it.opcode,reg1,reg2)
				cPtr[c+3] = MCLine("mov",it.var1,reg1)
				
				c += 4
			}


		case "cmp"

			tp := oPtr[it.var2].GetType()
			tp4 := oPtr[it.var4].GetType()

			if tp != tp4 {
				assert(IsRAXCastType(tp) and IsRAXCastType(tp4))
			}
			assert(oPtr[it.var1].GetType() == GTypeBool)

			r1 := X86Register
			r1 = "rax"
			r2 := r1
			r2 = "rdx"

			if IsFloat(tp)
			{
				r1 = "xmm0"
				r2 = "xmm1"
			}

			reg1 := bldr.PushReg(r1,tp)
			reg2 := bldr.PushReg(r2,tp)
			res := bldr.PushReg("rcx",GTypeBool)

			cPtr[c] = MCLine("mov",reg1,it.var2)
			cPtr[c+1] = MCLine("mov",reg2,it.var4)

			if IsFloat(tp) {
				if it.V3Cond() == ">" {
					cPtr[c+2] = MCLine("cmp",res,reg2,"<",reg1)
				}else if it.V3Cond() == ">=" {
					cPtr[c+2] = MCLine("cmp",res,reg2,"<=",reg1)
				}else {
					cPtr[c+2] = MCLine("cmp",res,reg1,it.V3Cond(),reg2)
				}
			}else{
				cPtr[c+2] = MCLine("cmp",res,reg1,it.V3Cond(),reg2)
			}

			cPtr[c+3] = MCLine("mov",it.var1,res)

			c += 4

		case "get_pointer"
			v1 := ref oPtr[it.var1]
			if v1 is MCConstRegisterX86
			{
				cPtr[c] = it
				c += 1
			}else{
				newReg := bldr.PushReg("rax",v1.GetType())
				cPtr[c] = it
				cPtr[c].var1 = newReg
				cPtr[c + 1] = MCLine("mov",it.var1,newReg)
				c += 2
			}
		case "store"
			ob1 := oPtr[it.var1]
			ob2 := oPtr[it.var2]

			tp := ob1.GetType()

			if ob1.GetType() == ob2.GetType() {
				reg := bldr.PushReg("rax",tp)

				cPtr[c] = MCLine("mov",reg,it.var2)
				cPtr[c+1] = MCLine("mov",it.var1,reg)
				c += 2
			}else{
				reg1 := bldr.PushReg("rcx",ob1.GetType())

				tp2 := ob2.GetType()
				reg2 := int
				if tp2 is TypeVector or  IsFloat(tp2) {
					reg2 = bldr.PushReg("xmm0",tp2)
				}else{
					reg2 = bldr.PushReg("rax",tp2)
				}
				

				cPtr[c] = MCLine("mov",reg1,it.var1)
				cPtr[c+1] = MCLine("mov",reg2,it.var2)
				cPtr[c+2] = MCLine("store",reg1,reg2)
				c += 3

			}
		case "load"
			ob1 := oPtr[it.var1]
			ob2 := oPtr[it.var2]

			tp := ob1.GetType()

			if ob1.GetType() == ob2.GetType() {
				reg := bldr.PushReg("rax",tp)

				cPtr[c] = MCLine("mov",reg,it.var2)
				cPtr[c+1] = MCLine("mov",it.var1,reg)
				c += 2
			}else{
				reg1 := bldr.PushReg("rcx",ob2.GetType())

				reg2 := int
				if tp is TypeVector or IsFloat(tp) {
					reg2 = bldr.PushReg("xmm0",tp)
				}else{
					reg2 = bldr.PushReg("rax",tp)
				}
				

				cPtr[c] = MCLine("mov",reg1,it.var2)
				cPtr[c+1] = MCLine("load",reg2,reg1)
				cPtr[c+2] = MCLine("mov",it.var1,reg2)
				c += 3
			}
		case "get_field_ptr"
			tpPtr := oPtr[it.var2].GetType()
			assert(tpPtr is in TypePoint)
			tp := tpPtr.Base

			assert(tp is TypeClass)

			assert(oPtr[it.var3] is MCConstInteger)
			indx := oPtr[it.var3]&->{MCConstInteger^}.GetValue()

			cls := tp->{TypeClass^}.ToClass

			offst := cls.GetFieldByIndexRaw(indx).MemOffset

			r1 := bldr.PushReg("rax",GTypeVoidP)
			intVal := bldr.PushInt(offst)

			cPtr[c++] = MCLine("mov",r1,it.var2)
			cPtr[c++] = MCLine("add",r1,intVal)
			cPtr[c++] = MCLine("mov",it.var1,r1)

		case "get_array_elem_ptr"
		
			obj1 := oPtr[it.var2]
			tp := oPtr[it.var2].GetType()

			if tp is in TypePoint or tp == GTypeStr {
				r1 := bldr.PushReg("rax",GTypeInt)
				r2 := bldr.PushReg("rdx",GTypeInt)

				tpSize := tp.Base.GetSize()
				tpSizeIndx := bldr.PushInt(tpSize)

				cPtr[c++] = MCLine("mov",r1,tpSizeIndx)
				cPtr[c++] = MCLine("mov",r2,it.var3)
				cPtr[c++] = MCLine("mul",r1,r2)
				cPtr[c++] = MCLine("mov",r2,it.var2)
				cPtr[c++] = MCLine("add",r1,r2)
				cPtr[c++] = MCLine("mov",it.var1,r1)
			}else {
				cPtr[c] = it
				c += 1
			}
		case "mov"
			ob1 := oPtr[it.var1]
			if ob1 is MCGlobalVariable {
				r1 := bldr.PushReg("rax",ob1.GetType().GetPoint())
				r2 := bldr.PushReg("rcx",oPtr[it.var2].GetType())
				cPtr[c] = MCLine("get_pointer",r1,it.var1)
				cPtr[c+1] = MCLine("mov",r2,it.var2)
				cPtr[c+2] = MCLine("store",r1,r2)
				c += 3
			}else{
				cPtr[c] = it
				c += 1
			}
		case "cast"
			tpTo := oPtr[it.var1].GetType()
			tpFrom := oPtr[it.var2].GetType()

			if IsRAXCastType(tpTo) and IsRAXCastType(tpFrom)
			{
				rFrom := bldr.PushReg("rax",tpFrom)
				rTo := bldr.PushReg("rax",tpTo)
				cPtr[c++] = MCLine("mov",rFrom,it.var2)
				cPtr[c++] = MCLine("mov",it.var1,rTo)

			}else{
				cPtr[c++] = it
			}
		case in !["sin","cos"]
			assert(false)
		case "va_start"
			if targetLinux
			{
				r1 := bldr.PushReg("rax",GTypeVoidP.GetPoint())
				r2 := bldr.PushReg("rcx",GTypeInt)
				r3 := bldr.PushReg("rcx",GTypeVoidP.GetPoint())

				cPtr[c++] = MCLine("mov",r1,it.var1)
				cPtr[c++] = MCLine("mov",r2,bldr.PushInt(min(redInts,6)*8))
				cPtr[c++] = MCLine("store",r1,r2)
				cPtr[c++] = MCLine("mov",r2,bldr.PushInt(min(redFloats,8)*16 + 6*8))
				cPtr[c++] = MCLine("store",r1,r2,bldr.PushInt(4))

				cPtr[c++] = MCLine("get_pointer",r3,pushVar(16,GTypeSizeT))
				cPtr[c++] = MCLine("store",r1,r3,bldr.PushInt(8))
				cPtr[c++] = MCLine("get_pointer",r3,regAreaId)
				cPtr[c++] = MCLine("store",r1,r3,bldr.PushInt(16))
			}
			if targetWindows
			{
				r1 := bldr.PushReg("rax",GTypeVoidP.GetPoint())
				r2 := bldr.PushReg("rcx",GTypeVoidP.GetPoint())
				
				offst := min(fnc.InputsIndxCount,4)

				cPtr[c++] = MCLine("get_pointer",r2,pushVar( offst*8 + 16,GTypeVoidP.GetPoint()))
				cPtr[c++] = MCLine("mov",r1,it.var1)
				cPtr[c++] = MCLine("store",r1,r2)
				
			}
		case "va_end"
			//nothing

		case "asm_start"
			while fnc.Lines[i].opcode != "asm_end"
				i += 1
		case "va_arg"
			// TODOTODO nothing 

		case "memory_barrier"
			//nothing
		case void
			cPtr[c] = it
			c += 1
		}
		i += 1
	}

	resTyp := fnc.Objects[fnc.ResultIndex].GetType()
	if resTyp == GTypeVoid {
		// this is fine
	}else if IsInt(resTyp) or IsPtrLikeType(resTyp) or resTyp == GTypeBool or resTyp is in TypeEnum {
		reg := bldr.PushReg("rax",resTyp)
		cPtr[c] = MCLine("mov",reg,fnc.ResultIndex)
		c += 1
	}else if resTyp == GTypeFloat or resTyp == GTypeDouble or resTyp is TypeVector {
		reg := bldr.PushReg("xmm0",resTyp)
		cPtr[c] = MCLine("mov",reg,fnc.ResultIndex)
		c += 1
	}else{
		printf("unknown res type %s %s\n",resTyp.GetBADStr().Str(),resTyp.UnitName)
		assert(false)
	}

	return bldr.GenerateFunc()
}
