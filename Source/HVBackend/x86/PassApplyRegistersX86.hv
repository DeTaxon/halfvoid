
PassApplyRegistersX86 := !(MCFunction^ fnc) ->MCFunction^
{
	objs := new Vector.{MCObject}
	o := fnc.Objects.Size()
	objs.Resize(o*6)
	oPtr := objs.GetPointer()
	memcpy(oPtr,fnc.Objects.GetPointer(),o*MCObject->TypeSize)

	pushReg := (X86Register reg, Type^ regType) ==> int
	{
		newReg := MCConstRegisterX86

		newReg.GetValue() = reg
		newReg.SetType(regType)

		oPtr[o] = newReg
		result = o
		o += 1
	}
	pushVar := (int offset, Type^ varType) ==> int
	{
		newVar := MCConstVarX86

		newVar.GetValue() = offset
		newVar.SetType(varType)

		oPtr[o] = newVar
		result = o
		o += 1
	}

	cmds := new Vector.{MCLine}
	c := 0
	cmds.Resize(fnc.Lines.Size()*4 + 100)
	cPtr := cmds.GetPointer()

	fTyp := NormalizeFuncType(fnc.BaseFunction.GetType()->{TypeFunc^})
	{// load inputs
		redInts := 0
		redFloats := 0
		stackIter := 16

		for i : fnc.InputsIndxCount
		{
			tp := fTyp.Params[i].ItType
			indx := i + fnc.InputsIndxStart

			reg := X86Register

			loadFromStack := false

			if (IsFloat(tp) or tp is TypeVector) and not fTyp.Params[i].IsRef {
				reg = "xmm0"
				if redFloats < 8 {
					reg&->{int^}^ += redFloats
					redFloats += 1
				}else{
					loadFromStack = true
				}
			}else{
				switch redInts
				{
				case 0 reg = "rdi"
				case 1 reg = "rsi"
				case 2 reg = "rdx"
				case 3 reg = "rcx"
				case 4 reg = "r8"
				case 5 reg = "r9"
				case void
					loadFromStack = true
				}
				redInts += 1
			}

			if loadFromStack
			{
				newVar := pushVar(stackIter,tp)
				stackIter += 8
				cPtr[c] = MCLine("mov",indx,newVar)
				c += 1
			}else{
				rt := pushReg(reg,tp)

				cPtr[c] = MCLine("mov",indx,rt)
				c += 1
			}
		}
	}

	i := 0
	while i < fnc.Lines.Size()
	{
		it := fnc.Lines[i]
		switch it.opcode
		{
		//case "debug_set_file"
		//case "debug_set_line" // delete debug info

		case "switch_start"
			cmpObj := it.var1
		
			i += 1

			while fnc.Lines[i].opcode != "switch_end"
			{
				ln := fnc.Lines[i]

				cPtr[c] = MCLine("jmp_if_op",ln.var2,cmpObj,"==",ln.var1)
				c += 1
				i += 1
			}
			

		case in !["div","mod","mul"]
			
			tp := oPtr[it.var1].GetType()

			r1 := X86Register
			r2 := X86Register
			r1 = "rax"
			r2 = "rcx"

			if IsFloat(tp) or tp is TypeVector {
				r1 = "xmm0"
				r2 = "xmm1"
			}

			reg1 := pushReg(r1,tp)
			reg2 := pushReg(r2,tp)

			cPtr[c] = MCLine("mov",reg1,it.var2)
			cPtr[c+1] = MCLine("mov",reg2,it.var3)

			cPtr[c+2] = MCLine("div",reg1,reg2) //NOTE, EDX used as well
			if it.opcode == "mul"
				cPtr[c+2].opcode = "mul"

			outReg := reg1
			if it.opcode == "mod"  {
				outReg = pushReg("rdx",tp)
			}
			cPtr[c+3] = MCLine("mov",it.var1,outReg)

			c += 4

		case in !["add","sub"]
			v1 := ref oPtr[it.var2] //TODO float
			v2 := ref oPtr[it.var3]
			res := ref oPtr[it.var1]

			tp := v1.GetType()

			r1 := X86Register
			r2 := X86Register

			if tp == GTypeFloat or tp == GTypeDouble or tp is TypeVector {
				r1 = "xmm0"
				r2 = "xmm1"
			}else{
				r1 = "rax"
				r2 = "rdx"
			}

			reg1 := pushReg(r1,tp)
			reg2 := pushReg(r2,tp)

			cPtr[c] = MCLine("mov",reg1,it.var2)
			cPtr[c+1] = MCLine("mov",reg2,it.var3)
			cPtr[c+2] = MCLine(it.opcode,reg1,reg2)
			cPtr[c+3] = MCLine("mov",it.var1,reg1)
			
			c += 4


		case "cmp"

			tp := oPtr[it.var2].GetType()
			tp4 := oPtr[it.var4].GetType()

			if tp != tp4 {
				assert(IsRAXCastType(tp) and IsRAXCastType(tp4))
			}
			assert(oPtr[it.var1].GetType() == GTypeBool)

			r1 := X86Register
			r1 = "rax"
			r2 := r1
			r2 = "rdx"

			if IsFloat(tp)
			{
				r1 = "xmm0"
				r2 = "xmm1"
			}

			reg1 := pushReg(r1,tp)
			reg2 := pushReg(r2,tp)
			res := pushReg("rcx",GTypeBool)

			cPtr[c] = MCLine("mov",reg1,it.var2)
			cPtr[c+1] = MCLine("mov",reg2,it.var4)

			if IsFloat(tp) {
				if it.V3Cond() == ">" {
					cPtr[c+2] = MCLine("cmp",res,reg2,"<",reg1)
				}else if it.V3Cond() == ">=" {
					cPtr[c+2] = MCLine("cmp",res,reg2,"<=",reg1)
				}else {
					cPtr[c+2] = MCLine("cmp",res,reg1,it.V3Cond(),reg2)
				}
			}else{
				cPtr[c+2] = MCLine("cmp",res,reg1,it.V3Cond(),reg2)
			}

			cPtr[c+3] = MCLine("mov",it.var1,res)

			c += 4

		case "get_pointer"
			v1 := ref oPtr[it.var1]
			if v1 is MCConstRegisterX86
			{
				cPtr[c] = it
				c += 1
			}else{
				newReg := pushReg("rax",v1.GetType())
				cPtr[c] = it
				cPtr[c].var1 = newReg
				cPtr[c + 1] = MCLine("mov",it.var1,newReg)
				c += 2
			}
		case "llvm_store"
			ob1 := oPtr[it.var1]
			ob2 := oPtr[it.var2]

			tp := ob1.GetType()

			if ob1.GetType() == ob2.GetType() {
				reg := pushReg("rax",tp)

				cPtr[c] = MCLine("mov",reg,it.var2)
				cPtr[c+1] = MCLine("mov",it.var1,reg)
				c += 2
			}else{
				reg1 := pushReg("rcx",ob1.GetType())

				tp2 := ob2.GetType()
				reg2 := int
				if tp2.GetSize() > 8 {
					assert(tp2 is TypeVector)
					assert(tp2.GetSize() == 16)
					reg2 = pushReg("xmm0",tp2)
				}else{
					reg2 = pushReg("rax",tp2)
				}
				

				cPtr[c] = MCLine("mov",reg1,it.var1)
				cPtr[c+1] = MCLine("mov",reg2,it.var2)
				cPtr[c+2] = MCLine("llvm_store",reg1,reg2)
				c += 3

			}
		case "llvm_getelementptr"
		
			obj1 := oPtr[it.var2]
			if obj1 is MCGlobalVariable {
				r := pushReg("rcx",obj1.GetType().GetPoint())

				cPtr[c] = MCLine("get_pointer",r,it.var2)
				cPtr[c+1] = MCLine("llvm_getelementptr0",it.var1,r,it.var3)
				c += 2
			}else{
				cPtr[c] = it
				c += 1
			}
		case "mov"
			ob1 := oPtr[it.var1]
			if ob1 is MCGlobalVariable {
				r1 := pushReg("rax",ob1.GetType().GetPoint())
				r2 := pushReg("rcx",oPtr[it.var2].GetType())
				cPtr[c] = MCLine("get_pointer",r1,it.var1)
				cPtr[c+1] = MCLine("mov",r2,it.var2)
				cPtr[c+2] = MCLine("llvm_store",r1,r2)
				c += 3
			}else{
				cPtr[c] = it
				c += 1
			}
		case in !["sin","cos"]
			tp := oPtr[it.var2].GetType()
			assert(IsFloat(tp))

			newObj := MCConstPointerTyped
			switch tp
			{
			case GTypeFloat
				switch it.opcode
				{
				case "sin" newObj.GetValue() = x86_sinf
				case "cos" newObj.GetValue() = x86_cosf
				}
			case GTypeDouble
				switch it.opcode
				{
				case "sin" newObj.GetValue() = x86_sind
				case "cos" newObj.GetValue() = x86_cosd
				}
			}
			newObj.SetType(GetFuncType(![tp],tp).GetPoint())
			fncId := o
			oPtr[o] = newObj
			o += 1

			cPtr[c] = MCLine("call_start",it.var1,fncId)
			cPtr[c+1] = MCLine("load_var",it.var2)
			cPtr[c+2] = MCLine("call_end")
			c += 3

		case void
			cPtr[c] = it
			c += 1
		}
		i += 1
	}

	resTyp := fTyp.ResultType
	if resTyp == GTypeVoid {
		// this is fine
	}else if IsInt(resTyp) or IsPtrLikeType(resTyp) or resTyp == GTypeBool  or fTyp.ResultRef {
		reg := pushReg("rax",resTyp)
		cPtr[c] = MCLine("mov",reg,fnc.ResultIndex)
		c += 1
	}else if resTyp == GTypeFloat or resTyp == GTypeDouble or resTyp is TypeVector {
		reg := pushReg("xmm0",resTyp)
		cPtr[c] = MCLine("mov",reg,fnc.ResultIndex)
		c += 1
	}else{
		printf("unknown res type %s %s %i\n",resTyp.GetBADStr().Str(),resTyp.UnitName,fTyp.ResultRef)
		assert(false)
	}

	objs.Resize(o)
	cmds.Resize(c)

	result = new MCFunction

	result.Objects = objs
	result.Lines = cmds

	result.BaseFunction = fnc.BaseFunction
	result.ResultIndex = fnc.ResultIndex
	result.InputsIndxStart = fnc.InputsIndxStart
	result.InputsIndxCount = fnc.InputsIndxCount
}

x86_sinf := !(float x) -> float { return sin(x) }
x86_cosf := !(float x) -> float { return cos(x) }
x86_sind := !(double x) -> double { return sin(x) }
x86_cosd := !(double x) -> double { return cos(x) }
