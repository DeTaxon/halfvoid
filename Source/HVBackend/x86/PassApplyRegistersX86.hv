
PassApplyRegistersX86 := !(MCFunction^ fnc) ->MCFunction^
{
	bldr := MakeGreedyPass(fnc,4,6)

	oPtr := bldr.objs.GetPointer()
	o := ref bldr.objsSize

	pushVar := (int offset, Type^ varType) ==> int
	{
		newVar := MCConstVarX86

		newVar.GetValue() = offset
		newVar.SetType(varType)

		oPtr[o] = newVar
		result = o
		o += 1
	}
	pushVar2 := (Type^ varType) ==> int
	{
		newVar := MCVariable

		newVar.GetValueType() = varType

		result = o
		oPtr[o++] = newVar
	}

	c := ref bldr.cmdsSize
	cPtr := bldr.cmds.GetPointer()

	fTyp := NormalizeFuncType(fnc.BaseFunction.GetType()->{TypeFunc^})

	regAreaId := 0

	redInts := 0
	redFloats := 0

	if targetLinux
	{// load inputs
		stackIter := 16

		for i : fnc.InputsIndxCount
		{
			tp := fTyp.Params[i].ItType
			indx := i + fnc.InputsIndxStart

			reg := X86Register

			loadFromStack := false

			if (IsFloat(tp) or tp is TypeVector) and not fTyp.Params[i].IsRef {
				reg = "xmm0"
				if redFloats < 8 {
					reg&->{int^}^ += redFloats
					redFloats += 1
				}else{
					loadFromStack = true
				}
			}else{
				switch redInts
				{
				case 0 reg = "rdi"
				case 1 reg = "rsi"
				case 2 reg = "rdx"
				case 3 reg = "rcx"
				case 4 reg = "r8"
				case 5 reg = "r9"
				case void
					loadFromStack = true
				}
				redInts += 1
			}

			if loadFromStack
			{
				newVar := pushVar(stackIter,tp)
				stackIter += 8
				cPtr[c] = MCLine("mov",indx,newVar)
				c += 1
			}else{
				rt := bldr.PushReg(reg,tp)

				cPtr[c] = MCLine("mov",indx,rt)
				c += 1
			}
		}

		if fTyp.IsVargs
		{
			regArea := GetTypeByName(StringSpan("va_list_registers"))
			assert(regArea != null)
			if regArea != null
			{
				rId := pushVar2(regArea)

				r1 := bldr.PushReg("rax",GTypeVoidP)

				cPtr[c++] = MCLine("get_pointer",r1,rId)

				offset := 0

				for i : 6
				{
					reg := X86Register
					switch i
					{
					case 0 reg = "rdi"
					case 1 reg = "rsi"
					case 2 reg = "rdx"
					case 3 reg = "rcx"
					case 4 reg = "r8"
					case 5 reg = "r9"
					}

					cPtr[c++] = MCLine("store",rId,bldr.PushReg(reg,GTypeSizeT),bldr.PushInt(offset))
					offset += GTypeSizeT.GetSize()
				}

				for i : 8
				{
					reg := X86Register
					reg = "xmm0"
					reg&->{int^}^ += i
					cPtr[c++] = MCLine("store",rId,bldr.PushReg(reg,GTypeVec4f),bldr.PushInt(offset))
					offset += 16

				}

				regAreaId = rId
			}
		}
	}
	if targetWindows
	{// load inputs
		stackIter := 16 + 32 // 16 - ret address + push(rbp), 32 - reserved for first 4 variables

		for i : fnc.InputsIndxCount
		{
			tp := fTyp.Params[i].ItType
			indx := i + fnc.InputsIndxStart

			if i < 4 {
				reg := X86Register

				if (IsFloat(tp) or tp is TypeVector) and not fTyp.Params[i].IsRef {
					reg = "xmm0"
					reg&->{int^}^ += i
				}else{
					switch i
					{
					case 0 reg = "rcx"
					case 1 reg = "rdx"
					case 2 reg = "r8"
					case 3 reg = "r9"
					}
				}

				rt := bldr.PushReg(reg,tp)
				cPtr[c++] = MCLine("mov",indx,rt)
			}else{
				newVar := pushVar(stackIter,tp)
				stackIter += 8
				cPtr[c] = MCLine("mov",indx,newVar)
				c += 1
			}
		}

		if fTyp.IsVargs and fTyp.Params.Size() <= 4
		{
			r1 := bldr.PushReg("rax",GTypeVoidP)
			cPtr[c++] = MCLine("get_pointer",r1,pushVar(16,GTypeVoidP))

			for i : 4
			{
				reg := X86Register

				switch i
				{
				case 0 reg = "rcx"
				case 1 reg = "rdx"
				case 2 reg = "r8"
				case 3 reg = "r9"
				}

				cPtr[c++] = MCLine("store",r1,bldr.PushReg(reg,GTypeVoidP),bldr.PushInt(8*i))
			}
		}
	}

	i := 0
	while i < fnc.Lines.Size()
	{
		it := fnc.Lines[i]
		switch it.opcode
		{
		//case "debug_set_file"
		//case "debug_set_line" // delete debug info

		case "switch_start"
			cmpObj := it.var1
		
			i += 1

			while fnc.Lines[i].opcode != "switch_end"
			{
				ln := fnc.Lines[i]

				cPtr[c] = MCLine("jmp_if_op",ln.var2,cmpObj,"==",ln.var1)
				c += 1
				i += 1
			}
			

		case in !["div","mod","mul"]
			
			tp := oPtr[it.var1].GetType()

			r1 := X86Register
			r2 := X86Register
			r1 = "rax"
			r2 = "rcx"

			if IsFloat(tp) or tp is TypeVector {
				r1 = "xmm0"
				r2 = "xmm1"
			}

			reg1 := bldr.PushReg(r1,tp)
			reg2 := bldr.PushReg(r2,tp)

			cPtr[c] = MCLine("mov",reg1,it.var2)
			cPtr[c+1] = MCLine("mov",reg2,it.var3)

			cPtr[c+2] = MCLine("div",reg1,reg2) //NOTE, EDX used as well
			if it.opcode == "mul"
				cPtr[c+2].opcode = "mul"

			outReg := reg1
			if it.opcode == "mod"  {
				outReg = bldr.PushReg("rdx",tp)
			}
			cPtr[c+3] = MCLine("mov",it.var1,outReg)

			c += 4

		case in !["add","sub"]
			v1 := ref oPtr[it.var2]
			v2 := ref oPtr[it.var3]
			res := ref oPtr[it.var1]

			tp := v1.GetType()

			r1 := X86Register
			r2 := X86Register

			if tp == GTypeFloat or tp == GTypeDouble or tp is TypeVector {
				r1 = "xmm0"
				r2 = "xmm1"
			}else{
				r1 = "rax"
				r2 = "rdx"
			}

			if (v1 is MCConstInteger or v2 is MCConstInteger) and r1 == "rax"
			{
				reg1 := bldr.PushReg(r1,tp)
				valIdx := 0
				if v2 is MCConstInteger
				{
					cPtr[c++] = MCLine("mov",reg1,it.var2)
					valIdx = it.var3
				}else{
					cPtr[c++] = MCLine("mov",reg1,it.var3)
					valIdx = it.var2
				}
				cPtr[c++] = MCLine(it.opcode,reg1,valIdx)
				cPtr[c++] = MCLine("mov",it.var1,reg1)
				
			}else{

				reg1 := bldr.PushReg(r1,tp)
				reg2 := bldr.PushReg(r2,tp)

				cPtr[c] = MCLine("mov",reg1,it.var2)
				cPtr[c+1] = MCLine("mov",reg2,it.var3)
				cPtr[c+2] = MCLine(it.opcode,reg1,reg2)
				cPtr[c+3] = MCLine("mov",it.var1,reg1)
				
				c += 4
			}


		case "cmp"

			tp := oPtr[it.var2].GetType()
			tp4 := oPtr[it.var4].GetType()

			if tp != tp4 {
				assert(IsRAXCastType(tp) and IsRAXCastType(tp4))
			}
			assert(oPtr[it.var1].GetType() == GTypeBool)

			r1 := X86Register
			r1 = "rax"
			r2 := r1
			r2 = "rdx"

			if IsFloat(tp)
			{
				r1 = "xmm0"
				r2 = "xmm1"
			}

			reg1 := bldr.PushReg(r1,tp)
			reg2 := bldr.PushReg(r2,tp)
			res := bldr.PushReg("rcx",GTypeBool)

			cPtr[c] = MCLine("mov",reg1,it.var2)
			cPtr[c+1] = MCLine("mov",reg2,it.var4)

			if IsFloat(tp) {
				if it.V3Cond() == ">" {
					cPtr[c+2] = MCLine("cmp",res,reg2,"<",reg1)
				}else if it.V3Cond() == ">=" {
					cPtr[c+2] = MCLine("cmp",res,reg2,"<=",reg1)
				}else {
					cPtr[c+2] = MCLine("cmp",res,reg1,it.V3Cond(),reg2)
				}
			}else{
				cPtr[c+2] = MCLine("cmp",res,reg1,it.V3Cond(),reg2)
			}

			cPtr[c+3] = MCLine("mov",it.var1,res)

			c += 4

		case "get_pointer"
			v1 := ref oPtr[it.var1]
			if v1 is MCConstRegisterX86
			{
				cPtr[c] = it
				c += 1
			}else{
				newReg := bldr.PushReg("rax",v1.GetType())
				cPtr[c] = it
				cPtr[c].var1 = newReg
				cPtr[c + 1] = MCLine("mov",it.var1,newReg)
				c += 2
			}
		case "store"
			ob1 := oPtr[it.var1]
			ob2 := oPtr[it.var2]

			tp := ob1.GetType()

			if ob1.GetType() == ob2.GetType() {
				reg := bldr.PushReg("rax",tp)

				cPtr[c] = MCLine("mov",reg,it.var2)
				cPtr[c+1] = MCLine("mov",it.var1,reg)
				c += 2
			}else{
				reg1 := bldr.PushReg("rcx",ob1.GetType())

				tp2 := ob2.GetType()
				reg2 := int
				if tp2 is TypeVector or  IsFloat(tp2) {
					reg2 = bldr.PushReg("xmm0",tp2)
				}else{
					reg2 = bldr.PushReg("rax",tp2)
				}
				

				cPtr[c] = MCLine("mov",reg1,it.var1)
				cPtr[c+1] = MCLine("mov",reg2,it.var2)
				cPtr[c+2] = MCLine("store",reg1,reg2)
				c += 3

			}
		case "load"
			ob1 := oPtr[it.var1]
			ob2 := oPtr[it.var2]

			tp := ob1.GetType()

			if ob1.GetType() == ob2.GetType() {
				reg := bldr.PushReg("rax",tp)

				cPtr[c] = MCLine("mov",reg,it.var2)
				cPtr[c+1] = MCLine("mov",it.var1,reg)
				c += 2
			}else{
				reg1 := bldr.PushReg("rcx",ob2.GetType())

				reg2 := int
				if tp is TypeVector or IsFloat(tp) {
					reg2 = bldr.PushReg("xmm0",tp)
				}else{
					reg2 = bldr.PushReg("rax",tp)
				}
				

				cPtr[c] = MCLine("mov",reg1,it.var2)
				cPtr[c+1] = MCLine("load",reg2,reg1)
				cPtr[c+2] = MCLine("mov",it.var1,reg2)
				c += 3
			}
		case in !["get_array_elem_ptr"]
		
			obj1 := oPtr[it.var2]
			tp := oPtr[it.var2].GetType()

			if tp is in TypePoint or tp == GTypeStr {
				r1 := bldr.PushReg("rax",GTypeInt)
				r2 := bldr.PushReg("rdx",GTypeInt)

				tpSize := tp.Base.GetSize()
				tpSizeIndx := bldr.PushInt(tpSize)

				cPtr[c++] = MCLine("mov",r1,tpSizeIndx)
				cPtr[c++] = MCLine("mov",r2,it.var3)
				cPtr[c++] = MCLine("mul",r1,r2)
				cPtr[c++] = MCLine("mov",r2,it.var2)
				cPtr[c++] = MCLine("add",r1,r2)
				cPtr[c++] = MCLine("mov",it.var1,r1)
			}else {
				cPtr[c] = it
				c += 1
			}
		case "mov"
			ob1 := oPtr[it.var1]
			if ob1 is MCGlobalVariable {
				r1 := bldr.PushReg("rax",ob1.GetType().GetPoint())
				r2 := bldr.PushReg("rcx",oPtr[it.var2].GetType())
				cPtr[c] = MCLine("get_pointer",r1,it.var1)
				cPtr[c+1] = MCLine("mov",r2,it.var2)
				cPtr[c+2] = MCLine("store",r1,r2)
				c += 3
			}else{
				cPtr[c] = it
				c += 1
			}
		case "cast"
			tpTo := oPtr[it.var1].GetType()
			tpFrom := oPtr[it.var2].GetType()

			if IsRAXCastType(tpTo) and IsRAXCastType(tpFrom)
			{
				rFrom := bldr.PushReg("rax",tpFrom)
				rTo := bldr.PushReg("rax",tpTo)
				cPtr[c++] = MCLine("mov",rFrom,it.var2)
				cPtr[c++] = MCLine("mov",it.var1,rTo)

			}else{
				cPtr[c++] = it
			}
		case in !["sin","cos"]
			tp := oPtr[it.var2].GetType()
			assert(IsFloat(tp))

			newObj := MCConstPointerTyped
			switch tp
			{
			case GTypeFloat
				switch it.opcode
				{
				case "sin" newObj.GetValue() = x86_sinf
				case "cos" newObj.GetValue() = x86_cosf
				}
			case GTypeDouble
				switch it.opcode
				{
				case "sin" newObj.GetValue() = x86_sind
				case "cos" newObj.GetValue() = x86_cosd
				}
			}
			newObj.SetType(GetFuncType(![tp],tp).GetPoint())
			fncId := o
			oPtr[o] = newObj
			o += 1

			cPtr[c] = MCLine("call_start",it.var1,fncId)
			cPtr[c+1] = MCLine("load_var",it.var2)
			cPtr[c+2] = MCLine("call_end")
			c += 3
		case "memset"
			newObj := MCConstPointerTyped
			newObj.GetValue() = memset
			newObj.SetType(GetFuncType(![GTypeVoidP,GTypeU8,GTypeSizeT],GTypeVoid).GetPoint())
			fncId := o
			oPtr[o++] = newObj

			cPtr[c++] = MCLine("call_start",0,fncId)
			cPtr[c++] = MCLine("load_var",it.var1)
			cPtr[c++] = MCLine("load_var",it.var2)
			cPtr[c++] = MCLine("load_var",it.var3)
			cPtr[c++] = MCLine("call_end")

		case "va_start"
			if targetLinux
			{
				r1 := bldr.PushReg("rax",GTypeVoidP.GetPoint())
				r2 := bldr.PushReg("rcx",GTypeInt)
				r3 := bldr.PushReg("rcx",GTypeVoidP.GetPoint())

				cPtr[c++] = MCLine("mov",r1,it.var1)
				cPtr[c++] = MCLine("mov",r2,bldr.PushInt(min(redInts,6)*8))
				cPtr[c++] = MCLine("store",r1,r2)
				cPtr[c++] = MCLine("mov",r2,bldr.PushInt(min(redFloats,8)*16 + 6*8))
				cPtr[c++] = MCLine("store",r1,r2,bldr.PushInt(4))

				cPtr[c++] = MCLine("get_pointer",r3,pushVar(16,GTypeSizeT))
				cPtr[c++] = MCLine("store",r1,r3,bldr.PushInt(8))
				cPtr[c++] = MCLine("get_pointer",r3,regAreaId)
				cPtr[c++] = MCLine("store",r1,r3,bldr.PushInt(16))
			}
			if targetWindows
			{
				r1 := bldr.PushReg("rax",GTypeVoidP.GetPoint())
				r2 := bldr.PushReg("rcx",GTypeVoidP.GetPoint())
				
				offst := min(fTyp.Params.Size(),4)

				cPtr[c++] = MCLine("get_pointer",r2,pushVar( offst*8 + 16,GTypeVoidP.GetPoint()))
				cPtr[c++] = MCLine("mov",r1,it.var1)
				cPtr[c++] = MCLine("store",r1,r2)
				
			}
		case "va_end"
			//nothing

		case void
			cPtr[c] = it
			c += 1
		}
		i += 1
	}

	resTyp := fTyp.ResultType
	if resTyp == GTypeVoid {
		// this is fine
	}else if IsInt(resTyp) or IsPtrLikeType(resTyp) or resTyp == GTypeBool  or fTyp.ResultRef {
		reg := bldr.PushReg("rax",resTyp)
		cPtr[c] = MCLine("mov",reg,fnc.ResultIndex)
		c += 1
	}else if resTyp == GTypeFloat or resTyp == GTypeDouble or resTyp is TypeVector {
		reg := bldr.PushReg("xmm0",resTyp)
		cPtr[c] = MCLine("mov",reg,fnc.ResultIndex)
		c += 1
	}else{
		printf("unknown res type %s %s %i\n",resTyp.GetBADStr().Str(),resTyp.UnitName,fTyp.ResultRef)
		assert(false)
	}

	return bldr.GenerateFunc()
}

x86_sinf := !(float x) -> float { return sin(x) }
x86_cosf := !(float x) -> float { return cos(x) }
x86_sind := !(double x) -> double { return sin(x) }
x86_cosd := !(double x) -> double { return cos(x) }
