MCInterpFunction := !(MCInterpContext^ iCntx,MCFunction^ interpFunc) -> void
{
	cs := 0
	thisFrame := MCInterpFuncFrame
	thisFrame.func = interpFunc

	opPtr := interpFunc.Lines.GetPointer()
	assert(opPtr != null)

	opsCount := interpFunc.Lines.Size()
	while cs < opsCount
	{
		if opPtr[cs].opcode == "call_start"
		{
			fncObj := ref interpFunc.Objects[opPtr[cs].var1]
			cs += 1

			indxs := HybridQueue.{int,8}
			while opPtr[cs].opcode != "call_end"
			{
				if opPtr[cs].opcode == "load_var"
				{
					indxs.Push(opPtr[cs].var1)
				}else{
					assert(false)
				}
				cs += 1
			}
			cs += 1

			if fncObj& is MCConstFunction
			{
				fncHV := fncObj&->{MCConstFunction^}.GetValue()

				if fncHV is BoxFuncDeclare
				{
					fncType := fncHV.GetType()->{TypeFunc^}
					thisFrame.CallFuncPtr(fncType,iCntx.DeclareToPtr(fncHV->{BoxFuncDeclare^}),indxs,0)
				}else{
					assert(false)
				}
			}

		}else{
			printf("unknown opcode %s at %i\n",interpFunc.Lines[cs].opcode.ToCStr(),cs)
			cs += 1
		}
	}
}
