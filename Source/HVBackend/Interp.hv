MCInterpFunction := !(MCInterpContext^ iCntx,MCFunction^ interpFunc) -> void
{
	cs := 0
	thisFrame := MCInterpFuncFrame
	thisFrame.func = interpFunc

	opPtr := interpFunc.Lines.GetPointer()
	assert(opPtr != null)

	thisFrame.localVarBlob = new BlobOnVector(512) //TODO calculate stack size
	for it,i : interpFunc.Objects
	{
		if it& is MCVariable
		{
			thisFrame.localVarTable[i] = thisFrame.localVarBlob.GetPointer() //TODO hm
		}
	}

	opsCount := interpFunc.Lines.Size()
	while cs < opsCount
	{
		thisLine := ref opPtr[cs]
		if opPtr[cs].opcode == "call_start"
		{
			fncObj := ref interpFunc.Objects[opPtr[cs].var1]
			cs += 1

			indxs := HybridQueue.{int,8}
			while opPtr[cs].opcode != "call_end"
			{
				if opPtr[cs].opcode == "load_var"
				{
					indxs.Push(opPtr[cs].var1)
				}else{
					assert(false)
				}
				cs += 1
			}
			cs += 1

			if fncObj& is MCConstFunction
			{
				fncHV := fncObj&->{MCConstFunction^}.GetValue()

				if fncHV is BoxFuncDeclare
				{
					fncType := fncHV.GetType()->{TypeFunc^}
					thisFrame.CallFuncPtr(fncType,iCntx.DeclareToPtr(fncHV->{BoxFuncDeclare^}),indxs,0)
				}else{
					//fncHV.WriteFuncCallMC(iCntx,indxs)
				}
			}

		}else if opPtr[cs].opcode == "clean"{
			obj := interpFunc.Objects[opPtr[cs].var1]
			clnVar := thisFrame.GetObjectPtr(opPtr[cs].var1)
			assert(clnVar != null)

			memset(clnVar,0,obj.GetType().GetSize())
			cs += 1
		}else if thisLine.opcode == "add" {
			objTyp := interpFunc.Objects[thisLine.var2].GetType()

			ptrRes := thisFrame.GetObjectPtr(opPtr[cs].var1)
			ptr1 := thisFrame.GetObjectPtr(opPtr[cs].var2)
			ptr2 := thisFrame.GetObjectPtr(opPtr[cs].var3)

			if IsInt(objTyp)
			{
				bigInt := s64
				switch objTyp.GetSize()
				{
					case 1 ptrRes->{s8^}^ = ptr1->{s8^}^ + ptr2->{s8^}^
					case 2 ptrRes->{s16^}^ = ptr1->{s16^}^ + ptr2->{s16^}^
					case 4 ptrRes->{s32^}^ = ptr1->{s32^}^ + ptr2->{s32^}^
					case 8 ptrRes->{s64^}^ = ptr1->{s64^}^ + ptr2->{s64^}^
				}
			}else{
				assert(false)
			}
			cs += 1
		}else if thisLine.opcode == "sub" {
			objTyp := interpFunc.Objects[thisLine.var2].GetType()

			ptrRes := thisFrame.GetObjectPtr(opPtr[cs].var1)
			ptr1 := thisFrame.GetObjectPtr(opPtr[cs].var2)
			ptr2 := thisFrame.GetObjectPtr(opPtr[cs].var3)

			if IsInt(objTyp)
			{
				bigInt := s64
				switch objTyp.GetSize()
				{
					case 1 ptrRes->{s8^}^ = ptr1->{s8^}^ - (ptr2->{s8^}^)
					case 2 ptrRes->{s16^}^ = ptr1->{s16^}^ - (ptr2->{s16^}^)
					case 4 ptrRes->{s32^}^ = ptr1->{s32^}^ - (ptr2->{s32^}^)
					case 8 ptrRes->{s64^}^ = ptr1->{s64^}^ - (ptr2->{s64^}^)
				}
			}else{
				assert(false)
			}
			cs += 1
		}else{
			printf("unknown opcode %s at %i\n",interpFunc.Lines[cs].opcode.ToCStr(),cs)
			cs += 1
		}
	}
}
