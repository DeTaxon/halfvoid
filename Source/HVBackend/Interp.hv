
MCInterpFunction2 := !(MCInterpContext^ iCntx,MCFunction^ interpFunc, Vector.{void^} inputs,void^ resultPtr = null) -> void
{
	fType := interpFunc.BaseFunction->{BoxFuncBody^}.GetType()->{TypeFunc^}

	isComplex := fType.ResultType.IsComplexReturn() and not fType.ResultRef
	if fType.ExtraResults.Size() != 0
		isComplex = true

	if isComplex and resultPtr != null
	{
		vars2 := MakeVectorOnStack.{void^,20}()
		vars2.Push(resultPtr)
		for it : inputs
		{
			vars2.Push(it)
		}
		MCInterpFunction(iCntx,interpFunc,vars2,null)
	}else{
		MCInterpFunction(iCntx,interpFunc,inputs,resultPtr)
	}

}

MCInterpFunction := !(MCInterpContext^ iCntx,MCFunction^ interpFunc, Vector.{void^} inputs,void^ resultPtr = null) -> void
{
	if interpFunc.Lines.Size() == 0
		return void

	objCount := 0
	if inputs.Size() != 0
	{
		objCount = 5 + inputs.Size()
	}

	thisFrame := MCInterpFuncFrame
	thisFrame.CreateStack()
	thisFrame.CreateFrame(iCntx,interpFunc,objCount)

	defer thisFrame.DestroyStack()

	
	retIndex := 0
	if resultPtr != null
	{
		retIndex = 1
		thisFrame.localVarTable[1] = resultPtr
	}
	inptsIndexes := MakeVectorOnStack.{int,10}()
	if inputs.Size() != 0
	{
		for it,i : inputs
		{
			c := i + 5
			inptsIndexes.Push(c)
			thisFrame.localVarTable[c] = it
		}
	}
	MCInterpFunction(iCntx,interpFunc,thisFrame&,inptsIndexes,retIndex)
}

MCInterpFunction := !(MCInterpContext^ iCntx,MCFunction^ interpFunc, MCInterpFuncFrame^ callerFrame, Vector.{int} callerIndx,int returnIndex = 0) -> void
{
	// interpFunc.Print()
	//exit(0)

	if interpFunc.Lines.Size() == 0
		return void

	assert(callerFrame != null)

	thisFrame := MCInterpFuncFrame
	thisFrame.InheritStack(callerFrame)
	thisFrame.CreateFrame(iCntx,interpFunc)
	thisFrame.callerIndx = callerIndx
	thisFrame.ParentFrame = callerFrame

	cs := ref thisFrame.cs

	opPtr := interpFunc.Lines.GetPointer()
	assert(opPtr != null)

	useStackSize := interpFunc.StackFrameSize
	thisFrame.localVarBlob = thisFrame.AllocateOnStack(useStackSize)->{u8^}
	//memset(thisFrame.localVarBlob.GetPointer(),0,useStackSize)
	
	for it,i : interpFunc.Objects
	{
		offset := interpFunc.StackOffsets[i]
		if it& is MCVariable or it is MCConstValue
		{
			thisFrame.localVarTable[i] = thisFrame.localVarBlob[offset]&
		}
		if it& is MCReference
		{
			thisFrame.localVarTable[i] = thisFrame.localVarBlob[offset]&
		}
		//if it.IsConstant
		//{
		//	thisFrame.localVarTable[i] = it.Value&
		//}
		
	}
	if callerFrame != null and returnIndex != 0
	{
		thisFrame.localVarTable[interpFunc.ResultIndex] = callerFrame.localVarTable[returnIndex]
	}
	if callerIndx.Size() != 0
	{
		argCount := min(callerIndx.Size(),interpFunc.InputsIndxCount)
		rng := Range(interpFunc.InputsIndxStart,interpFunc.InputsIndxStart + argCount - 1)
		for it,i : rng
		{
			thisFrame.localVarTable[it] = callerFrame.localVarTable[callerIndx[i]]
		}
	}

	labelsPtr := interpFunc.StackOffsets.GetPointer()

	opsCount := interpFunc.Lines.Size()
	while cs < opsCount
	{
		//printf("line %i %s %i\n",cs,thisFrame.DebugFileName,thisFrame.DebugFileLine)
		thisLine := ref opPtr[cs]
		switch thisLine.opcode
		{
		case "noop"
		case "call_start"
			fncObj := ref interpFunc.Objects[opPtr[cs].var2]
			returnIndexCall := opPtr[cs].var1
			cs += 1


			indxs := MakeVectorOnStack.{int,20}()
			while opPtr[cs].opcode != "call_end"
			{
				if opPtr[cs].opcode == "load_var"
				{
					indxs.Push(opPtr[cs].var1)
				}else{
					assert(false)
				}
				cs += 1
			}

			resultPtr := thisFrame.GetObjectPtr(thisLine.var1)

			if fncObj& is MCConstFunction
			{
				fncHV := fncObj&->{MCConstFunction^}.GetValue()

				if fncHV is ResistFunc
				{
					fncHV = fncHV->{ResistFunc^}.base
				}

				if fncHV is in BuildInVirtualCall
				{
					vTableIndx := 0
					fType := fncHV->{BuildInVirtualCall^}.wrappedFunc.GetType()->{TypeFunc^}

					if (fType.ResultType.IsComplexReturn() and not fType.ResultRef) or fType.ExtraResults.Size() != 0
						vTableIndx = 1
			
					v1 := thisFrame.GetObjectPtr(indxs[vTableIndx])
					vTable := v1->{void^^^}^^

					virtualFunc := fncHV->{BuildInVirtualCall^}.wrappedFunc

					if virtualFunc is ResistFunc
					{
						virtualFunc = virtualFunc->{ResistFunc^}.base
					}

					virtualFunc->{BoxFuncBody^}.WaitReadyState()

					vTblCls := virtualFunc->{BoxFuncBody^}.Params[0].GetType()->{TypeClass^}
					cls := vTblCls.ToClass.VTableType
					//globVar := iCntx.GetGlobalVarFromMem(vTable)
					//assert(globVar != null)
					//cls := globVar.GetType()->{TypeClass^}.ToClass
					memField := cls.GetFieldByIndex(fncHV->{BuildInVirtualCall^}.funcIndex)
					memOffset := memField.MemOffset

					memObj := vTable->{u8^}[memOffset]&->{BoxUnit^^}^

					fPtr := iCntx.GetFuncByPointer(memObj)
					
					if iCntx.vtableFunctions.Value.ContainSome(memObj)
					{
						mx := iCntx.vtableFunctions.Value.GetOne(memObj)

						if mx is ResistFunc
						{
							mx = mx->{ResistFunc^}.base->{BoxFuncBody^}
						}

						assert(mx is in BoxFuncBody)

						fncAsMC := iCntx.GetMCFunc(mx)
						assert(fncAsMC != null)

						MCInterpFunction(iCntx,fncAsMC,thisFrame&,indxs,returnIndexCall)
					}else{
						fncType := memField.GetType()->{TypeFunc^}.ResultType.Base
						thisFrame.CallFuncPtr(fncType->{TypeFunc^},memObj,resultPtr,indxs,0)
					}

				}else if fncHV is BoxFuncDeclare {
					fncType := fncHV.GetType()->{TypeFunc^}
					thisFrame.CallFuncPtr(fncType,iCntx.DeclareToPtr(fncHV->{BoxFuncDeclare^}),resultPtr,indxs,0)
				}else if fncHV is in BoxFuncBody{
					bdy := fncHV->{BoxFuncBody^}
					fncPtr := void^

					fncAsMC := iCntx.GetMCFunc(fncHV->{BoxFuncBody^})
					MCInterpFunction(iCntx,fncAsMC,thisFrame&,indxs,returnIndexCall)
				}else{
					printf("failed to call, unknown class %s\n",fncHV.UnitName)
					assert(false)
				}
			} else if fncObj& is MCConstPointerTyped {
				fType := fncObj.GetType().Base->{TypeFunc^}
				thisFrame.CallFuncPtr(fType,fncObj&->{MCConstPointer^}.GetValue(),resultPtr,indxs,0)
			} else if fncObj& is MCVariable or fncObj& is MCReference or fncObj is MCConstValue {
				functionPointer := thisFrame.GetObjectPtr(thisLine.var2)->{void^^}^
				assert(functionPointer != null) //TODO emit error
				fncVal := iCntx.GetFuncByPointer(functionPointer)
				if fncVal != null
				{
					MCInterpFunction(iCntx,fncVal,thisFrame&,indxs,returnIndexCall)
				}else{
					fType := fncObj.GetType().Base->{TypeFunc^}
					thisFrame.CallFuncPtr(fType,functionPointer,resultPtr,indxs,0)
				}
			} else if fncObj& is MCGlobalVariable
			{
				glbVar := fncObj&->{MCGlobalVariable^}.GetValueObject()
				memObj := GlobsMem.GetGlobalVarMem(glbVar)
				assert(memObj != null)
				fncVal := iCntx.GetFuncByPointer(memObj->{void^^}^)
				if fncVal != null
				{
					MCInterpFunction(iCntx,fncVal,thisFrame&,indxs,returnIndexCall)
				}else{
					thisFrame.CallFuncPtr(glbVar.GetType().Base->{TypeFunc^},memObj->{void^^}^,resultPtr,indxs,0)
				}

			}else{
				fncObj.PrintObject()
				assert(false)
			}

		case "clean"
			obj := interpFunc.Objects[thisLine.var1]
			clnVar := thisFrame.GetObjectPtr(thisLine.var1)
			assert(clnVar != null)

			memset(clnVar,0,obj.GetType().GetSize())
		case in !["and","or","xor","sshr","ushr","shl"]

			v1 := thisFrame.LoadS64(thisLine.var2)
			v2 := thisFrame.LoadS64(thisLine.var3)
			res := s64

			switch thisLine.opcode
			{
			case "and" res = v1 and_b v2
			case "or" res = v1 or_b v2
			case "xor" res = v1 xor_b v2
			case "sshr" res = v1 shr v2
			case "ushr" res = v1->{u64} shr v2->{u64}
			case "shl" res = v1 shl v2
			}

			thisFrame.StoreS64(thisLine.var1,res)

		case "not"
			objTyp := interpFunc.Objects[thisLine.var1].GetType()

			ptr1 := thisFrame.GetObjectPtr(thisLine.var1)
			ptr2 := thisFrame.GetObjectPtr(thisLine.var2)

			if objTyp == GTypeBool
			{
				ptr1->{bool^}^ = ptr2->{u8^}^ == 0
			}else{
				assert(false)
			}
		case in !["add","sub","mul","div","mod"]
			objTyp := interpFunc.Objects[thisLine.var2].GetType()

			if IsInt(objTyp)
			{
				v1 := thisFrame.LoadS64(thisLine.var2)
				v2 := thisFrame.LoadS64(thisLine.var3)
				res := s64

				if IsUInt(objTyp) {
					switch thisLine.opcode
					{
					case "add" res = v1->{u64} + v2->{u64}
					case "sub" res = v1->{u64} - v2->{u64}
					case "mul" res = v1->{u64} * v2->{u64}
					case "div" res = v1->{u64} div v2->{u64}
					case "mod" res = v1->{u64} mod v2->{u64}
					}
				}else{
					switch thisLine.opcode
					{
					case "add" res = v1 + v2
					case "sub" res = v1 - v2
					case "mul" res = v1 * v2
					case "div" res = v1 div v2
					case "mod" res = v1 mod v2
					}
				}


				thisFrame.StoreS64(thisLine.var1,res)
			}else if IsFloat(objTyp)
			{
				v1 := thisFrame.LoadDouble(thisLine.var2)
				v2 := thisFrame.LoadDouble(thisLine.var3)
				res := double

				switch thisLine.opcode
				{
				case "add" res = v1 + v2
				case "sub" res = v1 - v2
				case "mul" res = v1 * v2
				case "div" res = v1 / v2
				}

				thisFrame.StoreDouble(thisLine.var1,res)
			}else if IsVecType(objTyp) {
				v1 := thisFrame.LoadVec4f(thisLine.var2)
				v2 := thisFrame.LoadVec4f(thisLine.var3)
				res := vec4f

				switch thisLine.opcode
				{
				case "add" res = v1 + v2
				case "sub" res = v1 - v2
				case "mul" res = v1 * v2
				case "div" res = v1 / v2
				}

				thisFrame.StoreVec4f(thisLine.var1,res)
			}else{
				printf("some add %s\n",objTyp.GetBADStr().Str())
				assert(false)
			}
		case "cmp"
			objTyp := interpFunc.Objects[thisLine.var2].GetType()
			resBool := thisFrame.GetObjectPtr(thisLine.var1)->{bool^}

			spc := s64

			if IsInt(objTyp) or objTyp is TypeEnum or objTyp is in TypePoint
			{
				v1 := thisFrame.LoadS64(thisLine.var2)
				v2 := thisFrame.LoadS64(thisLine.var4)

				if IsSInt(objTyp) {
					spc = v1 <=> v2
				}else{
					spc = v1->{u64} <=> v2->{u64}
				}
			}else if IsFloat(objTyp)
			{
				v1 := thisFrame.LoadDouble(thisLine.var2)
				v2 := thisFrame.LoadDouble(thisLine.var4)
				spcFloat := v1 - v2
				if spcFloat > 0
					spc = 1
				if spcFloat < 0
					spc = -1
			}else{
				printf("failed to cmp, unknown type %s\n",objTyp.GetBADStr().Str())
				assert(false)
			}

			switch thisLine.V3Cond()
			{
				case "==" resBool^ = (spc == 0)
				case "!=" resBool^ = (spc != 0)
				case "<=" resBool^ = (spc <= 0)
				case "<" resBool^ = (spc < 0)
				case ">=" resBool^ = (spc >= 0)
				case ">" resBool^ = (spc > 0)
				case "<=>" resBool->{int^}^ = spc
				case void
					assert(false)
			}
		case "label"
		case "jmp"
			//cs = getLabel(thisLine.var1)
			cs = labelsPtr[thisLine.var1] - 1
		case "jmp_if_bool"
			boolVar := thisFrame.GetObjectPtr(thisLine.var2)->{u8^}
			if boolVar^ != 0
			{
				cs = labelsPtr[thisLine.var1] - 1
			}
		case "mov"
			v1 := thisFrame.GetObjectPtr(thisLine.var1)
			v2 := thisFrame.GetObjectPtr(thisLine.var2)
			typeSize := interpFunc.Objects[thisLine.var1].GetType().GetSize()
			memcpy(v1,v2,typeSize)
		case "cast"
			v1 := thisFrame.GetObjectPtr(thisLine.var1)
			v2 := thisFrame.GetObjectPtr(thisLine.var2)
			toType := interpFunc.Objects[thisLine.var1].GetType()
			fromType := interpFunc.Objects[thisLine.var2].GetType()
			typeSize := toType.GetSize()

			if IsInt(toType) and IsInt(fromType)
			{
				oldType := interpFunc.Objects[thisLine.var2].GetType()
				if typeSize > oldType.GetSize() and not IsUInt(toType)
				{
					memset(v1,0,typeSize)
					memcpy(v1,v2,min(typeSize,oldType.GetSize()) )
				}else{
					memset(v1,0,typeSize)
					memcpy(v1,v2,min(typeSize,oldType.GetSize()) )
				}
			}else if toType is in TypePoint
			{
				//memset(v1,0,typeSize)
				memcpy(v1,v2,typeSize)
			}else if IsFloat(toType) and IsInt(fromType)
			{
				val := s64
				memcpy(val&,v2,fromType.GetSize())
				if not IsUInt(fromType)
				{
					shift := (8 - fromType.GetSize()) * 8
					val = val shl shift
					val = val shr shift
				}
				switch toType
				{
				case GTypeFloat v1->{float^}^ = val
				case GTypeDouble v1->{double^}^ = val
				case void
					assert(false)
				}
			}else if IsFloat(toType) and IsFloat(fromType)
			{
				bigFloat := double
				switch fromType.GetSize()
				{
					case 4 bigFloat = v2->{float^}^
					case 8 bigFloat = v2->{double^}^
				}
				switch toType.GetSize()
				{
					case 4 v1->{float^}^ = bigFloat
					case 8 v1->{double^}^ = bigFloat
				}
			}else if IsInt(toType) and IsFloat(fromType)
			{
				bigFloat := double
				switch fromType.GetSize()
				{
					case 4 bigFloat = v2->{float^}^
					case 8 bigFloat = v2->{double^}^
				}
				switch toType.GetSize()
				{
					case 1 v1->{s8^}^ = bigFloat
					case 2 v1->{s16^}^ = bigFloat
					case 4 v1->{s32^}^ = bigFloat
					case 8 v1->{s64^}^ = bigFloat
				}

			}else if IsInt(toType) and fromType is in TypeEnum {
				minSize := min(toType.GetSize(),fromType.GetSize())
				memset(v1,0,toType.GetSize())
				memcpy(v1,v2,minSize)
			}else if toType is in TypeEnum and IsInt(fromType) {
				minSize := min(toType.GetSize(),fromType.GetSize())
				memset(v1,0,toType.GetSize())
				memcpy(v1,v2,minSize)
			} else
			{
				printf("can not cast type %s to %s\n",fromType.GetBADStr().Str(),toType.GetBADStr().Str())
				assert(false)
			}
		case "load_element_opt_class_const"
			setPtr := thisFrame.GetReferencePtr(thisLine.var1)
			v2 := thisFrame.GetObjectPtr(thisLine.var2)
			setPtr->{u8^^}^ = v2->{u8^}[thisLine.ConstValue]&
		case "set_reference"
			v1 := thisFrame.GetReferencePtr(thisLine.var1)
			v2 := thisFrame.GetObjectPtr(thisLine.var2)
			v1->{void^^}^ = v2
		case "get_pointer"
			res := thisFrame.GetObjectPtr(thisLine.var1)

			obj := ref interpFunc.Objects[thisLine.var2]
			if obj& is MCReference
			{
				res->{void^^}^ = thisFrame.localVarTable[thisLine.var2]->{void^^}^
			}else if obj& is MCVariable{
				res->{void^^}^ = thisFrame.localVarTable[thisLine.var2]
			}else if obj& is MCGlobalVariable {
				res->{void^^}^ = GlobsMem.GetGlobalVarMem(obj&->{MCGlobalVariable^}.GetValueObject())
			}else if obj& is MCConstInteger{
				res->{void^^}^ = obj&->{MCConstInteger^}.GetValue()&
			}else if obj& is MCConstVoid{
				res->{void^^}^ = null
			}else if obj& is MCConstFunction{
				frFunc := obj&->{MCConstFunction^}.GetValue()
				assert(frFunc is BoxFuncBody) //TODO to error?
				mcFunc := iCntx.GetMCFunc(frFunc->{BoxFuncBody^})
				assert(mcFunc != null)
				mcFuncPtr := iCntx.GetFunctionPointer(mcFunc)
				res->{void^^}^ = mcFuncPtr
			}else{
				printf("unknown object %s\n",obj.UnitName)
				assert(false)
			}
		case "max"
			objTyp := interpFunc.Objects[thisLine.var2].GetType()

			ptrRes := thisFrame.GetObjectPtr(opPtr[cs].var1)
			ptr1 := thisFrame.GetObjectPtr(opPtr[cs].var2)
			ptr2 := thisFrame.GetObjectPtr(opPtr[cs].var3)

			if IsInt(objTyp)
			{
				switch objTyp.GetSize()
				{
					case 1 ptrRes->{s8^}^ = max(ptr1->{s8^}^,ptr2->{s8^}^)
					case 2 ptrRes->{s16^}^ =max(ptr1->{s16^}^ ,ptr2->{s16^}^)
					case 4 ptrRes->{s32^}^ =max(ptr1->{s32^}^ ,ptr2->{s32^}^)
					case 8 ptrRes->{s64^}^ =max(ptr1->{s64^}^ ,ptr2->{s64^}^)
				}
			}else if IsFloat(objTyp)
			{
				switch objTyp.GetSize()
				{
					case 4 ptrRes->{float^}^  = max(ptr1->{float^}^  ,ptr2->{float^}^)
					case 8 ptrRes->{double^}^ = max(ptr1->{double^}^ ,ptr2->{double^}^)
				}
			}else{
				assert(false)
			}
		case "min"
			objTyp := interpFunc.Objects[thisLine.var2].GetType()

			ptrRes := thisFrame.GetObjectPtr(opPtr[cs].var1)
			ptr1 := thisFrame.GetObjectPtr(opPtr[cs].var2)
			ptr2 := thisFrame.GetObjectPtr(opPtr[cs].var3)

			if IsInt(objTyp)
			{
				switch objTyp.GetSize()
				{
					case 1 ptrRes->{s8^}^ = min(ptr1->{s8^}^,ptr2->{s8^}^)
					case 2 ptrRes->{s16^}^ =min(ptr1->{s16^}^ ,ptr2->{s16^}^)
					case 4 ptrRes->{s32^}^ =min(ptr1->{s32^}^ ,ptr2->{s32^}^)
					case 8 ptrRes->{s64^}^ =min(ptr1->{s64^}^ ,ptr2->{s64^}^)
				}
			}else if IsFloat(objTyp)
			{
				switch objTyp.GetSize()
				{
					case 4 ptrRes->{float^}^  = min(ptr1->{float^}^  ,ptr2->{float^}^)
					case 8 ptrRes->{double^}^ = min(ptr1->{double^}^ ,ptr2->{double^}^)
				}
			}else{
				assert(false)
			}
		case "sqrt"
			objTyp := interpFunc.Objects[thisLine.var2].GetType()

			ptrRes := thisFrame.GetObjectPtr(opPtr[cs].var1)
			ptr1 := thisFrame.GetObjectPtr(opPtr[cs].var2)

			if IsFloat(objTyp)
			{
				switch objTyp.GetSize()
				{
					case 4 ptrRes->{float^}^ = sqrtf(ptr1->{float^}^)
					case 8 ptrRes->{double^}^ = sqrtf(ptr1->{double^}^) //TODO switch to base sqrt
				}
			}else{
				assert(false)
			}
			
		case "cos"
			objTyp := interpFunc.Objects[thisLine.var2].GetType()

			ptrRes := thisFrame.GetObjectPtr(opPtr[cs].var1)
			ptr1 := thisFrame.GetObjectPtr(opPtr[cs].var2)

			if IsFloat(objTyp)
			{
				switch objTyp.GetSize()
				{
					case 4 ptrRes->{float^}^ = cos(ptr1->{float^}^)
					case 8 ptrRes->{double^}^ = cos(ptr1->{double^}^)
				}
			}else{
				assert(false)
			}
		case "sin"
			objTyp := interpFunc.Objects[thisLine.var2].GetType()

			ptrRes := thisFrame.GetObjectPtr(opPtr[cs].var1)
			ptr1 := thisFrame.GetObjectPtr(opPtr[cs].var2)

			if IsFloat(objTyp)
			{
				switch objTyp.GetSize()
				{
					case 4 ptrRes->{float^}^ = sin(ptr1->{float^}^)
					case 8 ptrRes->{double^}^ = sin(ptr1->{double^}^)
				}
			}else{
				assert(false)
			}
		case "vec_build"
			objTyp := interpFunc.Objects[thisLine.var1].GetType()
			ptrRes := thisFrame.GetObjectPtr(opPtr[cs].var1)

			if objTyp == GTypeVec2f
			{
				ptr1 := thisFrame.GetObjectPtr(opPtr[cs].var2)
				ptr2 := thisFrame.GetObjectPtr(opPtr[cs].var3)
				
				ptrRes->{float^}[0] = ptr1->{float^}^
				ptrRes->{float^}[1] = ptr2->{float^}^

			}else if objTyp == GTypeVec4f {
				ptr1 := thisFrame.GetObjectPtr(opPtr[cs].var2)
				ptr2 := thisFrame.GetObjectPtr(opPtr[cs].var3)
				ptr3 := thisFrame.GetObjectPtr(opPtr[cs].var4)
				ptr4 := thisFrame.GetObjectPtr(opPtr[cs].var5)
				
				ptrRes->{float^}[0] = ptr1->{float^}^
				ptrRes->{float^}[1] = ptr2->{float^}^
				ptrRes->{float^}[2] = ptr3->{float^}^
				ptrRes->{float^}[3] = ptr4->{float^}^
			}else{
				printf("unknown vector build on %s\n",objTyp.GetBADStr().Str())
				exit(0)
			}

		case "vec_scalar_mul"
			objTyp := interpFunc.Objects[thisLine.var2].GetType()
			ptrRes := thisFrame.GetObjectPtr(opPtr[cs].var1)

			ptr1 := thisFrame.GetObjectPtr(opPtr[cs].var2)
			ptr2 := thisFrame.GetObjectPtr(opPtr[cs].var3)

			if objTyp == GTypeVec3f {
				ptrRes->{float^}^ = ptr1->{vec3f^}^ <+> ptr2->{vec3f^}^
			}else if objTyp == GTypeVec4f {
				ptrRes->{float^}^ = ptr1->{vec4f^}^ <+> ptr2->{vec4f^}^
			}else if objTyp == GTypeVec2f {
				ptrRes->{float^}^ = ptr1->{vec2f^}^ <+> ptr2->{vec2f^}^
			}else if objTyp == GTypeQuantf {
				ptrRes->{float^}^ = ptr1->{quantf^}^ <+> ptr2->{quantf^}^
			}else{
				printf("unknown vec_scalar_mul on %s\n",objTyp.GetBADStr().Str())
				exit(0)
			}
		case "vec_shuffle_begin"
			objTyp := interpFunc.Objects[thisLine.var2].GetType()
			vecDest := thisFrame.GetObjectPtr(opPtr[cs].var1)
			vecSource := thisFrame.GetObjectPtr(opPtr[cs].var2)

			//TODO non float base, maybe double

			cs += 1

			ind := 0

			while opPtr[cs].opcode != "vec_shuffle_end"
			{
				if opPtr[cs].opcode == "vec_shuffle_zero"
				{
					vecDest->{float^}[ind] = 0.0
				}else{
					thisInd := thisFrame.GetObjectPtr(opPtr[cs].var1)->{int^}^
					vecDest->{float^}[ind] = vecSource->{float^}[thisInd]
				}
				ind += 1
				cs += 1
			}
		case "vec_shuffle_end"
			
			
		case "memset"
			sizeType := interpFunc.Objects[thisLine.var3].GetType()

			ptr1 := thisFrame.GetObjectPtr(opPtr[cs].var1)
			ptr2 := thisFrame.GetObjectPtr(opPtr[cs].var2)
			ptr3 := thisFrame.GetObjectPtr(opPtr[cs].var3)

			assert(sizeType == GTypeInt)
			switch sizeType.GetSize()
			{
				case 4 memset(ptr1->{void^^}^,ptr2->{int^}^,ptr3->{int^}^)
				case 8 memset(ptr1->{void^^}^,ptr2->{int^}^,ptr3->{u64^}^)
			}
		case "va_start"

			if callerFrame != null
			{
				bs := callerFrame.cs - 1
				cPtr := callerFrame.func.Lines.GetPointer()
				oPtr := callerFrame.func.Objects.GetPointer()

				assert(cPtr[bs].opcode == "call_end")

				while cPtr[bs].opcode != "call_start"
					bs -= 1

				fTyp := oPtr[cPtr[bs].var2].GetType()
				if fTyp? is in TypePoint
					fTyp = fTyp.Base
				if fTyp? is TypeFunc
				{
					fT := fTyp->{TypeFunc^}
					assert(fT.IsVargs)

					argsCount := fT.Params.Size()
					indxs := HybridQueue.{int,20}

					bs += 1
					k := -1
					while cPtr[bs].opcode != "call_end"
					{
						k += 1
						bs += 1

						if k < argsCount
							continue
						indxs.Push(cPtr[bs - 1].var1)
					}

					if indxs.Size() != 0
					{
						ptr := thisFrame.AllocateOnStack(indxs.Size()*8)

						for ind,i : indxs
						{
							ptr->{u64^}[i] = callerFrame.GetObjectPtr(ind)->{u64^}^
						}
						lst := thisFrame.GetObjectPtr(opPtr[cs].var1)->{va_list^^}^

						if #OS() == "Linux"
						{
							lst.intOffset = 48
							lst.floatOffset = 176
							lst.stackArea = ptr->{u8^}
							lst.regArea = ptr->{u8^}
						}
						if #OS() == "Windows"
						{
							lst^ = ptr
						}
					}


				}else{
					assert(false)
				}

			}else{
				assert(false)
			}
		case "va_end"
		case "va_arg"
			assert(false)
		case "get_array_elem_ptr"
			varType := interpFunc.Objects[thisLine.var2].GetType()
			indType := interpFunc.Objects[thisLine.var3].GetType()

			assert(indType == GTypeInt)

			v2 := thisFrame.GetObjectPtr(thisLine.var2)
			v3 := thisFrame.GetObjectPtr(thisLine.var3)

			assert(varType is in TypePoint or varType == GTypeStr)


			setPtr := thisFrame.GetObjectPtr(thisLine.var1)
			setPtr->{void^^}^ = v2->{u8^^}^[v3->{int^}^ * varType.Base.GetSize()]&

		case "get_field_ptr"
			classType := interpFunc.Objects[thisLine.var2].GetType().Base
			indType := interpFunc.Objects[thisLine.var3].GetType()

			assert(indType == GTypeInt)

			v2 := thisFrame.GetObjectPtr(thisLine.var2)
			v3 := thisFrame.GetObjectPtr(thisLine.var3)

			assert(classType is in TypeClass)

			asClass := classType->{TypeClass^}.ToClass
			fld := asClass.GetFieldByIndexRaw(v3->{int^}^)

			setPtr := thisFrame.GetObjectPtr(thisLine.var1)
			setPtr->{u8^^}^ = v2->{u8^^}^[fld.MemOffset]&

		case "store"
			resType := interpFunc.Objects[thisLine.var2].GetType()
			v1 := thisFrame.GetObjectPtr(thisLine.var1)
			v2 := thisFrame.GetObjectPtr(thisLine.var2)

			switch resType.GetSize()
			{
			case 1 v1->{u8^^}^^ = v2->{u8^}^
			case 2 v1->{u16^^}^^ = v2->{u16^}^
			case 4 v1->{u32^^}^^ = v2->{u32^}^
			case 8 v1->{u64^^}^^ = v2->{u64^}^
			case 16 v1->{vec4f^^}^^ = v2->{vec4f^}^
			case void assert(false)
			}
		case "load"
			resType := interpFunc.Objects[thisLine.var1].GetType()
			v1 := thisFrame.GetObjectPtr(thisLine.var1)
			v2 := thisFrame.GetObjectPtr(thisLine.var2)

			switch resType.GetSize()
			{
			case 1 v1->{u8^}^ = v2->{u8^^}^^
			case 2 v1->{u16^}^ = v2->{u16^^}^^
			case 4 v1->{u32^}^ = v2->{u32^^}^^
			case 8 v1->{u64^}^ = v2->{u64^^}^^
			case 16 v1->{vec4f^}^ = v2->{vec4f^^}^^
			case void assert(false)
			}

		case "debug_set_file"
			ptr1 := thisFrame.GetObjectPtr(opPtr[cs].var1)
			thisFrame.DebugFileName = ptr1->{char^^}^
		case "debug_set_line"
			ptr1 := thisFrame.GetObjectPtr(opPtr[cs].var1)
			thisFrame.DebugFileLine = ptr1->{int^}^
		case "switch_start"

			valType := thisFrame.func.Objects[opPtr[cs].var1].GetType()

			switchValue := thisFrame.GetObjectPtr(opPtr[cs].var1)->{int^}^

			if valType is TypeEnum
			{
				valSize := valType.GetSize()
				if valSize == 2
					switchValue = switchValue and_b 0xFFFF
				if valSize == 1
					switchValue = switchValue and_b 0xFF
			}

			cs += 1

			while opPtr[cs].opcode != "switch_end"
			{
				objVal := thisFrame.GetObjectPtr(opPtr[cs].var1)->{int^}^

				if objVal == switchValue {
					cs = labelsPtr[opPtr[cs].var2]
					break
				}
				cs += 1
			}
		case "switch_end"
		case "assert"
			//TODO

		// case "stack_push"
		// 	valType := thisFrame.func.Objects[opPtr[cs].var1].GetType()
		// 	valPtr := thisFrame.GetObjectPtr(opPtr[cs].var1)
		//
		// 	value := s64
		//
		// 	if valType.GetSize() == 8
		// 	{
		// 		value = valPtr->{u64^}^
		//
		// 	}else if IsInt(valType) or valType is TypeEnum {
		// 		if IsUInt(valType) or valType is TypeEnum
		// 		{
		// 			switch valType.GetSize()
		// 			{
		// 				case 1 value = valPtr->{u8^}^
		// 				case 2 value = valPtr->{u16^}^
		// 				case 4 value = valPtr->{u32^}^
		// 			}
		// 		}else{
		// 			switch valType.GetSize()
		// 			{
		// 				case 1 value = valPtr->{s8^}^
		// 				case 2 value = valPtr->{s16^}^
		// 				case 4 value = valPtr->{s32^}^
		// 			}
		// 		}
		// 	} else if valType == GTypeFloat {
		// 		value&->{double^}^ = valPtr->{float^}^
		// 	}else {
		// 		assert(false)
		// 	}
		// 	thisFrame.StackPushInt(value)
		//
		// case "stack_pop"
		// 	valType := thisFrame.func.Objects[opPtr[cs].var1].GetType()
		// 	valPtr := thisFrame.GetObjectPtr(opPtr[cs].var1)
		//
		// 	value := thisFrame.StackGetPtr()->{s64^}^
		//
		// 	if valType.GetSize() == 8
		// 	{
		// 		valPtr->{u64^}^ = value
		// 	}else if IsInt(valType) or valType is TypeEnum {
		// 		switch valType.GetSize()
		// 		{
		// 			case 1 valPtr->{u8^}^ = value
		// 			case 2 valPtr->{u16^}^ = value
		// 			case 4 valPtr->{u32^}^ = value
		// 		}
		// 	} else if valType == GTypeFloat {
		// 		 valPtr->{float^}^ = value&->{double^}^
		// 	}else {
		// 		assert(false)
		// 	}
		// 	thisFrame.StackPop()
		//
		// case in ![
		// 		"stack_add_int","stack_sub_int",
		// 		"stack_smul_int","stack_umul_int",
		// 		"stack_sdiv_int","stack_udiv_int",
		// 		"stack_smod_int","stack_umod_int",
		// 	]
		// 	ptr := thisFrame.StackGetPtr()->{s64^}
		// 	switch thisLine.opcode
		// 	{
		// 	case "stack_add_int" ptr[1] = ptr[0] + ptr[1]
		// 	case "stack_sub_int" ptr[1] = ptr[0] - ptr[1]
		// 	case "stack_smul_int" ptr[1] = ptr[0] * ptr[1]
		// 	case "stack_umul_int" ptr[1] = ptr[0]->{u64} * ptr[1]->{u64}
		// 	case "stack_sdiv_int" ptr[1] = ptr[0] div ptr[1]
		// 	case "stack_udiv_int" ptr[1] = ptr[0]->{u64} div ptr[1]->{u64}
		// 	case "stack_smod_int" ptr[1] = ptr[0] mod ptr[1]
		// 	case "stack_umod_int" ptr[1] = ptr[0]->{u64} mod ptr[1]->{u64}
		// 	}
		// 	thisFrame.StackPop()

		case void
			printf("unknown opcode %s at %i\n",interpFunc.Lines[cs].opcode.ToCStr(),cs)
			assert(false)
		}
		cs += 1
	}
}
