MCInterpFunction := !(MCInterpContext^ iCntx,MCFunction^ interpFunc) -> void
{
	cs := 0
	thisFrame := MCInterpFuncFrame
	thisFrame.func = interpFunc

	opPtr := interpFunc.Lines.GetPointer()
	assert(opPtr != null)

	thisFrame.localVarBlob = new BlobOnVector(512) //TODO calculate stack size
	for it,i : interpFunc.Objects
	{
		if it& is MCVariable
		{
			thisFrame.localVarTable[i] = thisFrame.localVarBlob.GetPointer() //TODO hm
		}
	}

	opsCount := interpFunc.Lines.Size()
	while cs < opsCount
	{
		if opPtr[cs].opcode == "call_start"
		{
			fncObj := ref interpFunc.Objects[opPtr[cs].var1]
			cs += 1

			indxs := HybridQueue.{int,8}
			while opPtr[cs].opcode != "call_end"
			{
				if opPtr[cs].opcode == "load_var"
				{
					indxs.Push(opPtr[cs].var1)
				}else{
					assert(false)
				}
				cs += 1
			}
			cs += 1

			if fncObj& is MCConstFunction
			{
				fncHV := fncObj&->{MCConstFunction^}.GetValue()

				if fncHV is BoxFuncDeclare
				{
					fncType := fncHV.GetType()->{TypeFunc^}
					thisFrame.CallFuncPtr(fncType,iCntx.DeclareToPtr(fncHV->{BoxFuncDeclare^}),indxs,0)
				}else{
					assert(false)
				}
			}

		}else if opPtr[cs].opcode == "clean"{
			obj := interpFunc.Objects[opPtr[cs].var1]
			clnVar := thisFrame.GetObjectPtr(opPtr[cs].var1)
			assert(clnVar != null)

			memset(clnVar,0,obj.GetType().GetSize())
			cs += 1
		}else{
			printf("unknown opcode %s at %i\n",interpFunc.Lines[cs].opcode.ToCStr(),cs)
			cs += 1
		}
	}
}
