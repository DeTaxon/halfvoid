
MCInterpFunction2 := !(MCInterpContext^ iCntx,MCFunction^ interpFunc, void^[] inputs = null,void^ resultPtr = null) -> void
{
	fType := interpFunc.BaseFunction.GetType()->{TypeFunc^}

	isComplex := fType.ResultType.IsComplexReturn() and not fType.ResultRef

	if isComplex and resultPtr != null
	{
		vars2 := HybridQueue.{void^,120}
		vars2.Push(resultPtr)
		if inputs != null
		{
			for it : inputs
			{
				vars2.Push(it)
			}
		}
		MCInterpFunction(iCntx,interpFunc,vars2,null)
	}else{
		MCInterpFunction(iCntx,interpFunc,inputs,resultPtr)
	}

}

MCInterpFunction := !(MCInterpContext^ iCntx,MCFunction^ interpFunc, void^[] inputs = null,void^ resultPtr = null) -> void
{
	thisFrame := MCInterpFuncFrame
	
	retIndex := 0
	if resultPtr != null
	{
		retIndex = 1
		thisFrame.localVarTable[1] = resultPtr
	}
	inptsIndexes := HybridQueue.{int,10}
	if inputs != null
	{
		for it,i : inputs
		{
			c := i + 5
			inptsIndexes.Push(c)
			thisFrame.localVarTable[c] = it
		}
	}
	MCInterpFunction(iCntx,interpFunc,thisFrame&,inptsIndexes,retIndex)
}

MCInterpFunction := !(MCInterpContext^ iCntx,MCFunction^ interpFunc, MCInterpFuncFrame^ callerFrame = null, int[] callerIndx = null,int returnIndex = 0) -> void
{
	//interpFunc.Print()
	//exit(0)
	//
	cs := 0
	thisFrame := MCInterpFuncFrame
	thisFrame.func = interpFunc

	if interpFunc.Lines.Size() == 0
		return void

	opPtr := interpFunc.Lines.GetPointer()
	assert(opPtr != null)

	useStackSize := 0
	for it,i : interpFunc.Objects
	{
		typ := Type^
		if it& is MCVariable
			typ = it&->{MCVariable^}.GetType()
		if it& is MCReference
			typ = GTypeVoidP
		if typ != null
		{
			al := typ.GetAlign()
			if al != 0
			{
				useStackSize = ((useStackSize + al - 1) div al) * al
			}
			useStackSize += typ.GetSize()
		}
	}
	useStackSize = (useStackSize + 15) and_b 0xFFFFF0
	thisFrame.localVarBlob = MakeBlob(useStackSize)
	//memset(thisFrame.localVarBlob.GetPointer(),0,useStackSize)
	offset := int
	inpPos := 0
	for it,i : interpFunc.Objects
	{
		typ := Type^
		if it& is MCVariable
			typ = it&->{MCVariable^}.GetType()
		if it& is MCReference
			typ = GTypeVoidP

		if i != 0 and i == interpFunc.ResultIndex and callerFrame != null and returnIndex != 0
		{
			thisFrame.localVarTable[i] = callerFrame.localVarTable[returnIndex]
			continue
		}
		if callerIndx != null and i in Range(interpFunc.InputsIndxStart,interpFunc.InputsIndxStart + callerIndx.Size() - 1)
		{
			thisFrame.localVarTable[i] = callerFrame.localVarTable[callerIndx[inpPos]]
			inpPos += 1
			continue
		}
		if typ != null
		{
			al := typ.GetAlign()
			if al != 0
			{
				offset = ((offset + al - 1) div al) * al
			}
			if it& is MCVariable
			{
				thisFrame.localVarTable[i] = thisFrame.localVarBlob.GetPointer()->{u8^}[offset]&
			}
			if it& is MCReference
			{
				thisFrame.localVarTable[i] = thisFrame.localVarBlob.GetPointer()->{u8^}[offset]&
			}

			offset += typ.GetSize()
		}
	}
	
	labelsPos := Tuple.{u16,int}[]
	
	{
		labelsList := List.{Tuple.{u16,int}}
		for it,i : interpFunc.Lines
		{
			if it.opcode == "label"
			{
				labelsList.Emplace(it.var1,i)
			}
		}
		labelsPos = labelsList.ToVector()
	}
	getLabel := (u16 val) ==> [labelsPos&]{
		for it : labelsPos
		{
			if it.0 == val
				return it.1
		}
		printf("lost label %i\n",val)
		//interpFunc.Print()
		//for it : labelsPos
		//{
		//	printf("labels %i %i\n",it.0,it.1)
		//}
		assert(false)
	}

	opsCount := interpFunc.Lines.Size()
	while cs < opsCount
	{
		//printf("line %i\n",cs)
		thisLine := ref opPtr[cs]
		switch opPtr[cs].opcode
		{
		case "noop"
			cs += 1
		case "call_start"
			fncObj := ref interpFunc.Objects[opPtr[cs].var2]
			returnIndexCall := opPtr[cs].var1
			cs += 1


			indxs := HybridQueue.{int,8}
			while opPtr[cs].opcode != "call_end"
			{
				if opPtr[cs].opcode == "load_var"
				{
					indxs.Push(opPtr[cs].var1)
				}else{
					assert(false)
				}
				cs += 1
			}
			cs += 1

			resultPtr := thisFrame.GetObjectPtr(thisLine.var1)

			if fncObj& is MCConstFunction
			{
				fncHV := fncObj&->{MCConstFunction^}.GetValue()

				if fncHV is in BuildInVirtualCall
				{
					vTableIndx := 0
					fType := fncHV->{BuildInVirtualCall^}.wrappedFunc.GetType()->{TypeFunc^}

					if fType.ResultType.IsComplexReturn() and not fType.ResultRef
						vTableIndx = 1
			
					v1 := thisFrame.GetObjectPtr(indxs[vTableIndx])
					vTable := v1->{void^^^}^^

					vTblCls := fncHV->{BuildInVirtualCall^}.wrappedFunc->{BoxFuncBody^}.Params[0].GetType()->{TypeClass^}
					cls := vTblCls.ToClass.VTableType
					//globVar := iCntx.GetGlobalVarFromMem(vTable)
					//assert(globVar != null)
					//cls := globVar.GetType()->{TypeClass^}.ToClass
					memField := cls.GetFieldByIndex(fncHV->{BuildInVirtualCall^}.funcIndex)
					memOffset := memField.MemOffset

					memObj := vTable->{u8^}[memOffset]&->{BoxUnit^^}^
					
					if iCntx.vtableFunctions.Value.ContainSome(memObj)
					{
						mx := iCntx.vtableFunctions.Value.GetOne(memObj)

						assert(mx is in BoxFuncBody)

						fncAsMC := iCntx.GetMCFunc(mx)
						assert(fncAsMC != null)

						MCInterpFunction(iCntx,fncAsMC,thisFrame&,indxs,returnIndexCall)
					}else{
						fncType := memField.GetType()->{TypeFunc^}.ResultType.Base
						thisFrame.CallFuncPtr(fncType->{TypeFunc^},memObj,resultPtr,indxs,0)
					}

				}else if fncHV is BoxFuncDeclare {
					fncType := fncHV.GetType()->{TypeFunc^}
					thisFrame.CallFuncPtr(fncType,iCntx.DeclareToPtr(fncHV->{BoxFuncDeclare^}),resultPtr,indxs,0)
				}else if fncHV is in BoxFuncBody{
					fncAsMC := iCntx.GetMCFunc(fncHV->{BoxFuncBody^})
					MCInterpFunction(iCntx,fncAsMC,thisFrame&,indxs,returnIndexCall)
				}else{
					printf("failed to call, unknown class %s\n",fncHV.UnitName)
					assert(false)
				}
			} else if  fncObj& is MCVariable or fncObj& is MCReference{
				functionPointer := thisFrame.GetObjectPtr(thisLine.var2)->{void^^}^
				assert(functionPointer != null) //TODO emit error
				fncVal := iCntx.GetFuncByPointer(functionPointer)
				assert(fncVal != null)
				MCInterpFunction(iCntx,fncVal,thisFrame&,indxs,returnIndexCall)
			}else{
				assert(false)
			}

		case "clean"
			obj := interpFunc.Objects[opPtr[cs].var1]
			clnVar := thisFrame.GetObjectPtr(opPtr[cs].var1)
			assert(clnVar != null)

			memset(clnVar,0,obj.GetType().GetSize())
			cs += 1
		case "and"
			objTyp := interpFunc.Objects[thisLine.var2].GetType()

			ptrRes := thisFrame.GetObjectPtr(opPtr[cs].var1)
			ptr1 := thisFrame.GetObjectPtr(opPtr[cs].var2)
			ptr2 := thisFrame.GetObjectPtr(opPtr[cs].var3)

			switch objTyp.GetSize()
			{
				case 1 ptrRes->{s8^}^ = ptr1->{s8^}^ and_b ptr2->{s8^}^
				case 2 ptrRes->{s16^}^ = ptr1->{s16^}^ and_b ptr2->{s16^}^
				case 4 ptrRes->{s32^}^ = ptr1->{s32^}^ and_b ptr2->{s32^}^
				case 8 ptrRes->{s64^}^ = ptr1->{s64^}^ and_b ptr2->{s64^}^
			}
			cs += 1
		case "or"
			objTyp := interpFunc.Objects[thisLine.var2].GetType()

			ptrRes := thisFrame.GetObjectPtr(opPtr[cs].var1)
			ptr1 := thisFrame.GetObjectPtr(opPtr[cs].var2)
			ptr2 := thisFrame.GetObjectPtr(opPtr[cs].var3)

			switch objTyp.GetSize()
			{
				case 1 ptrRes->{s8^}^ = ptr1->{s8^}^ or_b ptr2->{s8^}^
				case 2 ptrRes->{s16^}^ = ptr1->{s16^}^ or_b ptr2->{s16^}^
				case 4 ptrRes->{s32^}^ = ptr1->{s32^}^ or_b ptr2->{s32^}^
				case 8 ptrRes->{s64^}^ = ptr1->{s64^}^ or_b ptr2->{s64^}^
			}

			cs += 1
		case "sshr"
			objTyp := interpFunc.Objects[thisLine.var2].GetType()

			ptrRes := thisFrame.GetObjectPtr(opPtr[cs].var1)
			ptr1 := thisFrame.GetObjectPtr(opPtr[cs].var2)
			ptr2 := thisFrame.GetObjectPtr(opPtr[cs].var3)

			switch objTyp.GetSize()
			{
				case 1 ptrRes->{s8^}^ = ptr1->{s8^}^ shr ptr2->{s8^}^
				case 2 ptrRes->{s16^}^ = ptr1->{s16^}^ shr ptr2->{s16^}^
				case 4 ptrRes->{s32^}^ = ptr1->{s32^}^ shr ptr2->{s32^}^
				case 8 ptrRes->{s64^}^ = ptr1->{s64^}^ shr ptr2->{s64^}^
			}

			cs += 1
		case "ushr"
			objTyp := interpFunc.Objects[thisLine.var2].GetType()

			ptrRes := thisFrame.GetObjectPtr(opPtr[cs].var1)
			ptr1 := thisFrame.GetObjectPtr(opPtr[cs].var2)
			ptr2 := thisFrame.GetObjectPtr(opPtr[cs].var3)

			switch objTyp.GetSize()
			{
				case 1 ptrRes->{s8^}^ = ptr1->{u8^}^ shr ptr2->{u8^}^
				case 2 ptrRes->{s16^}^ = ptr1->{u16^}^ shr ptr2->{u16^}^
				case 4 ptrRes->{s32^}^ = ptr1->{u32^}^ shr ptr2->{u32^}^
				case 8 ptrRes->{s64^}^ = ptr1->{u64^}^ shr ptr2->{u64^}^
			}

			cs += 1
		case "shl"
			objTyp := interpFunc.Objects[thisLine.var2].GetType()

			ptrRes := thisFrame.GetObjectPtr(opPtr[cs].var1)
			ptr1 := thisFrame.GetObjectPtr(opPtr[cs].var2)
			ptr2 := thisFrame.GetObjectPtr(opPtr[cs].var3)

			switch objTyp.GetSize()
			{
				case 1 ptrRes->{s8^}^ = ptr1->{s8^}^ shl ptr2->{s8^}^
				case 2 ptrRes->{s16^}^ = ptr1->{s16^}^ shl ptr2->{s16^}^
				case 4 ptrRes->{s32^}^ = ptr1->{s32^}^ shl ptr2->{s32^}^
				case 8 ptrRes->{s64^}^ = ptr1->{s64^}^ shl ptr2->{s64^}^
			}

			cs += 1
		case "not"
			objTyp := interpFunc.Objects[thisLine.var1].GetType()

			ptr1 := thisFrame.GetObjectPtr(opPtr[cs].var1)
			ptr2 := thisFrame.GetObjectPtr(opPtr[cs].var2)

			if objTyp == GTypeBool
			{
				ptr1->{bool^}^ = ptr2->{u8^}^ == 0
			}else{
				assert(false)
			}
			cs += 1
		case "add"
			objTyp := interpFunc.Objects[thisLine.var2].GetType()

			ptrRes := thisFrame.GetObjectPtr(opPtr[cs].var1)
			ptr1 := thisFrame.GetObjectPtr(opPtr[cs].var2)
			ptr2 := thisFrame.GetObjectPtr(opPtr[cs].var3)

			if IsInt(objTyp)
			{
				bigInt := s64

				switch objTyp.GetSize()
				{
					case 1 ptrRes->{s8^}^ = ptr1->{s8^}^ + ptr2->{s8^}^
					case 2 ptrRes->{s16^}^ = ptr1->{s16^}^ + ptr2->{s16^}^
					case 4 ptrRes->{s32^}^ = ptr1->{s32^}^ + ptr2->{s32^}^
					case 8 ptrRes->{s64^}^ = ptr1->{s64^}^ + ptr2->{s64^}^
				}
			}else{
				assert(false)
			}
			cs += 1
		case "sub"
			objTyp := interpFunc.Objects[thisLine.var2].GetType()

			ptrRes := thisFrame.GetObjectPtr(opPtr[cs].var1)
			ptr1 := thisFrame.GetObjectPtr(opPtr[cs].var2)
			ptr2 := thisFrame.GetObjectPtr(opPtr[cs].var3)

			if IsInt(objTyp)
			{
				bigInt := s64
				switch objTyp.GetSize()
				{
					case 1 ptrRes->{s8^}^ = ptr1->{s8^}^ - (ptr2->{s8^}^)
					case 2 ptrRes->{s16^}^ = ptr1->{s16^}^ - (ptr2->{s16^}^)
					case 4 ptrRes->{s32^}^ = ptr1->{s32^}^ - (ptr2->{s32^}^)
					case 8 ptrRes->{s64^}^ = ptr1->{s64^}^ - (ptr2->{s64^}^)
				}
			}else{
				assert(false)
			}
			cs += 1
		case "mul"
			objTyp := interpFunc.Objects[thisLine.var2].GetType()

			ptrRes := thisFrame.GetObjectPtr(opPtr[cs].var1)
			ptr1 := thisFrame.GetObjectPtr(opPtr[cs].var2)
			ptr2 := thisFrame.GetObjectPtr(opPtr[cs].var3)

			if IsInt(objTyp)
			{
				bigInt := s64
				switch objTyp.GetSize()
				{
					case 1 ptrRes->{s8^}^ = ptr1->{s8^}^ * (ptr2->{s8^}^)
					case 2 ptrRes->{s16^}^ = ptr1->{s16^}^ * (ptr2->{s16^}^)
					case 4 ptrRes->{s32^}^ = ptr1->{s32^}^ * (ptr2->{s32^}^)
					case 8 ptrRes->{s64^}^ = ptr1->{s64^}^ * (ptr2->{s64^}^)
				}
			}else{
				assert(false)
			}
			cs += 1
		case "div"
			objTyp := interpFunc.Objects[thisLine.var2].GetType()

			ptrRes := thisFrame.GetObjectPtr(opPtr[cs].var1)
			ptr1 := thisFrame.GetObjectPtr(opPtr[cs].var2)
			ptr2 := thisFrame.GetObjectPtr(opPtr[cs].var3)

			if IsInt(objTyp)
			{
				bigInt := s64
				switch objTyp.GetSize()
				{
					case 1 ptrRes->{s8^}^ = ptr1->{s8^}^ div (ptr2->{s8^}^)
					case 2 ptrRes->{s16^}^ = ptr1->{s16^}^ div (ptr2->{s16^}^)
					case 4 ptrRes->{s32^}^ = ptr1->{s32^}^ div (ptr2->{s32^}^)
					case 8 ptrRes->{s64^}^ = ptr1->{s64^}^ div (ptr2->{s64^}^)
				}
			}else{
				assert(false)
			}
			cs += 1
		case "mod"
			objTyp := interpFunc.Objects[thisLine.var2].GetType()

			ptrRes := thisFrame.GetObjectPtr(opPtr[cs].var1)
			ptr1 := thisFrame.GetObjectPtr(opPtr[cs].var2)
			ptr2 := thisFrame.GetObjectPtr(opPtr[cs].var3)

			if IsInt(objTyp)
			{
				bigInt := s64
				switch objTyp.GetSize()
				{
					case 1 ptrRes->{s8^}^ = ptr1->{s8^}^ mod (ptr2->{s8^}^)
					case 2 ptrRes->{s16^}^ = ptr1->{s16^}^ mod (ptr2->{s16^}^)
					case 4 ptrRes->{s32^}^ = ptr1->{s32^}^ mod (ptr2->{s32^}^)
					case 8 ptrRes->{s64^}^ = ptr1->{s64^}^ mod (ptr2->{s64^}^)
				}
			}else{
				assert(false)
			}
			cs += 1
		case "cmp"
			objTyp := interpFunc.Objects[thisLine.var3].GetType()
			ptr1 := thisFrame.GetObjectPtr(opPtr[cs].var3)
			ptr2 := thisFrame.GetObjectPtr(opPtr[cs].var4)
			resBool := thisFrame.GetObjectPtr(thisLine.var1)->{bool^}

			if IsInt(objTyp) or objTyp is in TypePoint
			{
				spc := s64

				if IsInt(objTyp)
				{
					switch objTyp.GetSize()
					{
						case 1 spc = ptr1->{s8^}^ - (ptr2->{s8^}^)
						case 2 spc = ptr1->{s16^}^ - (ptr2->{s16^}^)
						case 4 spc = ptr1->{s32^}^ - (ptr2->{s32^}^)
						case 8 spc = ptr1->{s64^}^ - (ptr2->{s64^}^)
					}
				}else if objTyp is in TypePoint
				{
					spc = ptr1->{size_t^^}^ <=> ptr2->{size_t^^}^
				}else{
					assert(false)
				}

				switch thisLine.V2Cond()
				{
					case "==" resBool^ = (spc == 0)
					case "!=" resBool^ = (spc != 0)
					case "<=" resBool^ = (spc <= 0)
					case "<" resBool^ = (spc < 0)
					case ">=" resBool^ = (spc >= 0)
					case ">" resBool^ = (spc > 0)
					case void
						assert(false)
				}
			}else{
				assert(false)
			}
			cs += 1
		case "label"
			cs += 1
		case "jmp"
			cs = getLabel(thisLine.var1)
		case "jmp_if_bool"
			boolVar := thisFrame.GetObjectPtr(thisLine.var2)->{u8^}
			if boolVar^ != 0
			{
				cs = getLabel(thisLine.var1)
			}else{
				cs += 1
			}
		case "mov"
			v1 := thisFrame.GetObjectPtr(thisLine.var1)
			v2 := thisFrame.GetObjectPtr(thisLine.var2)
			typeSize := interpFunc.Objects[thisLine.var1].GetType().GetSize()
			memcpy(v1,v2,typeSize)
			cs += 1
		case "cast"
			v1 := thisFrame.GetObjectPtr(thisLine.var1)
			v2 := thisFrame.GetObjectPtr(thisLine.var2)
			toType := interpFunc.Objects[thisLine.var1].GetType()
			fromType := interpFunc.Objects[thisLine.var2].GetType()
			typeSize := toType.GetSize()

			if IsInt(toType) and IsInt(fromType)
			{
				oldType := interpFunc.Objects[thisLine.var2].GetType()
				if typeSize > oldType.GetSize() and not IsUInt(toType)
				{
					memset(v1,0,typeSize)
					memcpy(v1,v2,min(typeSize,oldType.GetSize()) )
				}else{
					memset(v1,0,typeSize)
					memcpy(v1,v2,min(typeSize,oldType.GetSize()) )
				}
			}else if toType is in TypePoint or toType is in TypeArrayView
			{
				//memset(v1,0,typeSize)
				memcpy(v1,v2,typeSize)
			}else if IsFloat(toType) and IsInt(fromType)
			{
				val := s64
				memcpy(val&,v2,fromType.GetSize())
				if not IsUInt(fromType)
				{
					shift := (8 - fromType.GetSize()) * 8
					val = val shl shift
					val = val shr shift
				}
				switch toType
				{
				case GTypeFloat v1->{float^}^ = val
				case GTypeDouble v1->{double^}^ = val
				case void
					assert(false)
				}
			}else
			{
				printf("can not cast type %s to %s\n",fromType.GetBADStr().Str(),toType.GetBADStr().Str())
				assert(false)
			}
			//TODO float to int , and back
			//signed types sign extension
			cs += 1
		case "load_element"
			varType := interpFunc.Objects[thisLine.var2].GetType()
			indType := interpFunc.Objects[thisLine.var3].GetType()

			assert(indType == GTypeInt)

			v2 := thisFrame.GetObjectPtr(thisLine.var2)
			v3 := thisFrame.GetObjectPtr(thisLine.var3)


			if varType is in TypePoint
			{
				objSet := ref interpFunc.Objects[thisLine.var1]
				assert(objSet& is MCReference)
				setPtr := thisFrame.GetReferencePtr(thisLine.var1)
				setPtr->{void^^}^ = v2->{u8^^}^[v3->{int^}^ * varType.Base.GetSize()]&
			}else if varType is in TypeClass{
				asClass := varType->{TypeClass^}.ToClass
				fld := asClass.GetFieldByIndexRaw(v3->{int^}^)

				objSet := ref interpFunc.Objects[thisLine.var1]
				assert(objSet& is MCReference)
				setPtr := thisFrame.GetReferencePtr(thisLine.var1)
				setPtr->{u8^^}^ = v2->{u8^}[fld.MemOffset]&
			}else{
				assert(false)
			}

			cs += 1
		case "set_reference"
			v1 := thisFrame.GetReferencePtr(thisLine.var1)
			v2 := thisFrame.GetObjectPtr(thisLine.var2)
			v1->{void^^}^ = v2
			cs += 1
		case "get_pointer"
			res := thisFrame.GetObjectPtr(thisLine.var1)

			obj := ref interpFunc.Objects[thisLine.var2]
			if obj& is MCReference
			{
				res->{void^^}^ = thisFrame.localVarTable[thisLine.var2]->{void^^}^
			}else if obj& is MCVariable{
				res->{void^^}^ = thisFrame.localVarTable[thisLine.var2]
			}else if obj& is MCGlobalVariable {
				res->{void^^}^ = iCntx.GetGlobalVarMem(obj&->{MCGlobalVariable^}.GetValueObject())
			}else if obj& is MCConstInteger{
				res->{void^^}^ = obj&->{MCConstInteger^}.GetValue()&
			}else if obj& is MCConstFunction{
				frFunc := obj&->{MCConstFunction^}.GetValue()
				assert(frFunc is BoxFuncBody) //TODO to error?
				mcFunc := iCntx.GetMCFunc(frFunc->{BoxFuncBody^})
				assert(mcFunc != null)
				mcFuncPtr := iCntx.GetFunctionPointer(mcFunc)
				res->{void^^}^ = mcFuncPtr
			}else{
				assert(false)
			}
			cs += 1
		case void
			printf("unknown opcode %s at %i\n",interpFunc.Lines[cs].opcode.ToCStr(),cs)
			cs += 1
		}
	}
}
