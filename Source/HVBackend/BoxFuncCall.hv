AppendClass BoxFuncCall
{
	WriteMC := virtual !(MCBuildContext^ ctx) -> WriteMCResult
	{
		if callObj.IsMCInlined
		{
			result = callObj.WriteFuncCallMC(ctx,downs)
		}else{
			fncId := ctx.AddFuncConst(callObj)

			thisIndexes := HybridQueue.{int,16}

			fType := callObj.GetType()->{TypeFunc^}

			extraOffset := 0
			if fType.ResultType.IsComplexReturn()
				extraOffset += 1

			for it,i : downs
			{

				subObj := it.WriteMC(ctx)

				if i < extraOffset
					continue
				fInd := i - extraOffset

				isRef := false
				if fInd < fType.Params.Size()
					isRef = fType.Params[fInd].IsRef
				if isRef
				{
					varId := ctx.CreateVar(it.GetType().GetPoint())
					HVB_ins_get_pointer(ctx,varId,subObj.CreatedId)
					thisIndexes.Push(varId)
				}else{
					varId := ctx.CreateVar(it.GetType())
					HVB_ins_move(ctx,varId,subObj.CreatedId)
					thisIndexes.Push(varId)
				}
			}
			if ResultVar != null
			{
				ctx.AddLocalVar(ResultVar)
				ResultVar.WriteMC(ctx)
			}

			returnByInput := false
			resultId := 0
			if fType.ResultType != GTypeVoid //TODO ref
			{
				if fType.ResultType.IsComplexReturn()
				{
					returnByInput = true
					assert(ResultVar != null)
					resultId = ctx.CreateVar(fType.ResultType.GetPoint())
					HVB_ins_get_pointer(ctx,resultId,ctx.GetLocalVar(ResultVar))
				}else{
					resultId = ctx.CreateVar(fType.ResultType)
				}
			}
			result.CreatedId = resultId

			ctx.lines.Push(MCLine("call_start",resultId,fncId))
			for it, i  : thisIndexes
			{
				ctx.lines.Push(MCLine("load_var",it))
			}
			ctx.lines.Push(MCLine("call_end"))
		}
	}
}

AppendClass BoxFunc
{
	IsMCInlined := virtual false
	WriteFuncCallMC := virtual !(MCBuildContext^ ctx,BoxExeObj^[] indexes) -> WriteMCResult
	{
		assert(false)
	}
}
