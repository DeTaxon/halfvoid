AppendClass BoxFuncCall
{
	WriteMC := virtual !(MCBuildContext^ ctx) -> WriteMCResult
	{
		if callObj.IsMCInlined
		{
			result = callObj.WriteFuncCallMC(ctx,downs)
		}else{
			fncId := ctx.AddFuncConst(callObj)

			thisIndexes := HybridQueue.{int,16}

			fType := callObj.GetType()->{TypeFunc^}

			for it,i : downs
			{
				subObj := it.WriteMC(ctx)

				isRef := false
				if i < fType.Params.Size()
					isRef = fType.Params[i].IsRef
				if isRef
				{
					varId := ctx.CreateReference(it.GetType())
					HVB_ins_set_reference(ctx,varId,subObj.CreatedId)
					thisIndexes.Push(varId)
				}else{
					varId := ctx.CreateVar(it.GetType())
					HVB_ins_move(ctx,varId,subObj.CreatedId)
					thisIndexes.Push(varId)
				}
			}

			resultId := 0
			if fType.ResultType != GTypeVoid //TODO ref
			{
				resultId = ctx.CreateVar(fType.ResultType)
			}
			result.CreatedId = resultId

			ctx.lines.Push(MCLine("call_start",resultId,fncId))
			for it : thisIndexes
			{
				ctx.lines.Push(MCLine("load_var",it))
			}
			ctx.lines.Push(MCLine("call_end"))
		}
	}
}

AppendClass BoxFunc
{
	IsMCInlined := virtual false
	WriteFuncCallMC := virtual !(MCBuildContext^ ctx,BoxExeObj^[] indexes) -> WriteMCResult
	{
		assert(false)
	}
}
