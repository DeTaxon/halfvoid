
MCInterpFuncFrame := class
{
	func := MCFunction^
	iCntx := MCInterpContext^

	callerIndx := Vector.{int} 

	localVarBlob := u8^
	//localVarTable := AVLMap.{int,void^}
	localVarTable := void^^
	//localVarTableHolder := Vector.{void^}

	objs := MCObject^

	StackPointer := u8^
	RevStackState := u8^
	StackAllocated := int

	DebugFileName := char^
	DebugFileLine := int

	ParentFrame := MCInterpFuncFrame^

	cs := int

	CreateStack := !() -> void
	{
		stackSize := 0
		if #Var("GC")
		{
			stackSize = MainGC.GetTaskRootStackSize() //TODO unconst
			StackPointer = MainGC.GetTaskRoot()->{u8^}
		}else{
			stackSize = 8*1024*1024 //TODO unconst
			StackPointer = malloc(stackSize)->{u8^}
		}

		RevStackState = StackPointer[stackSize]&
	}
	DestroyStack := !() -> void
	{
		if #Var("GC")
		{
			MainGC.RemoveTaskRoot(StackPointer)
		}else{
			free(StackPointer)
		}
	}
	InheritStack := !(MCInterpFuncFrame^ inherStack) -> void
	{
		StackPointer = inherStack.StackPointer
		StackAllocated = inherStack.StackAllocated
		RevStackState = inherStack.RevStackState
	}

	AllocateOnStack := !(int allocSize) -> void^
	{
		allocSize = (allocSize + 15) and_b 0xFFFFF0
		result = StackPointer[StackAllocated]&
		StackAllocated += allocSize
	}

	CreateFrame := !(MCInterpContext^ setContext,MCFunction^ setFunction,int atLeastLocalVarCount = 0) -> void
	{
		func = setFunction
		iCntx = setContext

		assert(setFunction.Objects.Size() != 0)

		//localVarTableHolder.Resize(setFunction.Objects.Size())
		//localVarTable = localVarTableHolder.GetPointer()
		if setFunction.Objects.Size() != 0
		{
			allocCount := max(setFunction.Objects.Size(),atLeastLocalVarCount)
			//localVarTable = calloc(allocCount,size_t->TypeSize)->{void^^}
			localVarTable = AllocateOnStack(allocCount*size_t->TypeSize)->{void^^}
		}

		objs = func.Objects.GetPointer()
	}

	GetObjectPtr := !(int index) -> void^
	{
		return localVarTable[index]
	}
	GetObjectSize := !(int index) -> int
	{
		return func.ObjectsSizes[index]
	}
	GetReferencePtr := !(int index) -> void^
	{
		obj := ref objs[index]
		if obj& is MCReference
		{
			return localVarTable[index]
		}
		assert(false)
	}

	GetStringPtr := !(u16 index) -> char^
	{
		obj := ref objs[index]

		if obj& is MCConstString
		{
			return obj&->{MCConstString^}.GetValue()
		}else if obj& is MCVariable
		{
			return localVarTable[index]->{char^^}^
		}else{
			assert(false)
		}
	}
	GetInt := !(u16 index) -> int
	{
		obj := ref func.Objects[index]

		if obj& is MCConstInteger
		{
			return obj&->{MCConstInteger^}.GetValue()
		}else{
			return GetObjectPtr(index)->{int^}^
		}
	}
	GetS64 := !(u16 index) -> s64
	{
		obj := ref func.Objects[index]

		if obj& is MCConstS64
		{
			return obj&->{MCConstS64^}.GetValue()
		}else{
			return GetObjectPtr(index)->{s64^}^
		}
	}
	GetDouble := !(u16 index) -> double
	{
		obj := ref objs[index]

		if obj& is MCConstDouble
		{
			return obj&->{MCConstDouble^}.GetValue()
		}else{
			return GetObjectPtr(index)->{double^}^
		}
	}

	LoadS64 := !(u16 index) -> s64
	{
		tp := func.Objects[index].GetType()
		tpSize := GetObjectSize(index)
		ptr := GetObjectPtr(index)

		if IsUInt(tp) {
			switch tpSize
			{
			case 1 result = ptr->{u8^}^
			case 2 result = ptr->{u16^}^
			case 4 result = ptr->{u32^}^
			case 8 result = ptr->{u64^}^
			}
		}else{
			switch tpSize
			{
			case 1 result = ptr->{s8^}^
			case 2 result = ptr->{s16^}^
			case 4 result = ptr->{s32^}^
			case 8 result = ptr->{s64^}^
			}
		}
	}
	StoreS64 := !(u16 index,s64 value) -> void
	{
		ptr := GetObjectPtr(index)

		switch GetObjectSize(index)
		{
		case 1 ptr->{s8^}^ = value
		case 2 ptr->{s16^}^ = value
		case 4 ptr->{s32^}^ = value
		case 8 ptr->{s64^}^ = value
		}
	}
	LoadDouble := !(u16 index) -> double
	{
		ptr := GetObjectPtr(index)
		tpSize := GetObjectSize(index)

		switch tpSize
		{
		// case 2 result = ptr->{half^}^
		case 4 result = ptr->{float^}^
		case 8 result = ptr->{double^}^
		}
	}
	StoreDouble := !(u16 index, double value) -> void
	{
		ptr := GetObjectPtr(index)
		tpSize := GetObjectSize(index)

		switch tpSize
		{
		// case 2 ptr->{half^}^ = value
		case 4 ptr->{float^}^ = value
		case 8 ptr->{double^}^ = value
		}
	}
	LoadVec4f := !(u16 index) -> vec4f
	{
		tp := func.Objects[index].GetType()
		tpSize := tp.GetSize()

		ptr := GetObjectPtr(index)

		switch tpSize
		{
		case 8 result = ptr->{vec2f^}^.xyxy
		case 12 result = ptr->{vec3f^}^.xyzx
		case 16 result = ptr->{vec4f^}^.xyzw
		}
	}
	StoreVec4f := !(u16 index, vec4f value) -> void
	{
		tp := func.Objects[index].GetType()
		tpSize := tp.GetSize()

		ptr := GetObjectPtr(index)

		switch tpSize
		{
		case 8 ptr->{vec2f^}^ = value.xy
		case 12 ptr->{vec3f^}^ = value.xyz
		case 16 ptr->{vec4f^}^ = value.xyzw
		}
	}


	StackGetPtr := !() -> u8^
	{
		return RevStackState
	}
	StackPushInt := !(s64 value) -> void
	{
		RevStackState = RevStackState[-8]&
		RevStackState->{s64^}^ = value
	}
	StackPushFloat := !(double value) -> void
	{
		RevStackState = RevStackState[-8]&
		RevStackState->{double^}^ = value
	}
	StackPop := !() -> void
	{
		RevStackState = RevStackState[8]&
	}

	CallFuncPtr := !(TypeFunc^ fType,void^ fPointer,void^ resultValue,Vector.{int} indexes,int resultIndex) -> void
	{
		fType = NormalizeFuncType(fType)
		varsCount := fType.Params.Size()
		assert(varsCount <= 40) //TODO Unconst

		values := void^[40]
		valuesPtr := void^[40]
		valuesTypes := void^[40]

		resultType := ffi_type_pointer->{void^}

		if not fType.ResultRef and fType.ExtraResults.Size() == 0
		{
			if fType.ResultType == GTypeFloat
			{
				resultType = ffi_type_float
			}else if fType.ResultType == GTypeDouble {
				resultType = ffi_type_double
			}
		}

		for it,i : indexes
		{
			itType := func.Objects[it]&.GetType()
			if itType == GTypeChar.GetPoint() or itType == GTypeStr
			{
				values[i] = GetStringPtr(it)
				valuesPtr[i] = values[i]&
				valuesTypes[i] = ffi_type_pointer
			}else if itType is in  TypePoint
			{
				values[i] = GetObjectPtr(it)->{void^^}^
				valuesPtr[i] = values[i]&
				valuesTypes[i] = ffi_type_pointer
			}else if itType == GTypeDouble{
				values[i]&->{double^}^ = GetDouble(it)
				valuesPtr[i] = values[i]&
				valuesTypes[i] = ffi_type_double
			}else if itType == GTypeFloat{
				valuesPtr[i] = GetObjectPtr(it)->{void^}
				valuesTypes[i] = ffi_type_float
			}else if itType == GTypeInt or itType == GTypeTypeId  or itType is in TypeEnum{ // TODO check type size for enum
				values[i]&->{int^}^ = GetInt(it)
				valuesPtr[i] = values[i]&
				valuesTypes[i] = ffi_type_sint32
			}else if itType == GTypeU32{
				values[i]&->{int^}^ = GetInt(it)
				valuesPtr[i] = values[i]&
				valuesTypes[i] = ffi_type_uint32
			}else if itType == GTypeU64{
				values[i]&->{s64^}^ = GetS64(it)
				valuesPtr[i] = values[i]&
				valuesTypes[i] = ffi_type_uint64
			}else if itType == GTypeS64{
				values[i]&->{s64^}^ = GetS64(it)
				valuesPtr[i] = values[i]&
				valuesTypes[i] = ffi_type_sint64
			}else if itType == GTypeBool{
				valuesPtr[i] = GetObjectPtr(it)
				valuesTypes[i] = ffi_type_sint8
			}else if itType == GTypeU8{
				valuesPtr[i] = GetObjectPtr(it)
				valuesTypes[i] = ffi_type_uint8
			}else if itType == GTypeChar {
				valuesPtr[i] = GetObjectPtr(it)
				valuesTypes[i] = ffi_type_uint8
			}else{
				printf("unknown type %s\n",itType.GetBADStr().Str())
				assert(false)
			}
		}
		someCif := u8[256] //TODO get type size

		if fType.IsVargs
		{
			ffi_prep_cif_var(someCif[0]&,2, varsCount,indexes.Size(),resultType,valuesTypes[0]&)
		}else{
			ffi_prep_cif(someCif[0]&,2, varsCount,resultType,valuesTypes[0]&)
		}
		ffi_call(someCif[0]&,fPointer,resultValue,valuesPtr[0]&)
	}
}
