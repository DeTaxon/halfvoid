
CliWin := class extend WindowCli
{
	StatusList := List.{Str}
	HotloadList := List.{Str}
	ConsoleList := List.{Str}

	tabs := LayoutTabs^

	InitWindow := virtual !() -> GUIObject^
	{
		tabs = new  LayoutTabs(![
			new LayoutHorizontal(![
				new MultilineText(StatusList)
			]),
			new LayoutHorizontal(![
				new MultilineText(HotloadList)
			]),
			new LayoutHorizontal(![
				new MultilineText(ConsoleList)
			]),
		])
	
		return new FrameCli(tabs)
	}
	KeyPressed := virtual !(int keyChar) -> void
	{
		switch keyChar
		{
		case '\t'
			tabs.NextTab()
			Refresh()
		case 'q'
			cliQuit = true
			while cliWorks != 0
				TSleep(0.2)
			cliWin.Quit()
		case 'r'
			StartInterpreter()
		}
	}
}

runInProgress := bool

StartInterpreter := !() -> void
{
	if runInProgress
		return void
	runInProgress = true
	TSpawnTask(() ==> {
		@work 
		{
			toRun := intGetFunc("main")
			toRun.ParseBody()
			WaitForParsingObjects()

			CompileAndRunCode(toRun->{BoxFuncBody^})
		}
		runInProgress = false
	})
}

StreamOnLambda := class extend Stream
{
	readLambda := !(void^,s64)&->void
	writeLambda := !(void^,s64)&->void
	this := !(!(void^,s64)&-> void rl, !(void^,s64)&->void wl) -> void
	{
		readLambda = rl?.Capture()
		writeLambda = wl?.Capture()
	}
	Read := virtual !(void^ data, s64 sLen) -> void
	{
		readLambda?(data,sLen)
	}
	Write := virtual !(void^ data, s64 sLen) -> void
	{
		writeLambda?(data,sLen)
	}
}

cliWin := CliWin^
cliQuit := bool
cliWorks := int

EnterCliMode := !() -> int
{
	ExpectWorkers(16)

	cliWin = new CliWin

	HotloadStream& = new StreamOnLambda(null,(data,sLen) ==> {
		st := Str
		st->AsString = new String(data->{char^},sLen->{int})
		cliWin.HotloadList.Push(st)
		cliWin.Refresh()
	})
	HotloadStream& = new TextStream(HotloadStream&)

	TSpawnTask(() ==> {

		hotload := HotloadContext

		AsyncMonitorFolderNonStop(StringSpan("."),true,(changedFile) ==> {
			asFile := changedFile->{File^}

			flId := asFile.GetId()


			foundFile := BoxFile^
			for spc : CodeSpaces
			{
				for thisFile : spc.Files
				{
					fId := thisFile.file.GetId()
					if fId == flId
					{
						foundFile = thisFile
						break
					}
				}
				if foundFile != null
					break
			}
			if foundFile == null
			{
				HotloadStream << "Changed file " << changedFile.GetName() << " not found in list\n"
				return void
			}
			HotloadStream << "Changed file " << changedFile.GetName() <<" , reloading content\n"

			foundFile.ReloadFile(hotload&,asFile)

			while hotload.ReloadFunctions.Size() != 0 or hotload.ReloadClasses.Size() != 0
			{
				if hotload.ReloadClasses.Size() != 0
				{
					newClass := hotload.ReloadClasses.Pop()
					newClass.ReloadClass(hotload&)
				}else{
					newFunc := hotload.ReloadFunctions.Pop()
					newFunc.ReloadFunction(hotload&,null)
				}
			}

			hotload.FailedToCompile[^].Recompile()
			hotload.FailedToCompile.Destroy()

			WaitForParsingObjects()

			if WorkBag.works.Size() == 0
			{
				GInterpCntx.ReloadFunctions(hotload&)
				hotload.Reset()
			}else{
				for it : WorkBag.works
				{
					if it is not CWorkFuncCompile
						continue
					hotload.FailedToCompile.Push(it->{CWorkFuncCompile^}.itFunc)
				}
			}
		})
	})

	TSpawnTask(() ==> {
		CliParseMain()
	})

	StartStatusMonitor()

	cliWin.Run()
	exit(0) //TODO 

}

CliParseMain := !() -> void
{
	mainFuncName := "internalHVEntryPoint"

	WaitForParsingObjects()
	mainFunc := intGetFunc(mainFuncName)
	assert(mainFunc != null)
	assert(mainFunc is BoxFuncBody)
	mainFunc.ParseBody()
	
	WaitForParsingObjects()

	mainFunc.ForceOutputName("main")

	WaitForParsingObjects()

	TLSStep()

	while WorkBag.works.Size() != 0
	{
		WaitForParsingObjects()
		TSleep(0.01)
	}

	for it : CodeSpaces
	{
		for libs : it.Modules
			libs.CreateInitPart()
	}

	while WorkBag.works.Size() != 0
	{
		WaitForParsingObjects()
		TSleep(0.01)
	}

	CompileAndRunInit()

	conVar := intGetGlobalVar("Console")
	if conVar != null
	{
		conVar.NotifyUseAndWait()
		globVar := GInterpCntx.GetGlobalVarMem(conVar)

		newStream := Stream^
		newStream = new StreamOnLambda(null,(data,sLen) ==> {
			st := Str
			st->AsString = new String(data->{char^},sLen->{int})
			cliWin.ConsoleList.Push(st)
			cliWin.Refresh()
		})
		newStream = new TextStream(newStream)

		globVar->{Stream^^}^ = newStream
	}
}
