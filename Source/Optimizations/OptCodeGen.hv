OptCodeGenLLVM := !(LLVMWriteContext^ ctx) -> void
{
	//WriteCodeToStream(ctx)

	mainFunc := intGetFunc(mainFuncName)
	assert(mainFunc != null)

	CodeCheckCtx := MCInterpContext

	c := CollectFunctionsCtx(CodeCheckCtx&,mainFunc->{BoxFuncBody^})

	c.Workarounds()
	c.Collect()

	ctx.ClassIgnoresVTable = true

	PrintDebugMeta(ctx)
	PrintDeclares(ctx)

	for st : GlobalStrings
	{
		st.PrintCode(ctx)
	}
	c.UsedClasses[^].PrintAsType(ctx)
	c.WriteGlobals[^].PrintCodeVar(ctx)
	c.DeclareFunctions[^].PrintCode(ctx)
	c.WriteFunctions[^].PrintCode(ctx)

	CodeSpaces[^].Files[^].PrintCode(ctx)
	DummyFile?.PrintCode(ctx)

	c.UsedTypes[^].PrintMeta(ctx)


	for refObj,refInd : GRefTypes
	{
		if refInd in c.UsedTypes
			refObj.PrintMeta(ctx)
	}
	
	ctx.writeStream.Close()
	ctx.writeStream = null

	printf("end\n")

	exit(0)
}


CollectFunctionsCtx := class extend TGCObject
{
	WriteGlobals := List.{GlobalVar2^}
	WriteFunctions := List.{BoxFuncBody^}
	DeclareFunctions := List.{BoxFuncDeclare^}
	UsedClasses := List.{BoxClass^}

	UsedTypes := AVLSet.{Type^}
	
	iCtx := MCInterpContext^

	checkedClasses := AVLSet.{BoxClass^}
	checkClasses := HybridStack.{BoxClass^,20}

	checkedFunctions := AVLSet.{BoxFunc^}
	checkFunctions := HybridStack.{BoxFuncBody^,20}

	checkedGlobals := AVLSet.{GlobalVar2^}
	checkGlobals := HybridStack.{GlobalVar2^,20}

	this := !(MCInterpContext^ interpContext,BoxFuncBody^ mainFunc) -> void
	{
		iCtx = interpContext
	
		assert(mainFunc is in BoxFuncBody)
	
		checkFunction(mainFunc)
	}

	checkFunction := !(BoxFunc^ fnc) -> void
	{
		if fnc in checkedFunctions
			return void
		checkedFunctions.Insert(fnc)

		if fnc is in BoxFuncBody
		{
			checkFunctions.PushFront(fnc->{BoxFuncBody^})
		}else if fnc is BoxFuncDeclare
		{
			DeclareFunctions.Push(fnc->{BoxFuncDeclare^})
		}else if fnc is ResistFunc{
			checkFunction(fnc->{ResistFunc^}.base)
		}else if fnc is BuildInVirtualCall {
			checkFunction(fnc->{BuildInVirtualCall^}.wrappedFunc)
		}else {
			assert(false)
		}
		
	}
	checkType := !(Type^ tp) -> void
	{

		if tp == null
			return void

		UsedTypes.Insert(tp)
		while tp.Base != null
		{
			if tp is TypeArrayView
				checkType(tp->{TypeArrayView^}.viewClassType)
			tp = tp.Base
			UsedTypes.Insert(tp)
		}

		if tp is TypeClass
		{
			cls := tp->{TypeClass^}.ToClass

			if cls not in checkedClasses
			{
				checkedClasses.Insert(cls)
				checkClasses.PushFront(cls)

				for cnst : cls.Constants?.Constants
				{
					checkConstant(cnst)
				}
			}
		}

		if tp is TypeFunc
		{
			fType := tp->{TypeFunc^}

			checkType(fType.Params[^].ItType)
			checkType(fType.ResultType)
		}
	}
	checkConstant := !(BoxExeConstObj^ cnst) -> void
	{
		if cnst is in Type
		{
			checkType(cnst->{Type^})
			return void
		}

	}
	checkGlobal := !(GlobalVar2^ glb) -> void
	{
		if glb in checkedGlobals
			return void

		checkType(glb.GetType())
		checkedGlobals.Insert(glb)
		checkGlobals.PushFront(glb)
	}

	Collect := !() -> void
	{
		while checkFunctions.Size() != 0 or checkClasses.Size() != 0 or checkGlobals.Size() != 0
		{
			if checkFunctions.Size() != 0
			{
				fnc := checkFunctions.Pop()
				mcFnc := iCtx.GetMCFunc(fnc)

				checkType(fnc.GetType())

				assert(mcFnc != null)

				WriteFunctions.Push(fnc)

				for it : mcFnc.Objects
				{
					switch it is
					{
					case MCVariable
						checkType(it.GetType())
					case MCReference
						checkType(it.GetType())
					case MCGlobalVariable
						checkGlobal(it.GetValueObject())
					case MCConstFunction
						checkFunction(it.GetValue())
					}
				}
			}
			if checkClasses.Size() != 0
			{
				cls := checkClasses.Pop()

				assert(cls != null)

				checkType(cls.VTableType?.ItType)
				checkType(cls.Fields[^].Value)
				checkType(cls.Parents[^].ItType)
				checkGlobal(cls.VTableValue?)


				for it : cls.VTable
				{
					if it is VTableVar
					{
						cnst := it->{VTableVar^}.ItConst

						if cnst is CheckInfoConst
						{
							checkGlobal(cnst->{CheckInfoConst^}.ItGlobVar)
						}
					}else if it is VTableFunc
					{
						checkFunction(it->{VTableFunc^}.Value)
					}else {
					}
				}

				UsedClasses.Push(cls)
			}
			if checkGlobals.Size() != 0
			{
				glb := checkGlobals.Pop()
				checkConstant(glb.value?)
				WriteGlobals.Push(glb)
			}
		}

		sortClasses()
	}
	
	sortClasses := !() -> void
	{
		classesList := AVLMap.{int,List.{BoxClass^}}

		for it : UsedClasses
		{
			d := getDepth(it)
			classesList[d].Push(it)
		}
		UsedClasses.Destroy()
		UsedClasses.Push(classesList[^][^])
	}
	getDepth := !(BoxClass^ cls) -> int
	{
		val := 0
		if cls.VTableType != null
			val = 1
		val = max(val,getDepth(cls.Parents[^]))
		return val + 1
	}

	Workarounds := !() -> void
	{
		ms := BoxUnit^
		for spc : CodeSpaced
		{
			for md : cps.Modules
			{
				ms = md.GetItem("memset")?
			}
		}
		if ms? is in BoxFunc
		{
			checkFunction(ms->{BoxFunc^})
		}
	}
}
