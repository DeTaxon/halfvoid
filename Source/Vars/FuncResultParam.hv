FuncResultParam := class extend ParamFunc
{
	CreatedVarCalls := List.{ParamLoadObj^}

	this := !(Type^ tp,bool isRef2) -> void
	{
		assert(CurrentFunc != null)
		parentFunc = CurrentFunc
		SetType(GetFuncType(0,null,null,tp,isRef2,false))
	}
	this := !(BoxExeObj^ obj) -> void
	{
		exeObj = obj
		this."FuncResultParam.this"(obj.GetType(),obj.IsMem())
	}
	IsMem := virtual !() -> bool
	{
		return GetType()->{TypeFunc^}.ResultRef
	}
	PrintCode := virtual !(LLVMWriteContext^ ctx) -> void
	{
		exeObj.PrintDefaultUse(ctx)
	}
	PrintResultObj := virtual !(LLVMWriteContext^ ctx, int resId, int debId) -> void
	{
		if exeObj.IsMem()
		{
			exeObj.PrintPointUse(ctx)
		}else{
			exeObj.PrintUse(ctx)
		}
	}
	PrintFuncCall := virtual !(LLVMWriteContext^ ctx,int resId,int debId,ExeDownList lst) -> void
	{
	}

	PopulateCalls := virtual !() -> void
	{
	}
	CreateCall := virtual !(CheckExeDownList objs) -> BoxExeObj^
	{
		return new BoxFuncCall(this&,objs)
	}
}
FuncResultParam2 := class extend FuncResultParam
{
	fallbackVar := LocalVar^

	this := !(Type^ tp,bool isRef2) -> void
	{
		assert(CurrentFunc != null)
		parentFunc = CurrentFunc
		SetType(GetFuncType(0,null,null,tp,isRef2,false))
	}
	this := !(BoxExeObj^ obj) -> void
	{
		exeObj = obj
		this."FuncResultParam.this"(obj.GetType(),obj.IsMem())
	}
	NotifyMemUse := virtual !() -> void
	{
		assert(exeObj != null)
		if exeObj.IsMem()
			return void
		makeBackupVar()
	}

	someoneOnMake := bool
	onMake := THatch

	makeBackupVar := !() -> void
	{
		assert(parentFunc.body != null)

		if someoneOnMake
		{
			onMake.Await()
			return void
		}else{
			someoneOnMake = true
		}
		defer onMake.Emit()

		refPath := exeObj.IsMem()

		varType := exeObj.GetType()
		if refPath
			varType = varType.GetPoint()

		fallbackVar = new LocalVar(StringSpan("anon"),varType,true,refPath)
		parentFunc.LocalVars.Push(fallbackVar)

		dwns := CheckExeDownList
		dwns.Push(fallbackVar.proxy&)

		if refPath
		{
			dwns.Push(new UnrefFuncCall(exeObj))
		}else{
			dwns.Push(exeObj)
		}

		setVar := CreateFuncCall(StringSpan("="),dwns)
		assert(setVar != null)
		fallbackVar.extraWork.Push(setVar)

		for it : CreatedVarCalls
		{
			it.CallObj = fallbackVar.CreateVarCall()
		}
		CreatedVarCalls.Destroy()

		if refPath
		{
			this&->SetType(FuncResultParam2OnMemRef)
		}else{
			this&->SetType(FuncResultParam2OnMem)
		}
	}
	NotifyCaptureUse := virtual !() -> void
	{
		makeBackupVar()
	}
	IsMem := virtual !() -> bool
	{
		return GetType()->{TypeFunc^}.ResultRef
	}
	PrintCode := virtual !(LLVMWriteContext^ ctx) -> void
	{
		exeObj.PrintDefaultUse(ctx)
	}
	PrintResultObj := virtual !(LLVMWriteContext^ ctx, int resId, int debId) -> void
	{
		if exeObj.IsMem()
		{
			exeObj.PrintPointUse(ctx)
		}else{
			exeObj.PrintUse(ctx)
		}
	}
	PrintFuncCall := virtual !(LLVMWriteContext^ ctx,int resId,int debId,ExeDownList lst) -> void
	{
	}

	populated := bool
	CreatedVarCalls := List.{ParamLoadObj^}
	CreateCall := virtual !(CheckExeDownList objs) -> BoxExeObj^
	{
		assert(not populated)
		res := new ParamLoadObj(this&)
		CreatedVarCalls.Push(res)
		return res
	}
	PopulateCalls := virtual !() -> void
	{
		populated = true
		for it : CreatedVarCalls
		{
			it.CallObj = new BoxFuncCall(this&)
		}
	}
}
FuncResultParam2OnMem := class extend FuncResultParam2
{
	NotifyMemUse := virtual !() -> void
	{
	}
	PrintCode := virtual !(LLVMWriteContext^ ctx) -> void
	{
		fallbackVar.PrintCode(ctx)
	}
	CreateCall := virtual !(CheckExeDownList objs) -> BoxExeObj^
	{
		assert(CreatedVarCalls.Size() == 0)
		return fallbackVar.CreateVarCall()
	}
	PopulateCalls := virtual !() -> void
	{
	}
}
FuncResultParam2OnMemRef := class extend FuncResultParam2
{
	NotifyMemUse := virtual !() -> void
	{
	}
	PrintCode := virtual !(LLVMWriteContext^ ctx) -> void
	{
		fallbackVar.PrintCode(ctx)
	}
	CreateCall := virtual !(CheckExeDownList objs) -> BoxExeObj^
	{
		assert(CreatedVarCalls.Size() == 0)
		return fallbackVar.CreateVarCall()
	}
	PopulateCalls := virtual !() -> void
	{
	}
}
