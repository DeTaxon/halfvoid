TryGetContinueBreak := !(Token^ itm) -> BoxExeObj^
{
	if itm.GetValue() == "continue"
	{
		return new BoxContinue(itm)
	}
	if itm.GetValue() == "break"
	{
		return new BoxBreak(itm)
	}
	return null
}

BoxContinue := class extend BoxExeObj
{
	goLabel := BoxLabel^
	exitCall := BoxExeObj^
	this := !(Token^ itm) -> void
	{
		for it : UnitStack
		{
			if it is in BoxBlockContinue
			{
				block := it->{BoxBlock^}
				goLabel = block.GetQuitLabel()
				exitCall = block.CreateGCClear()
				break
			}
		}
		if goLabel == null
			itm.EmitError("continue operator used without cycle")
	}
	PrintDefaultUse := virtual !(LLVMWriteContext^ ctx) -> void
	{
		exitCall?.PrintDefaultUse(ctx)
		goLabel.PrintGo(ctx)
	}
}

BoxBreak := class extend BoxExeObj
{
	goLabel := BoxLabel^
	exitCall := BoxExeObj^
	this := !(Token^ itm) -> void
	{
		for it : UnitStack
		{
			if it is in BoxBlockBreak
			{
				block := it->{BoxBlock^}
				goLabel = block.GetQuitLabel()
				exitCall = block.CreateGCClear()
				break
			}
		}
		if goLabel == null
			itm.EmitError("break operator used without cycle")
	}
	PrintDefaultUse := virtual !(LLVMWriteContext^ ctx) -> void
	{
		exitCall?.PrintDefaultUse(ctx)
		goLabel.PrintGo(ctx)
	}
}
