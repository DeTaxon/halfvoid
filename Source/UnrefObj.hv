TryGetUnrefObj := !(Token^ itm) -> BoxExeObj^
{
	if itm == null return null
	if itm.Down == null return null
	if itm.Down.Right == null return null
	if itm.Down.Right.Right != null return null
	if itm.Down.Right.GetValue() != "&" return null

	dwn := TryGetExeCall(itm.Down)

	if dwn == null
		itm.EmitError("can not get pointer to error object")
	dwn.NotifyMemUse()
	if not dwn.IsMem()
		itm.EmitError("can not get pointer to object, it is not on the memory")
	
	if dwn is in PtrToRef
		return dwn->{PtrToRef^}.Down

	return new UnrefFuncCall(dwn)
}
TryGetPtrObj := !(Token^ itm) -> BoxExeObj^
{
	if itm == null return null
	if itm.Down == null return null
	if itm.Down.Right == null return null
	if itm.Down.Right.Right != null return null
	if itm.Down.Right.GetValue() != "^" return null

	dwn := TryGetExeCall(itm.Down)

	assert(dwn != null)
	if dwn == null
		itm.EmitError("can not dereference object")

	if dwn.GetType() is in TypePoint
		return new PtrToRef(dwn)
}

UnrefFuncCall := class extend BoxExeObj
{
	Down := BoxExeObj^
	this := !(BoxExeObj^ obj) -> void
	{
		Down = obj
		ObjType = Down.GetType().GetPoint()
		obj.NotifyMemUse()
	}
	IsMem := virtual !() -> bool
	{
		return false
	}
	PrintPre := virtual !(LLVMWriteContext^ ctx) -> void
	{
		Down.PrintPointPre(ctx)
	}
	PrintUse := virtual !(LLVMWriteContext^ ctx) -> void
	{
		Down.PrintPointUse(ctx)
	}
}

PrintUnrefObj := !(LLVMWriteContext^ ctx,int id,BoxExeObj^ obj) -> void
{
	f := ctx.writeStream
	rType := NormalizeType(obj.GetType())

	obj.PrintPointPre(ctx)
	f^ << "%TUnref" << id << " = load "
	rType.PrintType(ctx)
	f^ << ","
	rType.PrintType(ctx)
	f^ << "* "
	obj.PrintPointUse(ctx)
	if DebugMode
		f^ << ", !dgb !" << GDebugLineCallId
	f^ << "\n"
}

GetElementRetrive := !(BoxExeObj^ hm, BoxExeObj^ ind) -> BoxExeObj^
{
	objs := CheckExeDownList
	objs.Push(hm)
	objs.Push(ind)
	return CreateFuncCall(StringSpan("[]"),objs)
}
