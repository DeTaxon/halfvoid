
ParseType := !(Object^ Node) -> Type^
{
	return ParseType(Node,null,null,null)
}
ParseType := !(Object^ Node,AttrArrayType^ toAdd) -> Type^
{
	return ParseType(Node,toAdd,null,null)
}
ParseType := !(Object^ Node,AttrArrayType^ toAdd,Queue.{ObjConstHolder^}^ tempConsts) -> Type^
{
	return ParseType(Node,toAdd,tempConsts,null)
}
ParseType := !(Object^ Node,AttrArrayType^ toAdd,Queue.{ObjConstHolder^}^ tempConsts,AVLMap.{char^,Type^}^ extrTypes) -> Type^ 
{
	if Node == null return null
	if Node.GetValue() == "~d" and Node.Down?.GetValue() == "#best"
	{
		srNode := Node.Down.Right
		bestType := Type^()

		for itr : srNode.Down
		{
			if itr.GetValue() == ","
				continue
			sType := ParseType(itr,toAdd,tempConsts,extrTypes)
			if sType == null
			{
				if itr is ObjIndent
				{
					asInd := itr->{ObjIndent^}

					if extrTypes?.Contain(asInd.MyStr)
					{
						if bestType == null
						{
							bestType = extrTypes^[asInd.MyStr]
						}else{
							bestType = TypeFight(bestType,extrTypes^[asInd.MyStr])
						}
						if bestType == null
							return null
					}else{
						toUp := Node.Up
						while toUp != null
						{
							if toUp is BoxFuncBody break
							toUp = toUp.Up
						}
						if toUp == null return null
						asBody := toUp->{BoxFuncBody^}
						if asBody.vargsName != asInd.MyStr return null
						fType := asBody.MyFuncType
						ii := asBody.funcUserParamsCount
						while ii < fType.ParsCount
						{
							if bestType == null
							{
								bestType = fType.Pars[ii]
							}else{
								bestType = TypeFight(bestType,fType.Pars[ii])
							}
							if bestType == null
							{
								return null
							}
							ii++
						}
					}
				}else{
					return null
				}
			}else{
				if bestType == null
				{
					bestType = sType
				}else{
					bestType = TypeFight(bestType,sType)
				}
				if bestType == null
					return null
			}
		}
		return bestType
	}
	if Node is ObjIndent
	{
		indName := (Node->{ObjIndent^}).MyStr
		
		NodeName := GetItem(indName,Node)
		
		if tempConsts != null
		{
			if tempConsts^[^].ItName == NodeName and it.Down? is ObjType
			{
				return it.Down->{ObjType^}.MyType
			}
		}

		if NodeName == null {
			for Modules
			{
				tryType := it.GetModuleType(indName)
				if tryType != null return tryType
			}
			for itCodeS : CodeSpaces ; $reverse
			{
				inMMap := itCodeS.codeTypeDefs.TryFind(indName)
				if inMMap != null
				{
					return inMMap^.GetType()
				}
			}
			return null
		}
		//NodeName.GetValue()
		if NodeName.GetValue() == ":=type"
		{
			return NodeName.GetType()
		}
		if NodeName.Down? is BoxClass
		{
			asCl := ((NodeName.Down)->{BoxClass^})
			return asCl.ClassType
		}
		if NodeName is ObjType
		{	
			asNeed := NodeName->{ObjType^}
			return asNeed.MyType
		}
		return null
	}
	if Node.GetValue() == "~type"
	{
		asNeed := Node->{ObjType^}
		return asNeed.MyType
	}
	if Node.GetValue() == "~d"
	{
		if Node.Down?.GetValue() == "!" and Node.Down.Right?.GetValue() in !["{}","{d}"]
		{
			itBox := @temp new FuncInputBox
			for nd : Node.Down.Right.Down
			{
				if nd.GetValue() == ","
					continue
				newTyp := ParseType(nd)
				if newTyp == null
					return null
				itBox.itPars.Emplace(newTyp,false)
			}
			if itBox.itPars.Size() == 0
				return null
			return GetTuple(itBox).ClassType
		}
		lazy := false
		while true
		{
			itr2 := Node.Down
			if itr2 == null break
			if itr2.GetValue() != "!" break
			itr2 = itr2.Right
			if itr2.GetValue() != "()"  break
			itr2 = itr2.Right
			lazy = itr2.GetValue() == "^"  or itr2.GetValue() == "&"
			break
		}
		if lazy
		{
			types := Queue.{Type^}() ; $temp
			refs := List.{bool}() ; $temp
			isVARR := false
			isLambda := false
			ptrSize := 0

			SyntaxCompress(Node.Down.Right,LexHVInputVars)
			UnboxParams(Node.Down.Right)

			iter := Node.Down.Right.Down

			metCommaIn := 0
			while iter != null
			{
				if iter.GetValue() != ","
				{
					switch metCommaIn
					{
					case 0
						if iter.GetValue() == "..."
						{
							isVARR = true
						}else{
							someType := Type^()
							isRefParam := false
							if iter.Down?.Right?.GetValue() == "&"
							{
								someType = ParseType(iter.Down)
								isRefParam = true
							}else{
								someType = ParseType(iter)
							}
							if someType == null
								return null
							if not isRefParam isRefParam = IsComplexType(someType)
							types.Push(someType)
							refs.Push(isRefParam)
						}
					case 1
						if not (iter is ObjIndent)
							return null
					case 2
						return null
					}

					metCommaIn += 1
				}else{
					metCommaIn = 0
				}
				iter = iter.Right 
			}
			iter = Node.Down.Right.Right
			while iter.GetValue() == "^"
			{
				ptrSize += 1
				iter = iter.Right
			}
			if iter.GetValue() == "&"
			{
				isLambda = true
				iter = iter.Right
			}

			iter = iter.Right
			someTypeRet := ParseType(iter)
			if someTypeRet == null return null

			if isLambda 
			{
				types.PushFront(GTypeVoidP)
				refs.PushFront(false)
				someTypeOut := GetFuncType(types,refs.ToArray(),someTypeRet,false,isVARR)
				asN := someTypeOut->{TypeFunc^}
				return asN.GetLambda()
			}

			someTypeOut := GetFuncType(types,refs.ToArray(),someTypeRet,false,isVARR)->{Type^}
			for ptrSize someTypeOut = someTypeOut.GetPoint()
			return someTypeOut
		}
		
		if Node.Down.GetValue() == "~ind" and Node.Down.Right?.GetValue() == "." and Node.Down.Right.Right?.GetValue() == "{}"
		{
			SyntaxCompress(Node.Down.Right.Right,PriorityData)
			itName := ((Node.Down)->{ObjIndent^}).MyStr

			if itName == "Tuple"
			{
				itms  := @temp new FuncInputBox
				if Node.Down.Right.Right.Down[^].GetValue() != ","
				{
					isType := ParseType(it)
					if isType == null
					{
						return null
					}else{
						itms.itPars.Emplace(isType,false)
						
					}
				}
				asCt :=  GetTuple(itms)
				if asCt == null
					return null
				return asCt.ClassType
			}

			box := @temp new FuncInputBox
			
			iterR := Node.Down.Right.Right.Down
			
			while iterR != null
			{	
				if iterR.GetValue() != ","
				{
					isType := ParseType(iterR)
					if isType == null
					{
						val := TryCompute(iterR)
						if val != null box.itConsts.Push(val.Clone()) //TODO: maybe not clone
						else 
						{
							if iterR is ObjIndent
							{
								itN := iterR->{ObjIndent^}.MyStr
								itmF := GetItem(itN,iterR)
								if itmF != null
								if itmF? is ObjParam and itmF.Down.GetValue() == "!{}{...}"
								{
									box.itConsts.Push(new ObjClassTemplatePointer(itmF.Down->{BoxClassTemplate^}))
								}else
								{
									return null
								}
							}else
							{
								//Node.EmitError("can not create class\n")
								return null
							}
						}
					}else{
						box.itConsts.Push(new ObjType(isType))
					}
				}
				iterR = iterR.Right
			}
			if box.itConsts.Size() == 0 return null

			if toAdd != null
			{
				for v3,k3 : toAdd^
				{
					box.itAttrs[k3] = v3
				}
			}

			if Node.Line != null
			for value,key : Node.Line.itAttrs
			{
				if key[0] == '#'
				{
					switch key
					{
						case "#outer_class"
							itrC := GetUpClass(Node)
							if itrC != null
							{
								for v2,k2 : itrC.ItAttrs
								{
									box.itAttrs[k2] = v2
								}
							}
						case void
					}
				}else{
					box.itAttrs[key] = value
				}
			}

			for cSpace : CodeSpaces ; $reverse
			{
				inInf := cSpace.codeTemplateTypedefs.TryFind(itName)
				if inInf != null
				{
					for itDefs : inInf^
					{
						itTyp := itDefs.TryGetType(box^)
						if itTyp != null return itTyp
					}
				}
			}

			NodeName := GetItem(itName,Node)

			if NodeName == null return null
			if NodeName.Down?.GetValue() == "!{}{...}"
			{
				asT := ((NodeName.Down)->{BoxClassTemplate^})


				return asT.GetClass(box^)
			}
			return null
		}



		if true
		{
			if not InDataR(Node.Down) return null
			Ri := Node.Down.Right
			if Ri == null return ParseType(Node.Down)
			
			under := ParseType(Node.Down)
			if under == null return null

			if Ri.GetValue() == "^"
			{
				return under.GetPoint()
			}
			if Ri.GetValue() == "[]"
			{
				if Ri.Down == null
				{
					return under.GetFatArray()
				}else
				{
					val := Object^()
					//if Ri.Down.GetValue() == "~ind"
					//{
					//	asNeed := ((Ri.Down)->{ObjIndent^})
					//	for i : nams.Size() 
					//		if nams[i] == asNeed.MyStr[1]& 
					//			val = vals[i]
					//}
					if val == null val = TryCompute(Ri.Down)
					if val == null return null
					if val.GetValue() == "~int"
					{
						DynCast := val->{ObjInt^}
						ArrSize := DynCast.MyInt
						return under.GetArray(ArrSize)->{Type^}
					}
				}

				return null
			}
		}


	}
	return null
}
