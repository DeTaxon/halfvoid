TypeClass := class extend Type
{
	ToClass := BoxClass^
	this := !(BoxClass^ ToSet) -> void
	{
		ItHash = ToSet.ClassId
		ToClass = ToSet
		ItName = GetNewName()
		metaId = ToSet.ClassId
	}
	GetType := virtual !() -> string
	{
		return "class"
	}
	GetNewName := virtual !() -> string
	{
		preRes := "%Class"sbt + ToClass.ClassId
		return preRes.Str()
	}
	GetGoodName := virtual !() -> string { 
		st := ""sbt + ToClass.ClassName 
		if ToClass.ItConsts.Size() != 0
		{
			st << ".{"
			for it,i : ToClass.ItConsts
			{
				if i != 0 st << ","
				st << it.GetConstValue()
			}
			st << "}"
		}
		if ToClass.ItAttrs.Size() != 0
		{
			st << " attrs: "
			for it,ind : ToClass.ItAttrs
				st << ind << " "
		}
		return @temp st.Str()
	}
	
	itAlign := int
	itSize := int
	computedAlign := bool
	debTable := List.{Tuple.{char^,MemParam^,int,int}}
	ComputeAlignAndDeb := !() -> void
	{
		if computedAlign return void
		computedAlign = true
		itAlign = 1
		
		nowSize := 0
		if ToClass.ContainVirtual
			nowSize = 8 //TODOSIZE

		appendType := (Type^ typ) ==> 
		{
			sAlign := typ.GetAlign()
			alignMask :=  ![0,0,1,0,3,0,0,0,7,0,0,0,0,0,0,0,15][sAlign]
			sSize := typ.GetSize()

			if (not ToClass.IsPacked) and ((nowSize and_b alignMask) != 0)
			{
				nowSize = nowSize + alignMask
				nowSize = nowSize - (nowSize and_b alignMask)
			}
			nowSize += sSize
			if sAlign > itAlign
				itAlign = sAlign
		}

		for it : ToClass.Parents
		{
			it.ClassType.ComputeAlignAndDeb()
			appendType(it.ClassType)
		}
		for it : ToClass.Params
		{
			sSize := it.ResultType.GetSize()
			debTable.Emplace(it.ItName,it,nowSize,sSize)
			appendType(it.ResultType)
		}
		itSize = nowSize
		if ToClass.IsPacked
			itAlign = 1
	}

	GetParamOffset := virtual !(int nr) -> int
	{
		ComputeAlignAndDeb()
		assert(nr < debTable.Size())
		return debTable[nr].2
	}
	GetAlign := virtual !() -> int
	{
		ComputeAlignAndDeb()
		return itAlign
	}
	GetSize := virtual !() -> int
	{
		ComputeAlignAndDeb()
		return itSize
	}
}
