BoxFunc := class extend BoxFuncContainer
{
	MyFuncType := TypeFunc^
	MyFuncParamNames := string[]
	FuncName := string
	OutputName := string
	IsSuffix := bool
	IsVirtual := bool
	IsMethod := bool
	IsRetComplex := bool
	IsRetRef := bool
	IsStatic := bool
	IsInvalid := bool
	IsSelfReturn := bool
	IsPassAttrs := bool

	CountAttrs := bool

	VirtualId := int

	MethodType := Type^

	ItConsts := Queue.{Object^}
	ItAttrs := AVLMap.{string,Object^}
	ItVals := List.{ObjConstHolder^}

	vargsName := string
	funcUserParamsCount := int

	DefaultValues := FuncDefValue[]
	DefaultValuesCount := int

	vargTypeBarrier := Object^


	GetType := virtual !() -> Type^
	{
		return MyFuncType
	}
	IsAssembler := virtual !() -> bool
	{
		return false
	}
	GenerateCall := virtual !(Object^ pars) -> BaseFuncCall^
	{
		return null
	}
	GetItem := virtual !(string name) -> Object^
	{
		if ItVals[^].ItName == name
			return it.Down
		return null
	}
	GetWrappedFunc := virtual !() -> BoxFunc^ 
	{
		return this&
	}
	
	IsSameConsts := !(FuncInputBox itBox) -> bool
	{
		if itBox.itConsts.Size() != ItConsts.Size() 
			return false

		if CountAttrs
		{
			if itBox.itAttrs.Size() < ItAttrs.Size() 
				return false
			for val,key : itBox.itAttrs
			{
				sRes :=  ItAttrs.TryFind(key)
				if sRes != null
				{
					if not CmpConstObjs(val,sRes^)
						return false
				}else{
					if val is ObjBool
					{
						asBool := val->{ObjBool^}
						if asBool.MyBool
							return false
					}else{
						return false
					}
				}
			}
		}

		for ct,i : itBox.itConsts , tc : ItConsts
		{
			if not CmpConstObjs(ct,tc) 
			{
				return false
			}
		}
		return true
	}

	ItConstsTT := List.{Object^}
	ParseConsts := !(Object^ cons) -> void
	{
		if cons != null
		{
			for iter : cons.Down
			{
				if iter.GetValue() == ","
					continue

				if iter.IsConst
				{
					ItConsts.Push(iter.Clone())
					ItConstsTT.Push(null)
					continue
				}
				typ := ParseType(iter)
				if typ != null
				{
					ItConsts.Push(new ObjType(typ))
					ItConstsTT.Push(null)
					continue
				}

				stdL := Queue.{string}()
				if ContainTType(iter,stdL)
				{
					ItConsts.Push(null->{Object^})
					ItConstsTT.Push(iter)
				}else{
					ErrorLog.Push("can not parse object in .{}\n")
				}
			}
		}
	}

	ParseParams := !(Object^ root, Object^ outObj,bool IsTempl) -> bool
	{
		return ParseParams(root,outObj,IsTempl,null)
	}
	ParseParams := !(Object^ root, Object^ outObj,bool IsTempl, TypeFunc^ parentFunc) -> bool
	{
		SyntaxCompress(root,PriorityData)
		Pars := Queue.{Object^}() ; $temp

		Typs := Queue.{Type^}() ; $temp
		TypsNams := Queue.{string}() ; $temp
		TypsDefValues := Queue.{Object^}() ; $temp
		TypsDefValuesModifier := List.{int}() ; $temp
		TypsIsRef := Queue.{bool}() ; $temp
		IsVargsL := false
		ContainTT := false
		defVals := 0

		RetTyp := null->{Type^}
		if GetValue() == "!()" RetTyp =  ParseType(outObj)
		if IsSelfReturn
		{
			RetTyp = MethodType
			IsRetRef = true
		}

		Stuff := Queue.{Object^}() ; $temp

		if RetTyp != null
		{
			if RetTyp is TypeArr or RetTyp is TypeClass
			{
				if not IsRetRef this.IsRetComplex = true
			}
		}
		if FuncName == "new" IsStatic = true

		if MethodType != null and (not IsStatic)
		{
			Typs.Push(MethodType)
			TypsNams.Push("this")
			TypsIsRef.Push(true)
		}

		Stuff.Push(root.Down[^]) ; $temp


		if Stuff.Size() != 0 Stuff.Push(new ObjSymbol(",")) ; $temp 

		indType := 0

		while Stuff.NotEmpty()
		{
			if Stuff[0].GetValue() == ","
			{
				if Pars.Size() == 2 or Pars.Size() == 5
				{
					if Pars[0].Down?.Right.GetValue() == "..."
					{
						vargTypeBarrier = Pars[0].Down.Right
						if not Pars[1] is ObjIndent {
							EmitError("it should be indent")
							return false
						}
						vargsName = Pars[1]->{ObjIndent^}.MyStr
					}else{
						IsParRef := false
						MayType := Type^()
						if Pars[0].Down?.Right?.GetValue() == "&"
						{
							MayType = ParseType(Pars[0].Down)
							IsParRef = true
						}else{
							MayType = ParseType(Pars[0])
						}
						indType += 1
						MayName := ""

						if MayType == null and not ContainTType(Pars[0])
						{
							if ContainTType(Pars[0]) or ContainTT
							{
								ContainTT = true
							}else
							{
								if not IsTempl
								{
									printf("can not parse type at %i\n",indType)
									return false
								}
							}
						}

						if Pars[1] is ObjIndent
						{
							MayName = (Pars[1]->{ObjIndent^}).MyStr

							if Pars.Size() == 5 and Pars[2].GetValue() == "="
							{
								assert(Pars[3].GetValue() == "static")
								fieldType := 0
								switch(Pars[3].GetValue())
								{
									case "static" fieldType = DefValueMod_Static
									case "field" fieldType = DefValueMod_Field
									case void assert(false)
								}
								TypsDefValues.Push(Pars[4])
								TypsDefValuesModifier.Push(fieldType)
								defVals += 1
								IsParRef = true
							}else{
								TypsDefValues.Push(null)
								TypsDefValuesModifier.Push(0)
							}
						}else{
							if Pars[1].Down?.Right?.GetValue() == "=" and Pars[1].Down is ObjIndent
							{
								MayName = (Pars[1].Down->{ObjIndent^}).MyStr
								TypsDefValues.Push(Pars[1].Down.Right.Right)
								TypsDefValuesModifier.Push(0)
								defVals += 1
							}else{
								printf("only indentificators allowed, got %s\n",Pars[1].GetValue())
								return false
							}
						}
						Typs.Push(MayType)
						TypsIsRef.Push(IsParRef)
						TypsNams.Push(StrCopy(MayName))
					}	
					Pars.Clean()		
				}
				if Pars.Size() == 1
				{
					if Pars[0].GetValue() == "..." IsVargsL = true
					else
					{
						if Pars[0].GetValue() == "~ind"
						{
							itType := Type^()
							isRef := false
							if parentFunc != null
							{
								tId := Typs.Size()
								if parentFunc.ParsCount > tId
								{
									itType = parentFunc.Pars[tId]
									isRef = parentFunc.ParsIsRef[tId]
								}
							}
							Typs.Push(itType)
							TypsIsRef.Push(isRef)
							TypsNams.Push((Pars[0]->{ObjIndent^}).MyStr)
							TypsDefValues.Push(null)
							TypsDefValuesModifier.Push(0)
						}else{
							itr := Pars[0]
							if itr is ObjData and itr.Down? is ObjIndent and itr.Down.Right?.GetValue() == "..."
							{
								asIn := itr.Down->{ObjIndent^}
								vargsName = asIn.MyStr
							}else{
								EmitError("unknown error\n")
							}

						}
					}
					Pars.Clean()
				}
				Stuff.Pop()
			}else
			{
				Pars.Push(Stuff.Pop())
			}
		}
		MyFuncType = null
		MyFuncParamNames = null

		DefaultValuesCount = defVals
		if defVals != 0
		{
			DefaultValues = new FuncDefValue[TypsDefValues.Size()]
			for toSet : DefaultValues, vl : TypsDefValues , modif : TypsDefValuesModifier
			{
				toSet.Value = vl
				toSet.ValueModifier = modif
			}
		}

		if Typs.Size() != 0
		{
			MyFuncParamNames = TypsNams.ToArray()
		}
		

		arr := TypsIsRef.ToArray()
		MyFuncType = GetFuncType(Typs,arr,RetTyp,IsRetRef,IsVargsL)
		funcUserParamsCount = MyFuncType.ParsCount

		if MyFuncParamNames != null and MyFuncType.ParsCount != 0
		{
			if MyFuncParamNames[0] == "this" IsMethod = true
		}

		if Typs.Size() == 0 return true

		return true
	}
	SetReturnType := !(Type^ toSet) -> void
	{
		this.IsRetComplex = false
		if toSet is TypeArr  or toSet is TypeClass
		{
			if not this.IsRetRef this.IsRetComplex = true
		}
		if MyFuncType.RetType != toSet
		{
			MyFuncType = ExchangeFuncType(MyFuncType,toSet)
		}			
	}
	ParseBlock := virtual !() -> void
	{
	}

	GetValue := virtual !() -> string
	{
		return "!()"
	}
	ApplyDeferUse := virtual !(int depth) -> void
	{
	}
}

PrintFuncBodySkobs := !(TIOStream f,TypeFunc^ fType,string[] names,string fName,string Extra,int itId) -> void
{
	f << "define " //"dso_local "

	if InCC != null
		f << " " << InCC << " "

	IsRetComplex := false

	if not fType.RetRef
	{
		IsRetComplex = IsComplexType(fType.RetType)
	}

	if IsRetComplex f << "void"
	else 
	{
		fType.RetType.PrintType(f)
		if fType.RetRef f << "*"
	}

	f << " @" << fName

	f << "("
	
	if Extra != null
	{
		f <<	Extra
		if IsRetComplex or fType.ParsCount != 0 
			f << " , "
	}
	if IsRetComplex 
	{
		f << fType.RetType.GetName() << "* %" << ReturnName
		if fType.ParsCount != 0 f << " , "
	}
	for i : fType.ParsCount
	{
		if i > 0 f << " , "
		if names != null and i < names->len
		{
			if fType.ParsIsRef[i]
				fType.Pars[i].GetPoint().PrintType(f)
			else	fType.Pars[i].PrintType(f)
			f << " %" <<names[i]
		}else{
			if fType.ParsIsRef[i]
				fType.Pars[i].GetPoint().PrintType(f)
			else	fType.Pars[i].PrintType(f)
			f << " %Extra" << itId << "Param" << i
		}
	}
	if fType.IsVArgs
	{
		if fType.ParsCount > 0 f << " , "
		f << "..."
	}
	f << ")"
}
