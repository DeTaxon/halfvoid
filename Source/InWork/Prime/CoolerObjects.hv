ObjSkobs := class extend Object
{
	Vers := int
	"this" := !(char^ st) -> void
	{
		if st == "{}" Vers = 1
		if st == "[]" Vers = 2
		if st == "()" Vers = 3
	}
	GetValue := virtual !() -> char^
	{
		if Vers == 1 return "{}"
		if Vers == 2 return "[]"
		if Vers == 3 return "()"
		return ""
	}
	GetTokenId := virtual !() -> int
	{
		switch Vers
		{
			case 3 return 46 
			case 1 return 47 
			case 2 return 48 
		}
		return 0
	}
	DoTheWork := virtual !(int pri) -> void
	{
		if pri == State_Start
		{
			if Vers == 1 and Left?.GetValue() != "."
			{
				isLft := Left != null
				oldVal := Object^
				if isLft {
					oldVal = Left
				}else{
					oldVal = Right
				}
				if Left? is ObjTemplateType //DECORATOR
				{
					cmdName := ("@"sbt + Left->{ObjTemplateType^}.MyStr + " block")->{char^}
					fBox := new FuncInputBox ; $temp

					lType := GetFuncType(![GTypeVoidP,GTypeInt],GTypeVoid).GetLambda()
					fBox.itPars.Emplace(lType,false)
					fBox.itPars.Emplace(GTypeInt,false)

					fnc  := FindFunc(cmdName,this&,fBox^,false)
					if fnc == null
					{
						lT2 := GetFuncType(![GTypeVoidP],GTypeVoid).GetLambda()
						box2 := new FuncInputBox ; $temp
						box2.itPars.Emplace(lT2,false)
						fnc = FindFunc(cmdName,this&,box2^,false)
						if fnc == null
							EmitError("Decorator not found")

						tmpObj := new Object ; $temp
						ReplaceNode(this&,tmpObj)

						newItm := new SBoostLambda()
						newItm.Down = this&
						this.Up = newItm
						MakeItBlock(this&)
						WorkBag.Push(newItm,State_Start)
						newItm.ApplyFunc(lT2,false)
						newCall := MakeSimpleCall(fnc,newItm)
						ReplaceNode(tmpObj,newCall)
						newCall.Line = this.Line
						newItm.Line = this.Line
					}else{
						tmpObj := new Object ; $temp
						ReplaceNode(this&,tmpObj)

						newItm := new SLambdaDecorator()
						newItm.Right = new ObjInt(0)
						newItm.Down = this&
						this.Up = newItm
						MakeItBlock(this&)
						WorkBag.Push(newItm,State_Start)
						newItm.ApplyFunc(lType,false)
						newCall := MakeSimpleCall(fnc,newItm)
						ReplaceNode(tmpObj,newCall)
						newCall.Line = this.Line
						newItm.Line = this.Line
					}
				}else{
					MakeItBlock(this&)
				}
				if oldVal != null
				{
					if isLft{
						WorkBag.Push(oldVal.Right,State_Start)
					}else{
						WorkBag.Push(oldVal.Down,State_Start)
					}
				}

			}else{
				WorkBag.Push(this&,State_Syntax)
				WorkBag.Push(this&,State_PreGetUse)
			}
		}
		if pri == State_Syntax
		{
			SyntaxCompress(this&,PriorityData)
		}
		if pri == State_PreGetUse
		{
			WorkBag.Push(Down[^],State_Start)
		}
	}
	Clone := virtual !() -> Object^
	{
		PreRet := new ObjSkobs(GetValue())
		PreRet.Line = Line

		LineI := Object^()
		
		for IterD : Down
		{
			if LineI == null
			{
				PreRet.Down = IterD.Clone()
				LineI = PreRet.Down
			}else{
				LineI.Right = IterD.Clone()
				LineI.Right.Left = LineI
				LineI = LineI.Right
			}
		}
		if PreRet.Down != null PreRet.Down.SetUp(PreRet)

		return PreRet
	}
}


UniteSkobs := !(Object^ Tree) -> Object^
{
	Bag := new Stack.{Object^} ; $temp
	iter := Tree
	
	while iter != null
	{
		Value := iter.GetValue()
		tokId := iter.GetTokenId()

		if tokId in 40..42 	Bag.Push(iter)

		if tokId in 43..45
		{
			itPair := char^
			switch tokId
			{
				case 43 itPair = "()"
				case 44 itPair = "{}"
				case 45 itPair = "[]"
			}

			if Bag.Empty() return iter
			Old := Bag.Pop()
			if tokId - Old.GetTokenId() != 3
			{
				Old.EmitError("incorrect pair for "sbt + Old.GetValue())
				return iter
			}

			NewObj := new ObjSkobs(itPair)
			NewObj.Line = Old.Line
			UNext(Old,NewObj,iter)

			TIter := NewObj.Down
			PopOutNode(TIter)
			TIter = NewObj.Down

			if TIter.Right != null{
				while TIter.Right != null TIter = TIter.Right
			}
			PopOutNode(TIter)

			iter = NewObj.Right
		}else{
			iter = iter.Right
		}

	}
	for Bag^
	{
		it.EmitError("pair for "sbt + it.GetValue() + " not found")
	}
	return null
}
