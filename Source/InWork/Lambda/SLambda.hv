IsSLambda := !(Object^ ob) -> bool
{
	if ob is SLambda return true
	if ob is SBoostLambda return true
	if ob is SLambdaDecorator return true
	if ob is SFuncLambda return true
	return false
}

SLambda := class extend BoxFuncContainer
{
	parsedStart := bool
	applyed := bool
	Names := RawArray.{char^}
	parms := LocalParam^^
	InAlloc := int^
	fastUse := TypeFunc^
	ItNR := int
	inAlloc := int
	manSkob := bool
	justFunc := bool
	ItId := int

	lambadOnItsFrameNr := int

	Created := bool

	StolenParams := AVLMap.{char^,LocalParam^}

	CaptureParams := List.{Tuple.{char^,LocalParam^,bool,MemParam^,int}}
	CPIndexes := List.{int}
	ResultType := Type^
	GetType := virtual !() -> Type^ { return ResultType }

	newCall := Object^
	deleteCall := Object^

	thisLambda := FuncParam^

	outLabel := BoxLabelAnon
	yieldLabel := BoxLabelAnon
	returnYieldLabel := BoxLabelAnon
	
	GetScope := virtual !() -> int { return ABox.ItId }
	this := !() -> void
	{
		ABox.ItId = GetNewId()
		outLabel."this"()
		yieldLabel."this"()
		returnYieldLabel."this"()
		WorkBag.Push(this&,State_Start)
		WorkBag.Push(this&,State_PrePrint)
		ItId = GetNewId()
		inAlloc = -1
		lambadOnItsFrameNr = -1
	}
	IsCloned := false
	Clone := virtual !() -> Object^
	{
		IsCloned = true
		PreRet := new SLambda()
		PreRet.Line = Line

		IterD := Down
		LineI := Object^
		LineI = null
		
		while IterD != null
		{
			if LineI == null
			{
				PreRet.Down = IterD.Clone()
				LineI = PreRet.Down
			}else{
				LineI.Right = IterD.Clone()
				LineI.Right.Left = LineI
				LineI = LineI.Right
			}
			IterD = IterD.Right
		}
		if PreRet.Down != null PreRet.Down.SetUp(PreRet)

		return PreRet
	}

	AddYodler := virtual !(BoxReturn^ toAdd) -> int
	{
		Yodlers.Push(toAdd)
		return Yodlers.Size()
	}
	ApplyParams := virtual !(int count, Type^^ pars,bool^ isRef) -> void
	{
		if count != 0
		{
			parms = new LocalParam^[count]
			InAlloc = new int[count]
		}
		for i : count
		{
			if isRef[i] {
				InAlloc[i] = ABox.GetAlloc(pars[i].GetPoint())
			}else{
				InAlloc[i] = ABox.GetAlloc(pars[i])
			}
			parms[i] = new LocalParam(pars[i],InAlloc[i],isRef[i])
		}

		WorkBag.Push(Down,State_Syntax)

	}
	DoStateStart := virtual !(int pri) -> void
	{
				parsedStart = true
				justFunc = Down.Right.GetValue() == "=>"
				if justFunc 
				{
					ts := this&
					ts->SetType(SFuncLambda)
				}
				//WorkBag.Push(this&,State_Syntax)
				names := Queue.{string}() ; $temp

				pars := Queue.{Type^}() ; $temp
				isRef := Queue.{bool}() ; $temp

				if not justFunc{
					names.Push(StrCopy("lambdaParam"sbt + ItId))
					pars.Push(GTypeVoidP)
					isRef.Push(false)
				}

				isTmpl := false

				skobPos := Object^()
				if Down.GetValue() == "()"
				{
					skobPos = Down
				}else{
					if Down.GetValue() == "~d"
					{
						if Down.Down.GetValue() == "()"
						{
							skobPos = Down.Down					
						}
					}
				}

				if skobPos != null
				{
					//TrimCommas(skobPos)
					iter := skobPos.Down
					bag := @temp new List.{Object^}
					while iter != null
					{
						if iter.GetValue() != ","
						{
							bag.Push(iter)
						}
						if iter.GetValue() == "," or iter.Right == null
						{
							switch bag.Size()
							{
								case 1
									if not bag^[0] is ObjIndent
									{
										EmitError("unknown input objecy\n")
										return void
									}
									asN := bag^[0]->{ObjIndent^}
									names.Push(asN.MyStr)
									pars.Push(null->{Type^})
									isRef.Push(false)
									isTmpl = true
								case 2
									if not bag^[1] is ObjIndent
									{
										EmitError("unknown input object\n")
										return void
									}
									asN2 := bag^[1]->{ObjIndent^}
									names.Push(asN2.MyStr)
									itTyp := ParseType(bag^[0])
									if itTyp == null
									{
										EmitError("can not parse type\n")
										return void
									}
									pars.Push(itTyp)
									isRef.Push(false)
								case 0
								case void
									//assert(false)
									EmitError("incorrect input of lambda \n"sbt + bag.Size())
							}
							bag.Clear()

						}
						iter = iter.Right
					}
				}else{
					isTmpl = true
					if Down.GetValue() == "~ind"
					{
						asN := Down->{ObjIndent^}
						names.Push(asN.MyStr)
						pars.Push(null->{Type^})
						isRef.Push(false)
					}else{
						EmitError("incorrect input items of lambda\n")
					}
				}

				Names.Resize(names.Size())
				for nm,i : names
				{
					Names[i] = nm
				}

				resType := GTypeVoid
				cmp := Down.Right
				if cmp.Right.GetValue() != "{}"
				{
					resType = ParseType(cmp.Right)
					if resType == null
						EmitError("can not parse return type")
					PopOutNode(cmp.Right)
				}

				asFunc := GetFuncType(pars,null->{bool^},resType,false,false)
				fastUse = asFunc

				if not isTmpl
				{
					//if not justFunc
					//{
						Created = true
						parms = new LocalParam^[pars.Size()]
						InAlloc = new int[pars.Size()]
						for it,i : pars
						{
							isRf := IsComplexType(it) 
							isRf = isRf or isRef[i]
							if isRf {
								InAlloc[i] = ABox.GetAlloc(it.GetPoint())
							}else{
								InAlloc[i] = ABox.GetAlloc(it)
							}
							if not justFunc and i == 0
							{
								lambadOnItsFrameNr = ABox.GetNR(InAlloc[0])
							}
							parms[i] = new LocalParam(it,InAlloc[i],isRf)
						}
						WorkBag.Push(Down,State_Syntax)
					//}
					WorkBag.Push(this&,State_PrePrint)
				}

				if justFunc
				{
					ResultType = asFunc.GetPoint()
				}else{
					ResultType = asFunc.GetLambda()
				}
				PopOutNode(Down)
				PopOutNode(Down)

				if Down.GetValue() == "[]"
				{
					count := 0
					for c : Down.Down
					{
						if c.GetValue() != ","
						{
							if count == 0
							{
								if c.GetValue() == "~ind"
								{
									CaptureParams.Emplace(c->{ObjIndent^}.MyStr,null,false,null,GetNewId())
									count = 1
								}else
								{
									EmitError("invalid capture input")
								}
							}else{
								if count == 1
								{	
									if c.GetValue() == "&"
									{
										CaptureParams.Back().2 = true
									}else
									{
										EmitError("unknown object")
									}
								}else{
									EmitError("too much stuf")
								}
							}
						}else{
							count = 0
						}
					}
					PopOutNode(Down)
				}

				if Down.GetValue() == "{}"
					manSkob = true
				MakeItBlock(Down)
	}
	DoTheWork := virtual !(int pri) -> void
	{
		if pri == State_PrePrint
		{
			if IsCloned return void
			for it : CaptureParams
			{
				if it.1 != null
					continue
				re := GetItem(it.0,Up)
				if re == null EmitError("Capture param "sbt + it.0 + " not found")
			}
		}
		if pri == State_Start and (not parsedStart)
		{
			DoStateStart(pri)
		}
		if pri == State_PostGetUse
		{
			if not justFunc
			{
				newCallB := @temp new FuncInputBox
				newCallB.itPars.Emplace(GTypeU64,false)
				newCallB.itConsts.Push(@temp new ObjType(GTypeU8))
				newFunc := FindFunc("new",Up,newCallB^,false)
				newCall = MakeSimpleCall(newFunc,new ParamNaturalCall("",new FuncParam("ResLambdaSize",GTypeU64,false)))


				delCallB := @temp new FuncInputBox
				delCallB.itPars.Emplace(GTypeVoidP,false)
				delFunc := FindFunc("delete",Up,delCallB^,false)
				deleteCall = MakeSimpleCall(delFunc,null)
				deleteCall = MakeSimpleCall(delFunc,new ParamNaturalCall("",new FuncParam("LambdaToDel",GTypeVoidP,false)))

			}
			inAlloc = GetAlloc(Up,ResultType.Base.GetPoint())
			ItNR = GetAllocNR(Up,inAlloc)
		}
		
		if pri == State_CheckDefer
		{
			ParseDefer()
		}
		if pri == State_PrePrint
		{
			ApplyCaptures()
			if Yodlers.Size() != 0
			{
				yodlerInAllocId := ABox.GetAlloc(GTypeInt)
				yodlerInAlloc = ABox.GetNR(yodlerInAllocId)
				if justFunc
				{
					ABox.liveOnGlobal = true
				}else{
					allFnd := Up
					while allFnd != null
					{
						if allFnd.GetValue() == "!()" or allFnd is SLambda
						{
							if allFnd is SLambda
							{
								asL := allFnd->{SLambda^}
								ABox.MoveTo(asL.ABox&)
							}else{
								asF := allFnd->{BoxFuncBody^}
								ABox.MoveTo(asF.ABox&)
							}
							break
						}
						allFnd = allFnd.Up
					}
				}
			}
		}
	}
	PrintInhers := !(TIOStream f,char^ startS,bool printDeb) -> void
	{
		funcsUp := List.{Tuple.{AllocBox^,SLambda^,BoxFuncBody^}}()
		funcsUp.allocator = gTemporaryPool&
		itrr := Up
		while itrr != null
		{
			if itrr.GetValue() == "!()"
			{
				funcsUp.Emplace(itrr->{BoxFuncBody^}.ABox&,null,itrr->{BoxFuncBody^})
				break
			}
			if IsSLambda(itrr)
			{
				asSL := itrr->{SLambda^}
				funcsUp.Emplace(asSL.ABox&,asSL,null)
				if asSL.justFunc
					break
			}
			itrr = itrr.Up
		}
		nameIter := 0
		prevLam := this&
		prevLName := startS
		for it, i : funcsUp
		{
			ABName := it.0.GetClassName()
			f << "%LBegin" << nameIter << "Pos = getelementptr " << ABName << " , " << ABName<< "* null ,i32 0, i32 " << prevLam.ItNR << "\n"
			f << "%LS2" << nameIter << " = ptrtoint " << prevLam.ResultType.GetName() << " %LBegin" << nameIter << "Pos to i64\n"
			f << "%LS1" << nameIter << " = ptrtoint i8* "<< prevLName  << " to i64\n"
			f << "%Lambda" << nameIter << "Pre2 = sub i64 %LS1" << nameIter << " , %LS2" << nameIter << "\n"
			f << "%Lambda" << nameIter << "Box = inttoptr i64 %Lambda" << nameIter << "Pre2 to " << ABName << "*\n"
			it.0.PrintBoxItems(f,"%Lambda"sbt + nameIter + "Box",-1) //TODO: add dbg data
			prevLam = it.1
			if prevLam?.justFunc
				prevLam = null
			if prevLam != null
			{
				f << "%NextLam" << nameIter << " = load i8* , i8** %T" << prevLam.InAlloc[0] << "\n"
				prevLName = ("%NextLam"sbt + nameIter)->{char^}
			}
			if it.2 != null and it.2.IsMethod
			{
				itrT := GetUpClass(it.2)
				
				f << "%this = load " << itrT->{BoxClass^}.ClassType.GetName() << "* , "
					<< itrT->{BoxClass^}.ClassType.GetName() << "** %T" << it.2.InAlloc[0] <<"\n"
			}
			nameIter += 1
		}
		if applyedCaptures
		{
			k := 0
			for it : CaptureParams
			{
				if it.1 == null
					continue
				kk := CPIndexes[k]
				f << "%T" <<  it.4 << " = getelementptr " 
				f << captureType.GetName() << " , " << captureType.GetName() 
				f << "* %T" << cptInAlloc << ", i32 0, i32 " << kk << "\n"
				k++
			}
		}
		if printDeb 
		{
			//funcsUp.Back().2.PrintDebugDeclare(f,this&)
			if Down != null Down[^].PrintDebugDeclare(f,null,null->{char^})
			for it : StolenParams it.PrintDebugDeclare(f,this&,null->{char^})
			for it : CaptureParams
			{
				if it.1 != null
					it.1.PrintDebugDeclare(f,this&,it.0)
			}
			
		}
	}
	
	applyedCaptures := bool
	GotCapture := bool
	captureType := Type^
	cptInAlloc := int
	cptInAllocNR := int
	ApplyCaptures := !() -> void
	{
		if applyedCaptures
			return void
		applyedCaptures = true

		iter := Up
		while iter != null
		{
			if iter is SLambda
				iter->{SLambda^}.ApplyCaptures()
			iter = iter.Up
		}

		toR := @temp new FuncInputBox
		GotCapture = false 

		almI := 0
		for it,i : CaptureParams
		{
			if it.1 != null
			{
				GotCapture = true
				CPIndexes.Push(almI)
				if it.2
				{
					toR.itPars.Emplace(it.1.ResultType.GetPoint(),true)
				}else{
					toR.itPars.Emplace(it.1.ResultType,true)
				}
				almI += 1
			}
		}
		if GotCapture
		{
			captureType = GetTuple(toR).ClassType
			cptInAlloc = GetAlloc(Up,captureType)
			cptInAllocNR = GetAllocNR(Up,cptInAlloc)
		}
	}


	PrintGlobal := virtual !(TIOStream f) -> void
	{
		if applyed
		{
			ABox.PrintGlobal(f)
		}
		Down.PrintGlobal(f)
		if applyed
		{
			
			funcsUp := List.{Tuple.{AllocBox^,SLambda^,BoxFuncBody^}}()
			funcsUp.allocator = gTemporaryPool&
			nameIter := 0
			prevLName := Names[0]
			if not justFunc
			{
				itrr := Up
				while itrr != null
				{
					if itrr.GetValue() == "!()"
					{
						funcsUp.Emplace(itrr->{BoxFuncBody^}.ABox&,null,itrr->{BoxFuncBody^})
						break
					}
					if IsSLambda(itrr)
					{
						asSL := itrr->{SLambda^}
						funcsUp.Emplace(asSL.ABox&,asSL,null)
						if asSL.justFunc
							break
					}
					itrr = itrr.Up
				}
				
				realAllocs := 0
				f << "%FatLambdaType" << ItId << " = type {"
				for bx : funcsUp
				{
					if realAllocs != 0
						f << ","
					if bx.0.parentAlloc == null
					{
						f << bx.0.GetClassName()
						realAllocs += 1
					}
				}
				f << "}\n"


				prevLambd := this&
				DeleteFunc(f,funcsUp,prevLambd,nameIter)
				IsFinishedFunc(f,funcsUp,prevLambd,nameIter)

				CloneFunc(f,funcsUp,realAllocs)

			}

			PrintFuncBodySkobs(f,fastUse,Names,"lambda"sbt + ItId,null->{string},ABox.ItId)
			if not justFunc 
			{ 
				f << "prefix %LambdaPrefix {"
				f <<" i8*(i8*)* @LambdaCopy" << ItId 
				f << " , void(i8*)* @LambdaDelete" << ItId 
				f << " , i1(i8*)* @LambdaIsFinished" << ItId 
				f << "}" 
			}
			f << "\n"

			if DebugMode
			{
				f << " !dbg !" << ABox.ItId
			}
			f << "\n{\n"

			if thisLambda != null
			{
				f << "%ThisLambda = bitcast i8* %lambdaParam" << ItId << " to " << ResultType.GetName() << "\n"
			}
			
			
			debId := -1
			if DebugMode
				debId = CreateDebugCall(this&)
			if not justFunc
			{
				PrintInhers(f,"%"sbt + Names[0],DebugMode)
			}
			ABox.PrintAlloc(f,"%Lambda0Box",debId)
			PrintABoxExtra(f)
			
			DeferFuncStart(f,debId)

			for i : fastUse.ParsCount
			{
				f << "store "
				f << fastUse.Pars[i].GetName()
				if fastUse.ParsIsRef[i] f << "*"
				f << " %" << Names[i] << " , "
				f << fastUse.Pars[i].GetName()
				if fastUse.ParsIsRef[i] f << "*"
				f << "* %T" << InAlloc[i] << "\n"
				if DebugMode and i != 0
				{
					outId := CreateDbgLocVar(this&,fastUse.Pars[i],Names[i])
					newId := CreateDebugCall(this&)
					if newId != -1 and outId != -1
					{
						f << "call void @llvm.dbg.declare(metadata " << fastUse.Pars[i].GetName()
						if fastUse.ParsIsRef[i] 
							f << "*"
						f <<"* %T" << InAlloc[i] << " , metadata !" << outId << " , metadata !DIExpression()) , !dbg !" << newId << "\n"
					}
				}
			}
			
			IsRetComplex := false
			if not fastUse.RetRef
			{
				IsRetComplex = IsComplexType(fastUse.RetType)
			}
			if (not IsRetComplex) and fastUse.RetType != GTypeVoid
			{
				f << "%Result = alloca " << fastUse.RetType.GetName()
				if fastUse.RetRef f << "*"
				f << "\n"
			}

			CodeStreamOverload(f)

			if Yodlers.Size() != 0
			{
				f << "%Yodler = getelementptr " << ABox.GetClassName() << " , " << ABox.GetAsUse() << " , i32 0, i32 " << yodlerInAlloc << "\n" 
				f << "%StartYield = load i32, i32* %Yodler\n"
				f << "switch i32 %StartYield, label %Yield0 ["
				for i : Yodlers.Size() + 1
					f << "i32 " << i << ", label %Yield" << i << "\n"
				f << "i32 " << (SLambdaFinishYieldValue - 1) << ", label %QuitFunc\n"
				f << "]\n"
				f << "Yield0:\n"
				//TODO if Finished emit error
			}

			Down.PrintInBlock(f) // MAIN DATA

			if Yodlers.Size() != 0
			{
				f << "br label %QuitFunc\n"
			}

			f << "br label %" << outLabel.GetLabel() << "\n"
			outLabel.PrintLabel(f)
			
			if Yodlers.Size() != 0
			{
				f << "store i32 " << (SLambdaFinishYieldValue - 1) << " , i32* %Yodler\n"
				f << "br label %" << yieldLabel.GetLabel() << "\n"
			}

			f << "br label %QuitFunc\n"
			f << "QuitFunc:\n"


			DeferFuncEnd(f,debId)

			if Yodlers.Size() != 0
			{
				f << "store i32 " << SLambdaFinishYieldValue << " , i32* %Yodler\n"
			}

			f << "br label %" << yieldLabel.GetLabel() << "\n"
			yieldLabel.PrintLabel(f)

			if fastUse.RetType == GTypeVoid or IsRetComplex
			{
				f << "ret void\n"
			}else{
				retTypeName := fastUse.RetType.GetName()
				if fastUse.RetRef retTypeName = (""sbt  + retTypeName + "*" <-) 
				f << "%ResultItem = load " << retTypeName << " , " << retTypeName << "* %Result\n"
				f << "ret " << retTypeName << " " << "%ResultItem\n"
			}
			f << "}\n"
			if DebugMode
			{	
				iter := Up
				if iter != null
				{
					while iter.Up != null
					{
						iter = iter.Up
					}
				}
				if iter != null
				{
					asN := iter->{BoxFile^}
					f << "!" << ABox.ItId << " = distinct !DISubprogram(name:\":LambdaFunction\","
					f << "scope: !" << asN.fileId << " , file: !" << asN.fileId
					f << ",type: !" << fastUse.metaId 
					if Line != null
					{
						f << ", line: " << Line.LinePos	
						f << ", scopeLine: " << Line.LinePos	
					}
					f << ", unit: !" << cuId
					f << ", flags: DIFlagPrototyped"
					f << ")\n"

				}
			}
		}
	}
	CodeStreamOverload := virtual !(TIOStream f) -> void
	{
	}
	PrintPre := virtual !(TIOStream f) -> void
	{
		if applyed
		{
			asL := ResultType->{TypeFuncLambda^}
			f << "%Tpl2" << ItId << " = getelementptr " << ResultType.Base.GetPoint().GetName() << "," << ResultType.Base.GetPoint().GetName() << "* %T" << inAlloc << ", i32 0\n"
			f << "store " << asL.GetPointName() << " @lambda" << ItId << ", " << ResultType.GetName() << " %Tpl2" << ItId << "\n"

			if Yodlers.Size() != 0
			{
				inNR := ABox.InheritNR()
				f << "%TpY" << ItId << " = getelementptr " << ABox.parentAlloc.GetClassName() << "," << ABox.parentAlloc.GetAsUse() << " ,i32 0,i32 " << inNR <<", i32 " << yodlerInAlloc <<"\n"
				f << "store i32 0, i32* %TpY" << ItId << "\n"
			}
			dbgId := -1
			if DebugMode and Up != null
				dbgId = CreateDebugCall(this.Up)

			k := 0
			for it,i : CaptureParams
			{
				if it.1 != null
				{
					nwId := GetNewId()
					if it.2
					{
						f << "%StP" << nwId << " = getelementptr " << captureType.GetName() << " , "
							<< captureType.GetName() << "* %T" << cptInAlloc << ", i32 0, i32 " << CPIndexes[k] << "\n"
						it.3.PrintPointPre(f,nwId,dbgId)
						f << "store "
						it.3.PrintPointUse(f,nwId,dbgId)
						f << " , "
						f << it.1.ResultType.GetName() << "** "
						f << "%StP" << nwId
						f << "\n"
					}else{
						f << "%StP" << nwId << " = getelementptr " << captureType.GetName() << " , "
							<< captureType.GetName() << "* %T" << cptInAlloc << ", i32 0, i32 " << CPIndexes[k] << "\n"
						it.3.PrintPre(f,nwId,dbgId)
						f << "store "
						it.3.PrintUse(f,nwId,dbgId)
						f << " , "
						f << it.1.ResultType.GetName() << "* "
						f << "%StP" << nwId
						f << "\n"
					}
					k++
				}
			}
		}
	}
	PrintUse := virtual !(TIOStream f) -> void
	{	
		ResultType.PrintType(f)
		f << " %Tpl2" << ItId
	}
	GetName := virtual !() -> string
	{
		return "%T"sbt + inAlloc
	}
	ApplyFunc := virtual !() -> void
	{
		WorkBag.Push(this&,State_PrePrint)
		applyed = true
		WorkBag.Push(Down,State_Start)
		WorkBag.Push(this&,State_PostGetUse)
	}
	ApplyFunc := virtual !(Type^ lambTyp, bool isFnc) -> void
	{
		WorkBag.Push(this&,State_PrePrint)
		if isFnc xor justFunc
		{
			if isFnc
			{
				EmitError("can not change lambda to func")
			}else{
				EmitError("can not change func to lambda")
			}
			return void
		}
		asFType := ((lambTyp.Base)->{TypeFunc^})

		if not manSkob
		{
			isRetCm := IsComplexType(asFType.RetType)

			if asFType.RetType != GTypeVoid and (not isRetCm)
			{
				UNext(Down.Down,new ObjObj("return()"),1)
			}
		}
		fastUse = asFType
		applyed = true
		ResultType = lambTyp
		WorkBag.Push(Down,State_Start)
		WorkBag.Push(this&,State_PostGetUse)

		ApplyParams(fastUse.ParsCount,fastUse.Pars,fastUse.ParsIsRef)
	}
	GetItem := virtual !(string name) -> Object^
	{
		for it,i : CaptureParams
		{
			if it.0 == name
			{
				if it.1 == null
				{
					inUp := GetItem(name,Up)
					if inUp == null
					{
						return null
					}
					if (inUp is ObjParam and inUp.Down? is LocalParam) or inUp is LocalParam or inUp is FuncParam
					{
						itMem := MemParam^()
						if inUp is LocalParam or inUp is FuncParam
						{
							itMem = inUp->{MemParam^}
						}else{
							if inUp.Down? is LocalParam
							{
								itMem = inUp.Down->{MemParam^}
							}else{
								assert(false)
							}
						}
						preRet := new LocalParam(itMem.GetType(),it.4,it.2)
						it.1 = preRet
						it.3 = itMem
						return preRet
					}
				}
				if it.1 != null
					return it.1
				break
			}
		}
		if not justFunc and name == "this_lambda"
		{
			if thisLambda == null
			{
				thisLambda = new FuncParam("ThisLambda" ,ResultType,false)
			}
			return thisLambda
		}
		if fastUse != null
		{
			for i : fastUse.ParsCount 
			{
				if Names[i] == name and parms != null
				{
					return parms[i]
				}
			}
		}

		if not StolenParams.Contain(name)
		{
			inUp := GetItem(name,Up)
			if inUp? is ObjParam and inUp.Down? is LocalParam
			{
				StolenParams[name] = inUp.Down->{LocalParam^}
			}
			if inUp? is LocalParam
			{
				StolenParams[name] = inUp->{LocalParam^}
			}
			if inUp != null
				inUp.NotifyPointUse()
			
		}

		return null
	}

	GetOutPath := virtual !(Object^ item, int typ,int size) ->BoxLabel^
	{
		if typ == PATH_YIELD
		{
			return yieldLabel&
		}
		return outLabel&
	}
	GetValue := virtual !() -> string
	{
		return "x=>x"
	}
	PrintDebugDeclare := virtual !(TIOStream f ,Object^ frc,char^ forcedName) -> void
	{
	}
	ApplyDeferUse := virtual !(int depth) -> void
	{
		printf("sfgasfhafg\n")
	}
	IsDataR := virtual true
	IsBlockData := virtual true
}
SFuncLambda := class extend SLambda
{
	PrintUse := virtual !(TIOStream f) -> void
	{	
		ResultType.PrintType(f)
		f << " @lambda" << ItId
	}
	GetName := virtual !() -> string
	{
		return "@lambda"sbt + ItId
	}
	PrintPre := virtual !(TIOStream f) -> void
	{
	}
	ApplyParams := virtual !(int count, Type^^ pars,bool^ isRef) -> void
	{
		this."SLambda.ApplyParams"(count,pars,isRef)
		ResultType = ResultType.Base.GetPoint()
	}
}

BuiltInLambdaCall := class extend BoxTemplate
{
	this := !() -> void
	{
		FuncName = "()"
		IsMethod = true

		pars := Queue.{Type^}()

		MyFuncType = null
	}
	CreateFuncPointer := virtual !(FuncInputBox itBox) -> TypeFunc^
	{
		pars := ref itBox.itPars

		asL := pars[0].first->{TypeFuncLambda^}
		asB :=  ((pars[0].first.Base)->{TypeFunc^})

		Pars := Queue.{Type^}() ; $temp

		for i : pars.Size()
		{
			if i == 0{
				Pars.Push(pars[0].first)
			}else{
				Pars.Push(asB.Pars[i])
			}
		}
		return GetFuncType(Pars,asB.ParsIsRef,asB.RetType,asB.RetRef,asB.IsVArgs)
	}
	GetPriority := virtual !(FuncInputBox itBox) -> int
	{
		pars := ref itBox.itPars

		if pars.Size() == 0 return 255
		if not pars[0].first is TypeFuncLambda return 255

		asL := pars[0].first->{TypeFuncLambda^}
		asB := ((pars[0].first.Base)->{TypeFunc^})

		if asB.ParsCount != pars.Size() return 255

		maxCmp := 0
		for i : pars.Size()
		{
			if i > 0
			{
				nowCmp := TypeCmp(pars[i].first,asB.Pars[i])
				if maxCmp < nowCmp maxCmp = nowCmp					
			}
		}
		return maxCmp
	}
	GetNewFunc := virtual  !(FuncInputBox itBox, TypeFunc^ fun) -> BoxFunc^
	{
		pars := ref itBox.itPars

		asL := pars[0].first->{TypeFuncLambda^}
		asB := ((pars[0].first.Base)->{TypeFunc^})

		IsCompl := false

		if not asB.RetRef {
			IsCompl = IsComplexType(asB.RetType)	
		}

		ToSet := "%Wut## = bitcast "sbt+ pars[0].first.GetName() + " #1 to i8* #d\n"
			+ "%Func## = load " +pars[0].first.Base.GetName() + "* , " + pars[0].first.GetName() + " #1 #d\n"


		if IsCompl or asB.RetType == GTypeVoid{
			ToSet << "call "
		}else{
			ToSet << "#0 = call " 
		}
		ToSet << pars[0].first.Base.GetName() << "%Func##(i8*  %Wut##"

		if IsCompl
		{
			ToSet << " , " << asB.RetType.GetName() << "* #0"
		}

		for i : pars.Size()
		{
			if i != 0{
			ToSet << " , "

				ToSet << asB.Pars[i].GetName()
				if asB.ParsIsRef[i]{
					ToSet << "*"
				}
				ToSet << " #" << (i + 1)
			}
		}
		ToSet << ") #d\n"
		
		return new BuiltInFuncMega("()",fun,ToSet)
	}
}
BuiltInTemplateSetLambda := class extend BoxTemplate
{
	this := !() -> void
	{
		FuncName = "="
		OutputName = "error"

		MyFuncType = GetFuncType(![null->{Type^},null->{Type^}],null->{Type^})
	}
	GetPriority := virtual !(FuncInputBox itBox) -> int
	{
		pars := ref itBox.itPars
		if pars.Size() != 2 return 255
		if not pars[0].second return 255
		if pars[0].first != pars[1].first return 255
		if pars[0].first.GetType() != "lambda" return 255
		return 0
	}
	GetNewFunc := virtual  !(FuncInputBox itBox, TypeFunc^ funct) -> BoxFunc^
	{
		pars := ref itBox.itPars
		return new BuiltInFuncBinar("=",pars[0].first,true,pars[1].first,false,GTypeVoid, 
		"store "sbt + pars[0].first.GetName() + " #2, " + pars[0].first.GetName() +"* #1 #d\n")
	}
	DoTheWork := virtual !(int pri) -> void
	{
		
	}
}
BuiltInTemplateCaptureLambda := class extend BoxTemplate
{
	this := !() -> void
	{
		IsMethod = true
		FuncName = "Capture"
		OutputName = "error"

		MyFuncType = GetFuncType(![null->{Type^}],GTypeVoidP)
	}
	GetPriority := virtual !(FuncInputBox itBox) -> int
	{
		pars := ref itBox.itPars
		if pars.Size() != 1 return 255
		if not pars[0].second return 255
		if pars[0].first.GetType() != "lambda" return 255
		return 0
	}
	GetNewFunc := virtual  !(FuncInputBox itBox, TypeFunc^ funct) -> BoxFunc^
	{
		pars := ref itBox.itPars
		asPtrN := pars[0].first.Base.GetPoint().GetName()
		return new BuiltInFuncUno(". not",pars[0].first,false,pars[0].first, 
		"%Fnc## = load "sbt + asPtrN + " , " + asPtrN + "* #1\n" +
		"%Pref## = bitcast " + asPtrN + " %Fnc## to %LambdaPrefix*\n" +
		"%ClFuncPre## = getelementptr %LambdaPrefix , %LambdaPrefix* %Pref##, i32 -1, i32 0\n"+
		"%ClFunc## = load i8*(i8*)*, i8*(i8*)** %ClFuncPre##\n"+
		"%LamPtr## = bitcast " + asPtrN + "* #1 to i8*\n"+
		"%CopyRes## = call i8* %ClFunc##(i8* %LamPtr##)\n" +
		"#0 = bitcast i8* %CopyRes## to " + asPtrN + "*\n")
	}
	DoTheWork := virtual !(int pri) -> void
	{
		
	}
}
BuiltInTemplateDeleteLambda := class extend BoxTemplate
{
	this := !() -> void
	{
		IsMethod = true
		FuncName = "Destroy"
		OutputName = "error"

		MyFuncType = GetFuncType(![null->{Type^}],GTypeVoid)
	}
	GetPriority := virtual !(FuncInputBox itBox) -> int
	{
		pars := ref itBox.itPars
		if pars.Size() != 1 return 255
		if not pars[0].second return 255
		if pars[0].first.GetType() != "lambda" return 255
		return 0
	}
	GetNewFunc := virtual  !(FuncInputBox itBox, TypeFunc^ funct) -> BoxFunc^
	{
		pars := ref itBox.itPars
		asPtrN := pars[0].first.Base.GetPoint().GetName()
		return new BuiltInFuncUno(". not",pars[0].first,false,GTypeVoid,
		"%Fnc## = load "sbt + asPtrN + " , " + asPtrN + "* #1\n" +
		"%Pref## = bitcast "sbt + asPtrN + " %Fnc## to %LambdaPrefix*\n" +
		"%ClFuncPre## = getelementptr %LambdaPrefix , %LambdaPrefix* %Pref##, i32 -1, i32 1\n"+
		"%ClFunc## = load void(i8*)*, void(i8*)** %ClFuncPre##\n"+
		"%LamPtr## = bitcast " + asPtrN + "* #1 to i8*\n"+
		"call void %ClFunc##(i8* %LamPtr##)")
	}
	DoTheWork := virtual !(int pri) -> void
	{
		
	}
}

BuiltInTemplateLambdaIsFinished := class extend BoxTemplate
{
	this := !() -> void
	{
		IsMethod = true
		FuncName = "IsFinished"
		OutputName = "error"

		MyFuncType = GetFuncType(![null->{Type^}],GTypeBool)
	}
	GetPriority := virtual !(FuncInputBox itBox) -> int
	{
		pars := ref itBox.itPars
		if pars.Size() != 1 return 255
		if pars[0].first.GetType() != "lambda" return 255
		return 0
	}
	GetNewFunc := virtual  !(FuncInputBox itBox, TypeFunc^ funct) -> BoxFunc^
	{
		pars := ref itBox.itPars
		asPtrN := pars[0].first.Base.GetPoint().GetName()
		return new BuiltInFuncUno(". not",pars[0].first,false,GTypeBool,
		"%Fnc## = load "sbt + asPtrN + " , " + asPtrN + "* #1\n" +
		"%Pref## = bitcast "sbt + asPtrN + " %Fnc## to %LambdaPrefix*\n" +
		"%ClFuncPre## = getelementptr %LambdaPrefix , %LambdaPrefix* %Pref##, i32 -1, i32 2\n"+
		"%ClFunc## = load i1(i8*)*, i1(i8*)** %ClFuncPre##\n"+
		"%LamPtr## = bitcast " + asPtrN + "* #1 to i8*\n"+
		"#0 = call i1 %ClFunc##(i8* %LamPtr##)")
	}
	DoTheWork := virtual !(int pri) -> void
	{
		
	}
}

GlobalLambdaCall := BuiltInLambdaCall^

copyLFuncType := Type^
copyLFuncTypeP := Type^
deleteLFuncType := Type^
deleteLFuncTypeP := Type^
CreateLambdaBuilts := !() -> void
{
	GlobalLambdaCall = new BuiltInLambdaCall()
	BuiltInTemplates.Push(GlobalLambdaCall)

	BuiltInTemplates.Push(new BuiltInTemplateSetLambda())
	BuiltInTemplates.Push(new BuiltInTemplateCaptureLambda())
	BuiltInTemplates.Push(new BuiltInTemplateDeleteLambda())
	BuiltInTemplates.Push(new BuiltInTemplateLambdaIsFinished())

	inpFuncE := Queue.{Type^}() ; $temp
	inpFuncE.Push(GTypeVoidP)
	
	copyLFuncType = GetFuncType(inpFuncE,null,GTypeVoidP,false,false)
	copyLFuncTypeP = copyLFuncType.GetPoint()

	deleteLFuncType = GetFuncType(inpFuncE,null,GTypeVoid,false,false)
	deleteLFuncTypeP = deleteLFuncType.GetPoint()
}
PrintLambdaGlobal := !(TIOStream f) -> void
{
	f << "%LambdaPrefix = type {i8*(i8*)*,void(i8*)*,i1(i8*)*}\n"
}
SLambdaFinishYieldValue := 2000000000
