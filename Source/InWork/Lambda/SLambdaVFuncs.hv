
PrintGlobalLambda := !(TIOStream f) -> void
{
	f << "define i1 @LambdaIsFinishedAlwaysTrue(i8* %ToTest)\n"
	f << "{\n"
	f << 	"ret i1 1\n"
	f << "}\n"
}

AppendClass SLambda
{
	DeleteFunc := !(TIOStream f, funcsUp,prevLambd,nameIter) -> void
	{
		f << "define void @LambdaDelete" << ItId << "(i8* %ToDel" << ItId << ")\n"
		f << "{\n"
			ABName3 := funcsUp[0].0.GetClassName()
			f << "%LBegin" << nameIter << "Pos = getelementptr " << ABName3 << " , " << ABName3 << "* null ,i32 0, i32 " << prevLambd.ItNR << "\n"
			f << "%LS2" << nameIter << " = ptrtoint " << ResultType.GetName() << " %LBegin" << nameIter << "Pos to i64\n"
			f << "%LS1" << nameIter << " = ptrtoint i8* %ToDel"<< ItId  << " to i64\n"
			f << "%Lambda" << nameIter << "Pre2 = sub i64 %LS1" << nameIter << " , %LS2" << nameIter << "\n"
			f << "%LambdaToDel = inttoptr i64 %Lambda" << nameIter << "Pre2 to i8*\n"
			assert(deleteCall != null)
			deleteCall.PrintInBlock(f)
			//f << "call void @free(i8* %LambdaToDel)\n"
		f << "ret void\n"
		f << "}\n"
	}
	IsFinishedFunc := !(TIOStream f, funcsUp,prevLambd,nameIter) -> void
	{
		if Yodlers.Size() == 0
			return void

		f << "define i1 @LambdaIsFinished" << ItId << "(i8* %ToTest" << ItId << ")\n"
		f << "{\n"

		//if Yodlers.Size() == 0
		//{
		//	f << "ret i1 1\n"
		//}else{
			PrintInhers(f,"%ToTest"sbt + ItId,false)
			ABox.PrintAlloc(f,"%Lambda0Box",-1)

			f << "%Yodler = getelementptr " << ABox.GetClassName() << " , " << ABox.GetAsUse() << " , i32 0, i32 " << yodlerInAlloc << "\n" 
			f << "%YieldValue = load i32, i32* %Yodler\n"
			f << "%CmpResult = icmp eq i32 %YieldValue , " << SLambdaFinishYieldValue << "\n" 
			f << "ret i1 %CmpResult\n"
		//}

		f << "}\n"
	}
	CloneFunc := !(TIOStream f, funcsUp,realAllocs) -> void
	{

		prevLName := "ToCpy"sbt + ItId <-

		f << "define i8* @LambdaCopy" << ItId << "(i8* %ToCpy" << ItId << ") \n"

		f << "{\n"
		PrintInhers(f,"%ToCpy"sbt + ItId,false)
		
		ABName := ""
		for funcsUp
		{
			ABName = it.0.GetClassName()
			break
		}

		f << "%ResSizePre" << ItId << " = getelementptr %FatLambdaType" << ItId << " , %FatLambdaType"
			<< ItId << "* null , i32 1\n"
		f << "%ResLambdaSize = ptrtoint %FatLambdaType" << ItId << "* %ResSizePre" << ItId << " to i64\n"
		//f << "%Res" << ItId << " = call i8* @malloc(i64 %ResSize)\n"
		assert(newCall != null)
		newCall.PrintPre(f)

		f << "%PreSet" << ItId << " = bitcast " 
		newCall.PrintUse(f) 
		f << " to " << ABName << "*\n"

		f << "%PreApply = bitcast "
		newCall.PrintUse(f)
		f <<  " to %FatLambdaType" << ItId << "*\n"


		asL := ResultType->{TypeFuncLambda^}


		prevAB := AllocBox^()
		flt := "%FatLambdaType"sbt + ItId <-
		nonNestedC := 0
		funcsUpSize := funcsUp.Size()
		revAllocIter := realAllocs - 1
		for k : funcsUpSize
		{
			nowId := funcsUpSize - k - 1
			nowR := ref funcsUp[nowId]
			if nowR.0.parentAlloc == null
			{
				f << "%OldPtr" << nowId << " = getelementptr " << flt << " , " << flt << "* %PreApply, i32 0,i32 " << revAllocIter << "\n"
				revAllocIter -= 1
			}else{
				prevCName := prevAB.GetClassName()
				f << "%OldPtr" << nowId << " = getelementptr " << prevCName << " , " << prevCName << "* %OldPtr" << (nowId + 1) << " , i32 0"
					f << ", i32 " << nowR.0.InheritNR() << "\n"
			}
			prevAB = nowR.0
		}
		
		prevAB = null
		for fc,k : funcsUp
		{
			if prevAB != null
			{
				//TODO change way to copy vars
				prevFunc := ref funcsUp[k - 1]
				assert(prevFunc.1 != null)

				nowCN := prevAB.GetClassName()
				f << "%ToSet" << k << " = getelementptr " << nowCN << " , " << nowCN 
				<< "* %OldPtr" << (k - 1) << ", i32 0,i32 " << prevFunc.0.GetNR(prevFunc.1.InAlloc[0]) << "\n"

				oldNr := prevFunc.1.ItNR

				f << "%OldPtrTT" << k << " = getelementptr " << fc.0.GetClassName() << " , " << fc.0.GetClassName() << "* %OldPtr"<< k<<" ,i32 0, i32 "<< oldNr <<"\n"
				f << "%OldPtrT" << k << " = bitcast " << prevFunc.1.GetType().GetName() << " %OldPtrTT"<< k<<" to i8*\n"
				f << "store i8* %OldPtrT"<< k << " , i8** %ToSet" << k << "\n"
			}
			if fc.2 != null and fc.2.IsMethod
			{
				itrT := GetUpClass(fc.2)
				assert(itrT != null)
				clName := itrT.ClassType.GetName()
				allcNR := fc.0.GetNR(fc.2.InAlloc[0])
				alName := fc.0.GetClassName()
				f << "%SetThis = getelementptr " << alName << "," << alName <<"* " 
				f << "%OldPtr" << k << " , i32 0,i32 " << allcNR <<"\n"
				f << "store " << clName << "* %this, "<< clName << "** %SetThis\n"
			}
			prevAB = fc.0
		}
		upABName := funcsUp[0].0.GetClassName()
		if Yodlers.Size() != 0
		{
			upAB := funcsUp[0].0
			f << "%Yodler = getelementptr " << upABName << " , " << upABName << "* %Lambda0Box, i32 0, i32 "<< ABox.InheritNR()<<",i32 " << yodlerInAlloc << "\n"
			f << "%PreSetYodler = getelementptr " << ABName << " , " << ABName << "* %OldPtr0 , i32 0,i32 "<< ABox.InheritNR() <<",i32 "<< yodlerInAlloc << "\n"
			f << "%YodlerValue = load i32 , i32* %Yodler\n"
			f << "store i32 %YodlerValue , i32* %PreSetYodler\n"
		}
		f << "%PreSetPoint" << ItId << " = getelementptr " << upABName << " , " << upABName << "* %OldPtr0 , i32 0, i32 " << ItNR << "\n"
		f << "store " << asL.GetPointName() << " @lambda" << ItId << ", " << ResultType.GetName() << " %PreSetPoint" << ItId << "\n"
		for prS,L : StolenParams
		{
			asMNR := -1 
			for it,F : funcsUp
			{
				asMNR = it.0.GetNR(prS.GetAllocId())

				if asMNR == -1
					continue

				is2Ref := false
				if prS is LocalParam and prS->{LocalParam^}.IsRef
					is2Ref = true
				if prS is ConstMemParamRefedRef //TODO add FuncResultMem
					is2Ref = true

				aBName := it.0.GetClassName()
				if is2Ref
				{
					f << "%Pre2Get" << L << " = load " << prS.ResultType.GetName() << "* , " << prS.ResultType.GetName()
						<< "** %T" << prS.GetAllocId() << "\n"
					f << "%PreSet" << L << " = getelementptr " << aBName << " , " << aBName << "* %OldPtr" << F <<" ,i32 0, i32 "<< asMNR << "\n" 
					f << "store " << prS.ResultType.GetName() << "* %Pre2Get" << L << " , "
						<< prS.ResultType.GetName() << "** %PreSet" << L << "\n"
				}else{
					f << "%Pre2Get" << L << " = load " << prS.ResultType.GetName() << " , " << prS.ResultType.GetName()
						<< "* %T" << prS.GetAllocId() << "\n"
					f << "%PreSet" << L << " = getelementptr " << aBName << " , " << aBName << "* %OldPtr"<< F <<" ,i32 0, i32 "<< asMNR << "\n" 
					f << "store " << prS.ResultType.GetName() << " %Pre2Get" << L << " , "
						<< prS.ResultType.GetName() << "* %PreSet" << L << "\n"
				}
			}
		}
		iii := 0
		for it,i : CaptureParams
		{
			if it.1 != null
			{	
				newIdd := GetNewId()
				sii := CPIndexes[iii]
				
				if it.2 
				{
					f << "%TSt" << sii << " = getelementptr " << upABName
						<< " , "<< upABName  << "* %OldPtr0,i32 0,i32 "<< cptInAllocNR <<",i32 0,i32 " << sii << "\n"
					it.1.PrintPointPre(f,newIdd,-1)
					f << "store "
					it.1.PrintPointUse(f,newIdd,-1)
					f << " , " << it.1.ResultType.GetName() << "** "
					f << "%TSt" << sii << "\n"
				}else{
					f << "%TSt" << sii << " = getelementptr " << upABName
						<< " , "<< upABName  << "* %OldPtr0,i32 0,i32 "<< cptInAllocNR <<",i32 0,i32 " << sii << "\n"
					it.1.PrintPre(f,newIdd,-1)
					f << "store "
					it.1.PrintUse(f,newIdd,-1)
					f << " , " << it.1.ResultType.GetName() << "* "
					f << "%TSt" << sii << "\n"
				}
				iii += 1
			}
		}


		//if ABox.parentAlloc != null and (not ABox.ItemBag.Empty())
		//{
		//	cntr := ABox.InheritNR()
		//	nmIn := 0
		//	for funcsUp
		//	{
		//		if it.0 == ABox.parentAlloc
		//			break
		//		nmIn += 1
		//	}
		//	f << "%ToSetAllc = getelementptr %FatLambdaType" << ItId << " , %FatLambdaType" << ItId
		//	f << "* %PreApply, i32 0, i32 0,i32 " << cntr << "\n"
		//	f << "%ItAllocPos = getelementptr " << ABox.parentAlloc.GetClassName() << " , " << ABox.parentAlloc.GetClassName() 
		//		<< "* %Lambda0Box, i32 0, i32 " << cntr <<"\n" 
		//	f << "%ItAlloc = load " << ABox.GetClassName() << " , " << ABox.GetClassName() 
		//		<< "* %ItAllocPos\n" 
		//	f << "store " << ABox.GetClassName() << " %ItAlloc,  " << ABox.GetClassName() 
		//		<< "* %ToSetAllc\n"
		//}
		
		f << "%RRes"<< ItId << " = bitcast "<< ResultType->{TypeFuncLambda^}.GetPointName() << "* %PreSetPoint" << ItId << " to i8*\n"
		f << "ret i8* %RRes"<< ItId << "\n"
		//f << "ret i8* null\n"
		f << "}\n"
	}
}
