
BoxForItemOnClass := class extend BoxForItem
{
	ContainDestroyFunc := virtual !() -> bool { return DestroyFunc != null }

	PrintIncrement := virtual !(BoxForOldFashionMulti^ self,TIOStream f,Object^ itr,int debId) -> void 
	{
		IncFunc.PrintPre(f)
	}
	PrintStepAfter := virtual !(BoxForOldFashionMulti^ self,TIOStream f,Object^ itr,int debId) -> void 
	{
		
		if UnrefFunc.IsRef() UnrefFunc.PrintPointPre(f) else UnrefFunc.PrintPre(f)
		if IndFunc != null
		{
			if IndFunc.IsRef()
			{
				IndFunc.PrintPointPre(f)
			}else{
				IndFunc.PrintPre(f)
			}
		}
		if Param? is RetFuncParamV2 and Name != null and debId != -1
		{
			Param->{RetFuncParamV2^}.PrintForDebugDeclare(f,Name,self.Down,debId)
		}
		if Param != null
			Param.DoStore(f,debId)
		if IndFunc != null and IndParam? is RetFuncParamV2 and IndName != null and debId != -1
		{
			IndParam->{RetFuncParamV2^}.PrintForDebugDeclare(f,IndName,self.Down,debId)
		}
		if IndParam != null
			IndParam.DoStore(f,debId)
	}
	PrintCheckEndPre := virtual !(BoxForOldFashionMulti^ self,TIOStream f,Object^ itr) -> void 
	{
		IsEndFunc.PrintPre(f)	
	}
	PrintCheckEndName := virtual !(BoxForOldFashionMulti^ self,Object^ itr) -> char^ 
	{
		return IsEndFunc.GetName()
	}

	PrintStart := virtual !(BoxForOldFashionMulti^ self,TIOStream f,Object^ itr) -> void 
	{
		if ProxyResult == null
		{
			itr.PrintPre(f)
		}else{
			itr.PrintPre(f)
			f << "store "
			itr.PrintUse(f)
			f << " , "
			itr.GetType().PrintType(f)
			f << "* " << ProxyResult.GetMainPtr(0)
			f << "\n"
		}
		
		if DestroyFunc != null
		{
			f << "store i8 " << self.deferLabel << " , i8* %DeferStack" << self.deferId << "\n"
			self.deferLabel += 1
		}
	}

	PrintDestroyFunc := virtual !(BoxForOldFashionMulti^ self,TIOStream f,Object^ itr,int j) -> void 
	{
		if DestroyFunc is BoxFuncBody //TODO in BoxFunc
		{
			if IsGCClass(itr.GetType())
			{
				itr.PrintPointPre(f)

				f << "%DestrObj" << self.ItId << "n" << j << " = bitcast "
				itr.PrintPointUse(f)
				f << " to i8*\n"

				f << "call void @" << gcCallDestroy.OutputName << "("
				f << "i8* %DestrObj" << self.ItId << "n" << j
				f << ")\n"
				continue
			}
			if DestroyFunc->{BoxFunc^}.IsVirtual
			{
				//TODO add virtual destructor support
				continue
			}
		}
		fnc := DestroyFunc->{BoxFunc^}
		f << "call void @" << fnc.OutputName << "("
		itr.PrintPointUse(f)
		f << ")\n"
		
	}

	Init := virtual !(BoxForOldFashionMulti^ self,Object^ iter, Type^ itType,SomeFuncCall^ asNeed2) -> void
	{
		ForItem := LocalParam^

		if itType is TypeClass
		{
			ItId2 := asNeed2.GetItAllocId()
			ForItem = new LocalParam(itType,ItId2)
		}else{
			assert(itType is TypePoint)
			newId := GetAlloc(self,itType)
			ForItem = new LocalParam(itType.Base,newId,true)
			ProxyResult = ForItem
		}
		ForItem.Line = iter.Line 
		
		asNeed := BoxClass^
		if itType is TypePoint
		{
			asNeed = itType.Base->{TypeClass^}.ToClass						
		} else {
			asNeed = itType->{TypeClass^}.ToClass
		}

		emptyBox := @temp new FuncInputBox
		emptyBox.itPars.Emplace(asNeed.ClassType,true)

		IncFuncP := asNeed.GetFunc("Inc",emptyBox^)
		UnrefFuncP := asNeed.GetFunc("^",emptyBox^)
		IsInvP := asNeed.GetFunc("IsInvalid",emptyBox^)
		DestroyFunc = asNeed.GetFunc("Destroy",emptyBox^)

		if IncFuncP == null {
			self.EmitError("incorrect for iterator, need increment\n")
			return void
		}
		if UnrefFuncP == null {
			self.EmitError("incorrect for iterator, need ^\n")
			return void
		}


		test := new ParamNaturalCall("",ForItem->{Object^})
		test.Line = iter.Line
		UnrefFunc = MakeSimpleCall(UnrefFuncP,test)
		UnrefFunc.Line = self.Line
		UnrefFunc.Up = self
		test = new ParamNaturalCall("",ForItem->{Object^})
		test.Line = iter.Line
		IncFunc = MakeSimpleCall(IncFuncP,test)
		IncFunc.Line = self.Line
		IncFunc.Up = self

		if IsInvP != null
		{
			test = new ParamNaturalCall("",ForItem->{Object^})
			test.Line = iter.Line
			IsInvalid = MakeSimpleCall(IsInvP,test)
			IsInvalid.Line = self.Line
			IsInvalid.Up = self
		}

		IsEndFuncP := asNeed.GetFunc("IsEnd",emptyBox^)
		test = new ParamNaturalCall("",ForItem->{Object^})
		test.Line = iter.Line
		IsEndFunc = MakeSimpleCall(IsEndFuncP,test)
		IsEndFunc.Line = self.Line
		IsEndFunc.Up = self

		Param = new RetFuncParamV2(UnrefFunc,self)
		Param.Up = self

		if IndName != null
		{
			itFunc4 := asNeed.GetFunc("Ind",emptyBox^)
			if itFunc4 == null
			{
				//EmitError("Can not get index item\n")
				self.EnabledIIndex = true
				IndParam = new FuncParam("ForIndex"sbt + self.ItId,GTypeInt,false)
				IndParam.Up = self

				if DebugMode
				{
					self.CreatedIIndexNames.Push(IndName)
				}
			}else{
				test = new ParamNaturalCall("",ForItem->{Object^})
				IndFunc = MakeSimpleCall(itFunc4,test)
				IndParam = new RetFuncParamV2(IndFunc,self)
				IndParam.Up = self
				IndFunc.Line = self.Line
				IndFunc.Up = self
			}
		}
	}
}
