
MetaBoxFor := class extend BoxForOldFashionMulti
{
	deferTookSize := int
	deferVal := int
	deferId := int
	GetDeferUsageVerticalSize := virtual !() -> int
	{
		deferTookSize = 0

		for it : Down
		{
			deferTookSize += it.GetDeferUsageVerticalSize()
		}

		return deferTookSize		
	}
	PrintDeferUse := virtual !(TIOStream f, BoxFuncContainer^ bd,BoxBlock^ blk, int depth,int^ labelIter) -> void
	{
		if deferTookSize == 0
			return void

		Down[^].PrintDeferUse(f,bd,blk,depth,labelIter)
	}
	PrintDeferInBlock := virtual !(TIOStream f, int itId,int^ labelSetIter) -> void
	{
		if deferTookSize == 0
			return void
		deferVal = labelSetIter^
		deferId = itId
		labelSetIter^ += deferTookSize
		Down[^].PrintDeferInBlock(f,itId,labelSetIter)
	}
}
MetaBoxForFields := class extend MetaBoxFor
{
	GetItem := virtual !(char^ name) -> Object^
	{
		return null
	}
	DoTheWork := virtual !(int pri) -> void
	{
		if pri == State_PrePrint
		{
			hldr := Down.Right->{FieldHolder^}
			cType := hldr.MyType
			if not cType is TypeClass
				EmitError("Type is not class")
			cntr := 0
			subBlocks := Object^()
			lastBlock := Object^()
			cls := cType->{TypeClass^}.ToClass
			for par : cls.Params
			{
				newBlock := Down.Clone()
				if subBlocks == null
				{
					subBlocks = newBlock
				}else{
					lastBlock.Right = newBlock
					newBlock.Left = lastBlock
				}
				lastBlock = newBlock
				cntr += 1
			}
			Down = subBlocks
			subBlocks.SetUp(this&)
			for c : cntr 
			{
				itr := Down
				for c itr = itr.Right
				MakeItBlock(itr)
			}
			for it,i : Down, par : cls.Params
			{
				if par.ItName == ""
					continue
				WorkBag.Push(it,State_Start)
				asBlock := it->{BoxBlock^}
				if hldr.Down != null
				{
					asBlock.Items.Push(new ObjHolder(InputItems[0].Name, new FuncParam("ForParamId"sbt + ItId + "i" + i,par.GetType(),true)))
				}else{
					asBlock.Items.Push(new ObjHolder(InputItems[0].Name, new ObjType(par.GetType())))
				}
				if InputItems[0].IndName != null
				{
					asBlock.Items.Push(new ObjHolder(InputItems[0].IndName, new ObjStr(par.ItName)))
				}
			}
			holder = hldr
			hldr.Up = this&
		}
	}
	PrintInBlock := virtual !(TIOStream f) -> void
	{
		cType := holder->{FieldHolder^}.MyType
		cls := cType->{TypeClass^}.ToClass
		if holder.Down != null
		{
			holder.Down.PrintPointPre(f)
			for par,i : cls.Params
			{
				if par.ItName == ""
					continue
				f << "%ForParamId" << ItId << "i" << i << " = getelementptr "
				cType.PrintType(f)
				f << " , "
				holder.Down.PrintPointUse(f)
				f << " , i32 0, i32 "<< cls.GetParamNr(i) <<"\n"
			}
		}
		for it : Down, par : cls.Params
		{
			if par.ItName == ""
				continue
			it.PrintInBlock(f)
		}
	}
}

MetaBoxForClassFuncs := class extend MetaBoxFor
{
	GetItem := virtual !(char^ name) -> Object^
	{
		return null
	}
	DoTheWork := virtual !(int pri) -> void
	{
		if pri == State_PrePrint
		{
			hldr := Down.Right->{MetaClassFuncsHolder^}
			cType := hldr.MyType
			if not cType is TypeClass
				EmitError("Type is not class")
			cntr := 0
			subBlocks := Object^()
			lastBlock := Object^()
			cls := cType->{TypeClass^}.ToClass
			for par : cls.defaultFuncsHolder.methods[^] //TODO + non default
			{
				newBlock := Down.Clone()
				if subBlocks == null
				{
					subBlocks = newBlock
				}else{
					lastBlock.Right = newBlock
					newBlock.Left = lastBlock
				}
				lastBlock = newBlock
				cntr += 1
			}
			Down = subBlocks
			subBlocks.SetUp(this&)
			for c : cntr 
			{
				itr := Down
				for c itr = itr.Right
				MakeItBlock(itr)
			}
			
			iter := Down
			for parList, parName : cls.defaultFuncsHolder.methods
			{
				for par : parList
				{
					WorkBag.Push(iter,State_Start)
					asBlock := iter->{BoxBlock^}
					asBlock.Items.Push(new ObjHolder(InputItems[0].Name, new ObjFuncPointer(par)))
					if InputItems[0].IndName != null
					{
						asBlock.Items.Push(new ObjHolder(InputItems[0].IndName, new ObjStr(parName)))
					}
					iter = iter.Right
				}
			}
			holder = hldr
			hldr.Up = this&
		}
	}
	PrintInBlock := virtual !(TIOStream f) -> void
	{
		for it : Down
		{
			it.PrintInBlock(f)
		}
	}
}
MetaBoxForFuncParams := class extend MetaBoxFor
{
	GetItem := virtual !(char^ name) -> Object^
	{
		return null
	}
	DoTheWork := virtual !(int pri) -> void
	{
		if pri == State_PrePrint
		{
			hldr := Down.Right->{MetaFuncParamsHolder^}
			cType := hldr.MyType
			if not cType is TypeFunc
				EmitError("Type is not function")
			cntr := 0
			subBlocks := Object^()
			lastBlock := Object^()

			pr := cType->{TypeFunc^}
			for i : pr.ParsCount
			{
				newBlock := Down.Clone()
				if subBlocks == null
				{
					subBlocks = newBlock
				}else{
					lastBlock.Right = newBlock
					newBlock.Left = lastBlock
				}
				lastBlock = newBlock
				cntr += 1
			}
			Down = subBlocks
			subBlocks.SetUp(this&)
			for c : cntr 
			{
				itr := Down
				for c itr = itr.Right
				MakeItBlock(itr)
			}
			for it,i : Down
			{
				WorkBag.Push(it,State_Start)
				asBlock := it->{BoxBlock^}
				asBlock.Items.Push(new ObjHolder(InputItems[0].Name, new ObjType(pr.Pars[i])))
			}
			holder = hldr
			hldr.Up = this&
		}
	}
	PrintInBlock := virtual !(TIOStream f) -> void
	{
		//cType := holder->{FieldHolder^}.MyType
		//cls := cType->{TypeClass^}.ToClass
		//if holder.Down != null
		//{
		//	holder.Down.PrintPointPre(f)
		//	for par,i : cls.Params
		//	{
		//		if par.ItName == ""
		//			continue
		//		f << "%ForParamId" << ItId << "i" << i << " = getelementptr "
		//		cType.PrintType(f)
		//		f << " , "
		//		holder.Down.PrintPointUse(f)
		//		f << " , i32 0, i32 "<< cls.GetParamNr(i) <<"\n"
		//	}
		//}
		for it : Down
		{
			it.PrintInBlock(f)
		}
	}
}
