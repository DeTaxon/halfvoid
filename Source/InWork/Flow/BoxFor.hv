GetBoxFor := !(Object^ dat) -> BoxFor^
{

	itemName := string
	indName := string

	itemName = null

	iterY := dat.Down.Right

	Names := @temp new List.{char^}
	indNames := @temp new List.{char^}
	Downs := @temp new List.{Object^}
	if iterY.Right.Right == null
	{
		Names.Push("it")
		Downs.Push(iterY)
		indNames.Push("it_ind")
		iterY = iterY.Right
	}else{
		while iterY.Right != null
		{
			if iterY.Right.GetValue() == ","
			{
				Names.Push(iterY->{ObjIndent^}.MyStr)
				iterY = iterY.Right.Right
				indNames.Push(iterY->{ObjIndent^}.MyStr)
				iterY = iterY.Right.Right
			}else{ // ":"
				Names.Push(iterY->{ObjIndent^}.MyStr)
				iterY = iterY.Right.Right
				indNames.Push(null->{string})
			}
			Downs.Push(iterY)
			iterY = iterY.Right
			if iterY.GetValue() == ","
				iterY = iterY.Right

		}
	}
	preRes :=  new BoxForOldFashionMulti(Names^,indNames^,Downs^,iterY)
	preRes.Line = dat.Down.Line

	return preRes
}

BoxFor := class extend Object
{
}


BoxForOldFashionMulti := class extend BoxFor
{
	ItId := int
	IsStep1 := bool

	itemsCount := int

	InputItems := RawArray.{BoxForItem^}

	attrs := AttrArrayType^

	destroyFuncCount := int

	EnabledIIndex := bool
	CreatedIIndexNames := List.{char^}

	holder := Object^

	endLabel := BoxLabel^

	//BoxForMeta
	deferTookSize := int
	deferVal := int
	deferId := int


	this := !(List.{char^} names, List.{char^} f_ind,List.{Object^} items,Object^ itBlock) -> void
	{
		endLabel = new BoxLabelAnon()
		for items
		{
			if it.IsConst 
				continue
			mayb := TryCompute(it)
			if mayb != null
			{
				oldLine := it.Line
				it = mayb.Clone()
				it.Line = oldLine
			}
		}


		Down = itBlock
		Down.Left = null
		itemsCount = items.Size()
		iter := Down

		for i : itemsCount, itm : items
		{
			iter.Right = itm
			iter.Right.Left = iter
			iter = iter.Right
		}
		iter.Right = null
		Down.SetUp(this&)

		InputItems.Resize(itemsCount)
		InputItems[^] = new BoxForItem

		for it,i : names
			InputItems[i].Name = it
		for it,i : f_ind
			InputItems[i].IndName = it

		WorkBag.Push(this&,State_PreGetUse)

		IsStep1 = true

		ItId = GetNewId()
	}
	useDecorator := bool
	decLambdaCall := Object^
	decLambdaCallFunc := BoxFunc^
	DoTheWork := virtual !(int pri) -> void
	{
		if visitedWork[pri] return void
		else if pri != State_GetUse  visitedWork << pri

		if pri == State_Start
		{
			Down.Line = Line
			WorkBag.Push(this&,State_PreGetUse)
		}
		if pri == State_PreGetUse
		{
			while TryParseMacro(Down.Right,this&) != null {}


			WorkBag.Push(this&,State_GetUse)
			if Left? is ObjTemplateType //DECORATOR
			{
				TType := Left
				cmdName := Left->{ObjTemplateType^}.MyStr
				itBox := new FuncInputBox
				
				bodyL := GetFuncType(![GTypeVoidP],GTypeVoid).GetLambda()
				innerL := GetFuncType(![GTypeVoidP,bodyL],GTypeVoid).GetLambda()
				outerL := GetFuncType(![GTypeVoidP,innerL],GTypeVoid).GetLambda()

				itBox.itPars.Emplace(outerL,false)

				fnc := FindFunc("@"sbt + cmdName + " for",this&,itBox^,false)

				if fnc == null
					EmitError("Decorator not found")

				tmpObj := Object
				lmbd := UNext(this&, new SBoostLambda(),1)->{SBoostLambda^}
				ReplaceNode(lmbd,tmpObj&)
				lmbd.Down = this&
				this.Up = lmbd
				lmbd.ApplyFunc(outerL,false)
				dCall := MakeSimpleCall(fnc,lmbd)
				ReplaceNode(tmpObj&,dCall)


				gotL := lmbd.GetItem("_1")
				assert(gotL != null)
				lCall := new ParamNaturalCall("_1",gotL)

				itBx := @temp new FuncInputBox
				itBx.itPars.Emplace(innerL,false)
				itBx.itPars.Emplace(bodyL,false)

				lCallFunc := GlobalLambdaCall.GetFunc(itBx^)
				assert(lCallFunc != null)

				useDecorator = true
				decLambdaCall = lCall
				decLambdaCallFunc = lCallFunc

			}

			WorkBag.Push(Down.Right[^],State_Start)
		}
		if pri == State_GetUse
		{
			if(Down.Right is FieldHolder) //TODO unify
			{
				asPrm := this&
				asPrm->SetType(MetaBoxForFields)
				WorkBag.Push(this&,State_PrePrint)
				return void
			}
			if(Down.Right is MetaFuncParamsHolder)
			{
				asPrm := this&
				asPrm->SetType(MetaBoxForFuncParams)
				WorkBag.Push(this&,State_PrePrint)
				return void
			}
			if(Down.Right is MetaClassFuncsHolder)
			{
				asPrm := this&
				asPrm->SetType(MetaBoxForClassFuncs)
				WorkBag.Push(this&,State_PrePrint)
				return void
			}
			if(Down.Right is CmdMarkedHolder)
			{
				asPrm := this&
				asPrm->SetType(MetaBoxForMarked)
				WorkBag.Push(this&,State_GetUse)
				return void
			}
		
			if IsStep1
			{
				InputItems.Resize(itemsCount)

				Downs:= @temp new List.{Object^}
				for i : itemsCount
				{
					if Down.Right.GetType() == null
					{
						EmitError("can not evaluate type in for each\n")
					}

					if Down.Right.GetType() is TypeFuncLambda
					{
						Downs.Push(Down.Right)
						PopOutNode(Down.Right)
						continue
					}

					someBox := @temp new FuncInputBox
					someBox.itPars.Emplace(Down.Right.GetType(),Down.Right.IsRef())
					if Down.Right is MetaItemWrapper
					{
						someBox.itMetaPtr = Down.Right->{MetaItemWrapper^}.ptrToBlock
					}


					func := FindFunc("~For",this&,someBox^,false)
					if func == null 
					{
						Down.Right.GetType()
						EmitError("can not load ~For func\n")
						continue
					}
					if func.MyFuncType.RetType == null
					{
						EmitError("can not deduce return type of function ~For\n")
						continue
					}

					rType := func.MyFuncType.RetType

					if rType is TypeFuncLambda
					{
						asFunc := rType.Base->{TypeFunc^}
						if asFunc.RetType == GTypeVoid
							EmitError("Return type of lamda function can not be void")
					}else{
						if (not rType is TypeClass)
							and (not (rType is TypePoint and rType.Base is TypeClass))
						{
							EmitError("~For have to return class or pointer to class\n")
							continue
						}
					}

					InputItems[i].ProxyFunc = func

					tmp := Down.Right
					PopOutNode(tmp)
					preSet := MakeSimpleCall(func,tmp)
					preSet.Line = tmp.Line
					if tmp.Line == null
					{
						tmp.Up.Print(0)
					}
					preSet.Up = this&
					Downs.Push(preSet)
				}

				iter := Down
				iter2 := Downs.Start
				iter = Down
				WorkBag.Push(this&,State_GetUse)
				while iter2 != null //TODO BAD cycle
				{
					iter.Right = iter2.Data
					iter.Right.Left = iter
					iter = iter.Right
					iter2.Data.Up = this&
					iter2 = iter2.Next
					WorkBag.Push(iter,State_GetUse)
				}
				Down.SetUp(this&)
				IsStep1 = false
			}else{
				visitedWork << pri

				if useDecorator
				{
					bodyL := GetFuncType(![GTypeVoidP],GTypeVoid).GetLambda()

					MakeItBlock(Down)
					bodyLambda := UNext(Down, new SBoostLambda(),1)->{SBoostLambda^}
					bodyLambda.ApplyFunc(bodyL,false)

					tmpObj := @temp new Object
					ReplaceNode(Down,tmpObj)
					decLambdaCall.Right = bodyLambda
					bodyLambda.Left = decLambdaCall
					bodyCall := MakeSimpleCall(decLambdaCallFunc,decLambdaCall)
					ReplaceNode(Down,bodyCall)
					//PopOutNode(TType)
					MakeItBlock(Down)
				}
				MakeItBlock(Down)
				WorkBag.Push(Down,State_Start)
				iter := Down.Right
				for i : itemsCount
				{
					if iter.GetType() is TypeFuncLambda
					{
						InputItems[i]->SetType(BoxForItemOnGenerator)
						InputItems[i].Init(this&,iter,iter.GetType(),null)
						iter = iter.Right
						continue
					}
					asNeed2 := iter->{SomeFuncCall^}
					itType := InputItems[i].ProxyFunc.MyFuncType.RetType

					if itType is TypeFuncLambda
					{
						InputItems[i]->SetType(BoxForItemOnGenerator)
					}else{
						InputItems[i]->SetType(BoxForItemOnClass)
					}

					InputItems[i].Init(this&,iter,itType,asNeed2)

					iter = iter.Right
				}
				if InputItems[^].ContainDestroyFunc()
					destroyFuncCount += 1
				if destroyFuncCount != 0
				{
					fnc := GetBoxFuncContainer(this&)
					if fnc != null
					{
						fnc.DoDefer()
					}
				}
			}
		}
	}
	GetItem := virtual !(string name) -> Object^
	{
		for it : InputItems
		{
			if it.Name == name
				return it.Param
			if it.IndName == name
				return it.IndParam
		}
		return null
	}
	
	GetDeferUsageVerticalSize := virtual !() -> int
	{
		return Down.GetDeferUsageVerticalSize()	+ destroyFuncCount
	}
	PrintDeferUse := virtual !(TIOStream f, BoxFuncContainer^ bd,BoxBlock^ blk, int depth,int^ labelIter) -> void
	{
		Down.PrintDeferUse(f,bd,blk,depth,labelIter)

		for itr,i : Down.Right
		{
			if not InputItems[i].ContainDestroyFunc()
				continue

			j := destroyFuncCount - i - 1
			f << "br label %DeferLabel" << labelIter^ << "\n"
			f << "DeferLabel" << labelIter^ << ":\n"

			InputItems[i].PrintDestroyFunc(this&,f,itr,j)

			labelIter^ -= 1
		}
	}

	GetDeferUsage := virtual !() -> int
	{
		val := GetDeferUsageDown()
		if destroyFuncCount != 0
		{
			val = max(val,1)
		}
		return val
	}
	deferId := int
	deferLabel := int
	PrintDeferInBlock := virtual !(TIOStream f, int itId,int^ labelSetIter) -> void
	{
		//Down.Right.PrintDeferInBlock(f,itId,labelSetIter)
		deferId = itId
		deferLabel = labelSetIter^
		labelSetIter^ += Down.GetDeferUsageVerticalSize() + destroyFuncCount
	}
	PrintInBlock := virtual !(TIOStream f) -> void
	{
		debId := -1
		if DebugMode debId = CreateDebugCall(this&)
		
		for itr,i : Down.Right
		{
			InputItems[i].PrintStart(this&,f,itr)
		}


		Checks := 0
		if InputItems[^].IsInvalid != null //TODO Contain
			Checks += 1

		if Checks > 0
		{
			for it : InputItems
			{
				if it.IsInvalid == null
					continue

				it.IsInvalid.PrintPre(f)
				f << "br i1 " << it.IsInvalid.GetName() << ", label %" << endLabel.GetLabel()
				if Checks > 1
				{
					f << ", label %NextCheck" << Checks << "\n"
					f << "NextCheck" << Checks << ":\n"
				}else{
					f << ", label %start" << ItId << "\n" // no need in standart for
					f << "start" << ItId << ":\n"
				}

				Checks -= 1
			}
		}else{
			f << "br label %start" << ItId << "\n" // no need in standart for
			f << "start" << ItId << ":\n"
		}

		createdIInts := @temp new List.{int}

		if debId != -1 for it : CreatedIIndexNames
		{
			newRes := CreateDbgLocVar(Down,GTypeInt,it)
			if newRes != -1
				createdIInts.Push(newRes)
		}

		if EnabledIIndex {
			f << "br label %ExtraStart" << ItId << "\n"
			f << "ExtraStart" << ItId << ":\n"
			f << "%ForIndex" << ItId << " = phi i32 [0,%start" << ItId << "] , [%FIndex" << ItId << ", %ExtraEnd" << ItId << "]\n"

			for it : createdIInts^
			{
				f << "call void @llvm.dbg.value(metadata i32 %ForIndex" << ItId << " ,metadata !" << it << ",metadata !DIExpression()), !dbg !"<<debId<<"\n" 
			}
		}

		
		for it,i : InputItems
		{
			it.PrintStepBefore(this&,f,null,debId)
		}

		InputItems[0].PrintCheckEndPre(this&,f,null)
		f << "br i1 " 
		f << InputItems[0].PrintCheckEndName(this&,null) 
		f << " , label %" << endLabel.GetLabel() << " , label %Next" << ItId << "\n"
		f << "Next" << ItId << ":\n"


		for it,i : InputItems
		{
			it.PrintStepAfter(this&,f,null,debId)
		}
		Down.PrintDeferInBlock(f,deferId,deferLabel&)
		Down.PrintInBlock(f)

		
		f << "br label %IncFuncs" << ItId << "\n"
		f << "IncFuncs" << ItId << ":\n"

		InputItems[^].PrintIncrement(this&,f,null,debId)

		if EnabledIIndex
		{
			f << "br label %ExtraEnd" << ItId << "\n"
			f << "ExtraEnd" << ItId << ":\n"
			f << "%FIndex" << ItId << " = add i32 %ForIndex" << ItId << " , 1\n"
			f << "br label %ExtraStart" << ItId << "\n"
		}else{
			f << "br label %start" << ItId << "\n"
		}

		if labelContinue != null
		{
			labelContinue.PrintLabel(f)
			Down->{BoxBlock^}.PrintDeferInBlockUse(f)
			f << "br label %IncFuncs" << ItId << "\n"
		}
		if labelBreak != null
		{
			labelBreak.PrintLabel(f)
			Down->{BoxBlock^}.PrintDeferInBlockUse(f)
			f << "br label %" << endLabel.GetLabel() << "\n"
		}
		endLabel.PrintLabel(f)
	}

	labelContinue := BoxLabel^
	labelBreak := BoxLabel^

	GetOutPath := virtual !(Object^ itm, int typ, int size) -> BoxLabel^
	{
		if typ == PATH_RETURN or typ == PATH_YIELD
		{
			return Up.GetOutPath(this&,typ,size) //poke
		}
		if typ == PATH_CONTINUE
		{
			if size == 0{
				if labelContinue == null
					labelContinue = new BoxLabelAnon()
				return labelContinue
			}
			return Up.GetOutPath(itm,typ,size - 1)
		}
		if typ == PATH_BREAK
		{
			if size == 0{
				if labelBreak == null
					labelBreak = new BoxLabelAnon()
				return labelBreak
			}
			return Up.GetOutPath(itm,typ,size - 1)
		}
		return null
	}
	GetBadLabel := !(Object^ prebNode) -> Object^
	{
		return endLabel
	}
	GetValue := virtual !() -> string
	{
		return "~~for()"
	}
}


