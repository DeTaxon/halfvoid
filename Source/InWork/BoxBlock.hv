MakeItBlock := !(Object^ item) -> bool
{
	return MakeItBlock(item,true)
}
MakeItBlock := !(Object^ item,bool useStuf) -> bool
{
	if item == null return false
	if item.GetValue() == "{d}" return true
	
	oldUp := item.Up
	oldRight := item.Right
	oldLeft := item.Left

	item.Up = null
	item.Right = null
	item.Left = null

	bloc := new BoxBlock(item)

	item.Up = oldUp
	item.Right = oldRight
	item.Left = oldLeft

	ReplaceNode(item,bloc)

	item.SetUp(bloc)

	bloc.usePaths = useStuf

	return true
}


GetBlock := !(Object^ obj) -> BoxBlock^
{
	itr := obj
	while itr != null
	{
		if itr is BoxBlock
			return itr->{BoxBlock^}
		itr = itr.Up
	}
	return null
}

BoxBlock := class extend WorkObject
{
	GetUseIter := int
	Items := List.{ObjHolder^}
	ItId := int
	
	gotRetPath := bool

	outRLabel := BoxLabel^

	usePaths := bool

	gcObjects := HybridQueue.{int,8}
	AddGC := !(int varId) -> void
	{
		gcObjects.Push(varId)
		if gcObjects.Size() == 1
		{
			fnc := GetBoxFuncContainer(this&)
			if fnc != null
			{
				fnc.DoDefer()
				WorkBag.Push(Down,State_Start)
			}
		}
	}

	this := !() -> void
	{
		ItId = GetNewId()
	}
	this := !(Object^ toRepl) -> void
	{
		quitPath."this"()
		ItId = GetNewId()
		if toRepl.GetValue() == "{}"
		{	
			Down = toRepl.Down
		}else
		{
			Down = toRepl
		}
		if Down != null Down.SetUp(this&)
		Line = toRepl.Line
	}
	RecursMake := !() -> void
	{
			woot := @temp List.{Object^}

			if Down[^].GetValue() == "{}"
				woot.Push(it)
			MakeItBlock(woot^[^])
	}
	GetItem := virtual !(string name) -> Object^
	{
		if Items[^].ItName == name
			return it.Down
		return null
	}
	GetValue := virtual !() -> string
	{
		return "{d}"
	}
	GetScope := virtual !() -> int { 
		if Up == null or Up.GetScope() <= 0
			return -1
		return ItId 
	}
	needDeferCall := !() -> bool
	{
		if gcObjects.Size() != 0
			return true
		if deferDepth != 0
			return true
		return false
	}
	PrintGlobal := virtual !(TIOStream f) -> void 
	{
		if gcObjects.Size() != 0
		{
			aBox := AllocBox^()
			itr := Up
			while itr != null
			{
				aBox = itr.GetABox()
				if aBox != null
					break
				itr = itr.Up
			}

			f << "define void @BlockGCCleanUp" << ItId << "(i8* %StackObj)\n"
			f << "{\n"
			f << "%AllcObj = bitcast i8* %StackObj to " << aBox.GetClassName() << "*\n"
			aBox.PrintBoxItems(f,"%AllcObj",-1)
			for it,i : gcObjects
			{
				typ := aBox.GetObjType(it)
				tn := typ.GetName()
				f << "br label %Start" << i << "\n"
				f << "Start" << i << ":\n"
				f << "%LD" << it << " = load " << tn << " , " << tn << "* %T" << it << "\n"
				f << "%AsVoidP" << i << " = bitcast " << tn << " %LD"<<it<<" to i8*\n"
				f << "call void @" << gcDecRefFunc.OutputName << "(i8* %AsVoidP" << i << ")\n"
				f << "store " << tn << " null, " << tn << "* %T" << it << "\n"
				f << "br label %End" << i << "\n"
				f << "End"<<i<<":\n"
			}
			f << "ret void\n}\n"
		}

		if needDeferCall()
		{
			deferCount := 0
			itrR := Down
			while itrR.Right != null
			{
				deferCount += itrR.GetDeferUsageVerticalSize()
				itrR = itrR.Right
			}
			deferCount += itrR.GetDeferUsageVerticalSize()

			blkDepth := 0
			itrUp := Up
			while not IsBoxFuncContainer(itrUp)
			{
				if itrUp is BoxBlock
				{
					blkDepth += 1
				}
				itrUp = itrUp.Up
				assert(itrUp != null)
			}
			deferUpDepth = blkDepth
			cntr := itrUp->{BoxFuncContainer^}
			f << "define void @BlockDeferCall" << ItId << "(i8* %StackObj,i1 %isException)\n"
			f << "{\n"
			f << "%StackObjABox = bitcast i8* %StackObj to %AllocClass" << cntr.ABox.ItId << "*\n"
			cntr.PrintABoxData(f,"%StackObjABox",-1)

			f << "%DeferValPtr = getelementptr i8 , i8* %DeferStack , i32 " << blkDepth << "\n"
			f << "%DeferVal = load i8, i8* %DeferValPtr\n"
			f << "switch i8 %DeferVal , label %DeferLabel0 [\n"
			for i : (deferCount+1)
			{
				f << "	i8 " << i << " , label %DeferLabel" << i << "\n"
			}
			f << "]\n"

			val := deferCount
			while itrR != null
			{
				itrR.PrintDeferUse(f,cntr,this&,blkDepth,val&)
				itrR = itrR.Left
			}

			f << "br label %DeferLabel0\n"
			f << "DeferLabel0:\n"
			f << "store i8 0, i8* %DeferValPtr\n"

			if gcObjects.Size() != 0
				f << "call void @BlockGCCleanUp" << ItId << "(i8* %StackObj)\n"

			f << "	ret void\n"
			f << "}\n"
		}

		
		PrintGlobalSub(f)
		if DebugMode
		{
			if Up != null
			{
				itr := Up
				while itr.Up != null
					itr = itr.Up
				if itr != null and itr is BoxFile
				{
					f << "!" << ItId << " = !DILexicalBlock(scope: !" 
					f << Up.GetScope() << ", file: !" << itr.GetScope()
					if Line != null
					{
						f << ", line: " << Line.LinePos
					}
					f << ")\n"
				}
			}
//!20 = distinct !DILexicalBlock(scope: !16, file: !1, line: 6, column: 2)
		}
	}
	PrintSomePath := !(TIOStream f, string PathName, int num,string OutName) -> void
	{
		for iter,i : Down
		{
			f << PathName << num << "in" << i << ":\n"
			iter.PrintDestructor(f)
			if i == 0{
				f << "br label %" << OutName << "\n"
			}else{
				f << "br label %" << PathName << num << "in" << i - 1 << "\n"
			}
		}
	}
	PrintInBlock := virtual !(TIOStream f) -> void
	{
		if Line == null Line = Up.Line

		if gcObjects.Size() != 0 
		{
			cntr := GetBoxFuncContainer(this&)
			aBox := cntr.GetABox()
			for gcObj : gcObjects
			{
				typName := aBox.GetObjType(gcObj).GetName()
				f << "store "<<typName<<" null, "<<typName<<"* %T" << gcObj << "\n"
			}
		}

		if needDeferCall()
		{
			f << "store i8 0, i8* %DeferStack"<< deferUpDepth <<"\n"
		}
		
		defVal := 1
		for iter,i : Down
		{
			CodeBeforeLineCall(f,i)
			iter.PrintDeferInBlock(f,deferUpDepth,defVal&)
			iter.PrintInBlock(f)
			CodeAfterLineCall(f,1)
		}


		if needDeferCall()
		{
			PrintDeferInBlockUse(f)
		}

		if usePaths {
			f << "br label %" << quitPath.GetLabel() << "\n"

			if preRetLabel != null
			{
				preRetLabel.PrintLabel(f)
				if gotRetPath f << "br label %" << outRLabel.GetLabel() << "\n"
				
			}

				//if gotRetPath PrintSomePath(f,"RetPath",ItId,outRName)
			if gotRetPath f << "br label %" << outRLabel.GetLabel() << "\n"
			//f << "LastContPath" <<ItId << ":\n"
			quitPath.PrintLabel(f)
		}
	}
	LoadOutPath := !() -> void
	{
		if outRLabel == null{
			if Up != null{
				outRLabel = Up.GetOutPath(this&,PATH_RETURN,1)
			}else{
				EmitError("software error 311653\n")
			}
		}
	}
	preRetLabel := BoxLabel^
	quitPath := BoxLabelAnon
	GetOutPath := virtual !(Object^ objs, int typ , int size) -> BoxLabel^
	{
		if not usePaths
		{
			if Up == null return null
			return Up.GetOutPath(objs,typ,size)
		}
		if typ == PATH_YIELD
		{
			return Up.GetOutPath(objs,typ,size)
		}

		if typ == PATH_RETURN
		{
			LoadOutPath()

			gotRetPath = true

			if Up?.GetValue() in !["!()","{!()}","x=>x"]
			{	
				if preRetLabel == null preRetLabel = new BoxLabelAnon()
				return preRetLabel
			}
			return outRLabel
		}
		if typ == PATH_BREAK || typ == PATH_CONTINUE
		{
			if size == 0 {
				return quitPath&
			}
			return Up.GetOutPath(objs,typ,size - 1)
		}
		return null
	}
	deferDepth := int
	deferUpDepth := int
	GetDeferUsageVerticalSize := virtual !() -> int
	{
		if needDeferCall()
			return 1
		return 0
	}
	PrintDeferInBlock := virtual !(TIOStream f, int id,int^ labelSetIter) -> void
	{
		if not needDeferCall()
			return void
		f << "store i8 " << labelSetIter^ << ", i8* %DeferStack"<<id <<"\n"
		labelSetIter^ += 1
	}
	GetDeferUsage := virtual !() -> int
	{
		for itr : Down
		{
			c := itr.GetDeferUsage()
			if c != 0
			{
				if c > deferDepth
					deferDepth = c
			}
		}
		val := deferDepth
		if gcObjects.Size() != 0
		{
			val = max(val,1)
		}
		if val == 0
			return 0
		return val + 1
	}
	PrintDeferInBlockUse := !(TIOStream f) -> void
	{
		if not needDeferCall()
			return void
		f << "call void @BlockDeferCall" << ItId << "(i8* %StackObj,i1 0)\n" 
	}
	PrintDeferUse := virtual !(TIOStream f, BoxFuncContainer^ bd,BoxBlock^ blk, int depth,int^ labelIter) -> void
	{
		if not needDeferCall()
			return void
		curId := labelIter^
		labelIter^ -= 1

		f << "br label %DeferLabelSkip" <<curId << "\n"
		f << "br label %DeferLabel" << curId << "\n"
		f << "DeferLabel" << curId << ":\n"
		f << "call void @BlockDeferCall" << ItId << "(i8* %StackObj,i1 %isException)\n" 
		f << "br label %DeferLabelSkip" <<curId << "\n"
		f << "DeferLabelSkip" << curId << ":\n"
	}
	PrintBlockAddDefer := !(TIOStream f,int debId) -> void
	{
		if not needDeferCall()
			return void
		PrintAddDefer(f, "@BlockDeferCall"sbt + ItId ,"%StackObj",debId)
		//f  << "call void @" << deferAddDefer2.OutputName << "(void(i8*,i1)* @BlockDeferCall" << ItId << ",i8* %StackObj)"

		//if debId{
		//	f << " , !dbg !" << debId
		//}
		//f << "\n"
	}
	SetClassBlock := !() -> void
	{
		this&->SetType(BoxBlockClass)
	}
	DoTheWork := virtual !(int pri) -> void
	{
		if pri == State_Start
		{
			WorkBag.Push(this&,State_Syntax)
			if IsClassObj(Up?)
			{
				SetClassBlock()
			}
			//if Up.GetValue() == "~switch()" RecursMake()
			//if (not InClass and (Up.GetValue() == "{d}" or Up.GetValue() == "~switch()")) RecursMake()
		}
		if pri == State_Syntax
		{
			SyntaxCompress(this&,PriorityData)

			UnboxParams(this.Down)
			WorkBag.Push(this&,State_GetUse)

			itr := Down
			while itr != null
			{
				if (not itr is in ObjData) and itr.GetValue() != "?or??" and itr.GetValue() != "return()" and not (itr is QJumpLand){ //TODO: wut is dat
				//if (not itr is ObjData) and itr.GetValue() != "?or??"{
					itr = itr.Right
					continue
				}

				tstNode := TryParseMacro(itr)
				switch tstNode
				{
					case MacroRestart itr = Down
					case null itr = itr.Right
					case void itr = tstNode
				}
			}
		}
		if pri == State_GetUse
		{
			iter := Down

			for GetUseIter
				if iter != null iter = iter.Right
			if iter != null
			{
				WorkBag.Push(this&,State_GetUse)
				WorkBag.Push(iter,State_Start)
				GetUseIter += 1
			}else{
				WorkBag.Push(this&,State_DestructCheck)
			}
		}
	}

	CodeBeforeLineCall := virtual !(TIOStream f, int num) -> void
	{
	}
	CodeAfterLineCall := virtual !(TIOStream f, int num) -> void
	{
	}
}

PATH_RETURN := 1
PATH_YIELD := 2
PATH_CONTINUE := 3
PATH_BREAK := 4
