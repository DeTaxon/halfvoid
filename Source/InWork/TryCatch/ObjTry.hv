
expEnter := BoxFunc^
expLeave := BoxFunc^
expGetPoint := BoxFunc^


ExceptionInit := !() -> bool
{


	dummy := @temp new Object
	box := @temp new FuncInputBox

	entr := FindFunc("internalEnterTry",dummy,box^,false)
	if entr == null return false
	entr.ParseBlock()
	expEnter = entr

	lev := FindFunc("internalLeaveTry",dummy,box^,false)
	if lev == null return false
	lev.ParseBlock()
	expLeave = lev

	getPr := FindFunc("internalGetExceptPoint",dummy,box^,false)
	if getPr == null return false
	getPr.ParseBlock()
	expGetPoint = getPr

	return true
}

ParseTry := !(Object^ itm) -> Object^
{
	if itm.Down == null return null

	if itm.Down.GetValue() == "try" return new ObjTry(itm)

	return null
}

ObjTry := class extend ObjTryCommon
{
	exName := char^
	exType := Type^
	exParam := MemParam^
	this := !(Object^ itm) -> void
	{
		ItId = GetNewId()
		PopOutNode(itm.Down)
		PopOutNode(itm.Down.Right)
		Down = itm.Down
		Down[^].Up = this&
		WorkBag.Push(this&,State_Start)
		Line = itm.Line
	}
	DoTheWork := virtual !(int st) -> void
	{
		if st == State_Start
		{
			WorkBag.Push(this&,State_Syntax)
		}
		if st == State_Syntax
		{
			SyntaxCompress(Down.Right,LexHVInputVars)
			WorkBag.Push(this&,State_PreGetUse)
		}
		if st == State_PreGetUse
		{
			objP := Down.Right
			if objP.Down == null
			{
				EmitError("empty catch not allowed, try \"IException^ e\"")
				return void
			}
			if objP.Down.Right == null and objP.Down is ObjIndent
			{
				exName = objP.Down->{ObjIndent^}.MyStr
				exType = @once ParseType(new ObjIndent("IException")).GetPoint() //TODO @temp on indent
				if exType == null
					EmitError("internal error, IException not found")
			}else{
				if objP.Down.Right == null
				{
					EmitError("one obj in catch not allowed, try \"IException^ e\"")
					return void
				}
				exType = ParseType(objP.Down)
				if exType == null or (not exType is TypePoint)
				{
					EmitError("can not parse type in catch, or is not point")
					return void
				}
				if not objP.Down.Right is ObjIndent
				{
					EmitError("second object in catch must be indentificator\n")
					return void
				}
				asInd := objP.Down.Right->{ObjIndent^}
				exName = asInd.MyStr
			}

			exParam = new FuncParam("I"sbt + ItId,exType,false)

			MakeItBlock(Down)
			MakeItBlock(Down.Right.Right)
			WorkBag.Push(Down,State_Start)
			WorkBag.Push(Down.Right.Right,State_Start)
		}
	}
	GetItem := virtual !(char^ name) -> Object^
	{
		if name == exName
		{
			return exParam
		}
		return null
	}
	PrintInBlock := virtual !(TIOStream f) -> void
	{
		debId := -1
		if DebugMode
		{
			debId = CreateDebugCall(this&)
		}

		PrintStart(f,debId)

		f << "OnGood" << ItId << ":\n"
		Down.PrintDeferInBlock(f,deferId,deferVal&)
		Down.PrintInBlock(f)
		f << "br label %OnEnd" << ItId << "\n"
		f << "OnBad" << ItId << ":\n"

		f << "call void @" << expLeave.OutputName << "()"
		if debId != -1
		{
			f << ", !dbg !" << debId
		}
		"\n"

		if exName != null
		{
			f << "%IPre" << ItId << " = call i8* @" << expGetPoint.OutputName << "()"
			if debId != -1 f << ", !dbg !" << debId
			f << "\n"
			f << "%I" << ItId << " = bitcast i8* %IPre" << ItId << " to " << exType.GetName() << "\n"
		}

		Down->{BoxBlock^}.PrintDeferInBlockUse(f)
		Down.Right.Right.PrintDeferInBlock(f,deferId,deferVal&)
		Down.Right.Right.PrintInBlock(f)
		f << "br label %OnLastEnd" << ItId << "\n"

		f << "OnEnd" << ItId << ":\n"
		f << "call void @" << expLeave.OutputName << "()"
		if debId != -1
		{
			f << ", !dbg !" << debId
		}
		"\n"
		f << "br label %OnLastEnd" << ItId << "\n"
		f << "OnLastEnd" << ItId << ":\n"
	}
	deferTookSize := int
	deferVal := int
	deferId := int
	GetDeferUsageVerticalSize := virtual !() -> int
	{
		deferTookSize = Down.GetDeferUsageVerticalSize()
		deferTookSize += Down.Right.Right.GetDeferUsageVerticalSize()
		return deferTookSize		
	}
	PrintDeferUse := virtual !(TIOStream f, BoxFuncContainer^ bd,BoxBlock^ blk, int depth,int^ labelIter) -> void
	{
		if deferTookSize == 0
			return void

		Down.Right.Right.PrintDeferUse(f,bd,blk,depth,labelIter)
		Down.PrintDeferUse(f,bd,blk,depth,labelIter)
	}
	PrintDeferInBlock := virtual !(TIOStream f, int itId,int^ labelSetIter) -> void
	{
		if deferTookSize == 0
			return void
		deferVal = labelSetIter^
		deferId = itId
		labelSetIter^ += deferTookSize
	}
}
