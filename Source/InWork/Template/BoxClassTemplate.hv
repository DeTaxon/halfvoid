
BoxClassTemplate := class extend Object
{
	ItClasses := AVLMap.{int,Stack.{BoxClass^}}
	ClassTree := Object^
	ConstTree := Object^
	ExtendTree2 := HybridQueue.{Object^,4}

	relAttrs := QueueSet.{string}

	this := !(Object^ tree,Object^ txt) -> void
	{
		ClassTree = tree.Clone()
		ClassTree.SetUp(this&)

		ConstTree = ClassTree.Down.Right.Right

		PopOutNode(ClassTree.Down.Right)		
		PopOutNode(ClassTree.Down.Right)
		ConstTree.SetUp(this&)

		if ClassTree.Down.Right.GetValue() == "extend"
		{
			PopOutNode(ClassTree.Down.Right)
			ExtendTree2.Push(ClassTree.Down.Right.Clone())
			PopOutNode(ClassTree.Down.Right)

			while ClassTree.Down.Right.GetValue() == ","
			{
				PopOutNode(ClassTree.Down.Right)
				ExtendTree2.Push(ClassTree.Down.Right.Clone())
				PopOutNode(ClassTree.Down.Right)
			}
		}

		SyntaxCompress(ConstTree,PriorityData)
		MakeGoodConsts(ConstTree)

		for ite : ClassTree.Down.Right.Down
		{
			if ite.GetValue() == "~ind"
			{
				asInd := ite->{ObjIndent^}
				if asInd.MyStr[0] == '$'
					relAttrs.Push(asInd.MyStr)
			}
		}
	}
	GetItem := virtual !(string name) -> Object^
	{
		return null
	}
	GetClass := !(FuncInputBox itBox) -> TypeClass^
	{
		itHash := itBox.GetConstsHash()
		if ItClasses[itHash][^].IsSameConsts(itBox)
			return it.ClassType

		newConsts := @temp new List.{ObjConstHolder^}
		if not IsEqConsts(ConstTree,itBox,newConsts^)
		{
			return null
		}

		newTree := ClassTree.Clone()
		newTree.Up = this&
		
		inher := BoxClass^()

		treeIter := newTree.Down.Right
		
		newEx := @temp new List.{Object^}

		for exT : ExtendTree2
		{
			newEx.Push(exT.Clone())
		}
		newClass := new BoxClass(treeIter,newEx^)
		newClass.Up = this&

		for exT : newEx^
		{
			exT.Up = newClass
		}

		newClass.Right = Down
		if Down != null Down.Left = newClass
		Down = newClass
	

		newClass.ItConsts.Push(itBox.itConsts[^])
		newClass.ItVals.Push(newConsts^[^])
		
		templs := Queue.{QueueSet.{string}^}() ; $temp
		templs.Push(this.relAttrs&)
		
		for itr,itrK : itBox.itAttrs
		{
			for templs
			{
				if it.Contain(itrK)
				{
					newClass.ItAttrs[StrCopy(itrK)] = itr
				}
			}
		}

		ItClasses[itHash].Push(newClass)
		return newClass.ClassType
	}
	GetValue := virtual !() -> string
	{
		return "!{}{...}"
	}
	PrintInBlock := virtual !(TIOStream f) -> void
	{
	}
}
