Files := Queue.{BoxFile^}
ZipFiles := Queue.{BoxFile^}

FilesInRepo := AVLMap.{vRepoFile^,BoxFile^}

LoadFile := !(string name,Object^ start) -> BoxFile^
{
	if start == null return null
	iter := start
	while iter.Up != null iter = iter.Up

	asF := iter->{BoxFile^}
	prePath := ""sbt + asF.filePath.itStr
	prePath2 := ""sbt + Path(prePath).FolderName()
	prePath2 << "/" << name
	newPath := Path(prePath2).FullPath()

	return LoadFile(Path(StrCopy(newPath.Get())))
}
LoadFile := !(Path fullName) -> BoxFile^
{
	vFile := gRepo.GetFile(fullName.Get())
	if vFile != null
	{
		return LoadFile(vFile)
	}

	for Files
	{
		if it.filePath == fullName
			return it
	}
	//printf("loading %s\n",fullName.itStr)
	//#critical_atomic
	ob := GetObjectsFromFile2(fullName)->{BoxFile^}

	if ob == null 
	{
		ErrorLog.Push("file "sbt + fullName.itStr +" not found\n")
		return null
	}

	Files.Push(ob)
	ob.cs = InfiniteCodeSpace
	return ob
}
LoadFile := !(vRepoFile^ file) -> BoxFile^
{
	if FilesInRepo.Contain(file)
		return FilesInRepo[file]
	
	fPath := StrCopy(file.GetPath())
	ptr := file.Map()
	//defer file.Unmap()
	ob := GetObjectsFromMemory(Path(fPath),ptr,file.Size())

	FilesInRepo[file] = ob
	Files.Push(ob)
	ob.filePath = fPath
	ob.cs = InfiniteCodeSpace
	return ob
}
LoadZipFile := !(Path fullName,List.{void^} res,List.{char^} suf) -> void
{
	newZip := @temp new ZipFile
	newZip.AnalizeFile(fullName.itStr)
	defer newZip.DecUser()
	for fil : newZip^
	{
		if fil.realSize == 0
			continue
		shouldUse := false
		for s : suf
		{
			sLen := StrSize(s)
			if fil.fullName.Size() >= sLen and fil.fullName[-sLen..0] == s
			{
				shouldUse = true
				break
			}
		}
		if not shouldUse
			continue
			
		itPtr := fil.Map()
		itNamePre := ""sbt << fullName.itStr << "/" << fil.fullName.Str()
		itName := itNamePre.Str()
		ob := GetObjectsFromMemory(Path(itName),itPtr->{char^},fil.realSize)
		res.Push(ob)
		ZipFiles.Push(ob)
		fil.Unmap()
	}

}

ImportCmd := class extend Object
{
	toImport := string
	toPoint := BoxFile^
	this := !(string toAdd) ->void
	{
		toImport = toAdd
		WorkBag.Push(this&,State_Load)
	}
	GetValue := virtual !() -> string
	{
		return "#import cp"
	}
	GetFile := !() -> BoxFile^
	{
		if toPoint == null
		{
			toPoint = LoadFile(toImport,this&)

			if toPoint == null
			{
				ErrorLog.Push("file "sbt + toImport + " not found\n")
			}
		}
		return toPoint
	}
	DoTheWork := virtual !(int pri) -> void
	{
		if toPoint == null
		{
			toPoint = LoadFile(toImport,this&)
			if toPoint != null
			{
				WorkBag.Push(toPoint,State_Start)
			}
		}
		if Up != and Up is BoxFile{
			asNeed := Up->{BoxFile^}
			asNeed.ImportingFiles.Push(toPoint)
		}
	}
}


