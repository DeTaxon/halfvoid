
jitMode := false

internalMemset := BoxFunc^

passJITFuncs := AVLMap.{char^,Tuple.{Type^,MemParam^}}

JITPreInit := !() -> void
{
	if not jitMode
		return void

	addJITFunction("TSleep",TSleep->{void^},![GTypeDouble],GTypeVoid)
	addJITFunction("TExpectWorkers",TExpectWorkers->{void^},![GTypeInt],GTypeVoid)

	addJITFunction("TPauseTask",TPauseTask->{void^},![GTypeInt.GetPoint()],GTypeVoid)
	addJITFunction("TResumeTask",TResumeTask->{void^},![GTypeInt],GTypeVoid)
	addJITFunction("TExpectWorkers",TExpectWorkers->{void^},![GTypeInt],GTypeVoid)


	lType := GetFuncType(![GTypeVoidP],GTypeVoid).GetLambda()
	addJITFunction("TSpawnTask",TSpawnTask->{void^},![lType],GTypeVoid)
	addJITFunction("TAwaitWork",TAwaitWork->{void^},![lType],GTypeVoid)

	//addJITFunction("TFullInit",_blankFunc->{void^},GTypeVoid)

	addJITFunc("TFullInit",_blankFunc)
	//addJITFunc("TAwaitManyWorks",TAwaitManyWorks)

	if $posix
	{
		addJITFunction("stat",stat->{void^},![GTypeChar.GetPoint(),GTypeVoidP],GTypeInt)
		addJITFunction("lstat",lstat->{void^},![GTypeChar.GetPoint(),GTypeVoidP],GTypeInt)
		addJITFunction("fstat",fstat->{void^},![GTypeInt,GTypeChar.GetPoint()],GTypeInt)
	}
}

getTypeJIT := !() .{@T} -> Type^
{
	if T->Group == "Func"
	{
		pars := @temp new List.{Type^}
		for par : T->Params
		{
			pars.Push(getTypeJIT().{par})
		}
		return GetFuncType(@temp pars.ToArray(),null,pars.Size(),getTypeJIT().{T->ResultType},false,false,false)
		//return GetFuncType(GTypeVoid)
	} else if T->Group == "Prime"
	{
		return GetType(T->Name)
	} else if T->Group == "Pointer"
	{
		return GetType(T->Name).GetPoint()
	} else if T->Group == "Array"
	{
		404 = true
		assert(false)
	} else if T->Group == "Class"
	{
		404 = true
		assert(false)
	}
}

addJITFunc := !(char^ name, @T func) -> void
{
	funcType := getTypeJIT().{T->Base}
	funcTypePtr := funcType.GetPoint()
	funcPar := new GlobalParam(funcTypePtr,new ObjPointer(func->{void^},funcTypePtr))
	passJITFuncs[name] = !{funcType,funcPar}
}

addJITFunction := !(char^ name ,void^ fPoint, Type^[@ArrSize] inps,Type^ outType) -> void
{
	sleepType := GetFuncType(inps,outType)
	sleepTypePtr := sleepType.GetPoint()
	sleepPar := new GlobalParam(sleepTypePtr,new ObjPointer(fPoint->{void^},sleepTypePtr))
	passJITFuncs[name] = !{sleepType,sleepPar}
}
addJITFunction := !(char^ name ,void^ fPoint,Type^ outType) -> void
{
	sleepType := GetFuncType(outType)
	sleepTypePtr := sleepType.GetPoint()
	sleepPar := new GlobalParam(sleepTypePtr,new ObjPointer(fPoint->{void^},sleepTypePtr))
	passJITFuncs[name] = !{sleepType,sleepPar}
}

JITInit := !() -> void
{
	box := @temp new FuncInputBox
	box.itPars.Emplace(GTypeVoidP,false)
	box.itPars.Emplace(GTypeSizeT,false)

	internalMemset = FindFunc("internalGCMemClear",null,box^,false)
	assert(internalMemset != null)

	if not jitMode
		return void

	rp := GetItem("gRepo",null)
	if rp?.Down != null
	{
		rp.Down.Down = new ObjPointer(gRepo,rp.GetType())
		rp.Down.Down.Up = rp.Down
	}

	tb := GetItem("CurrentTaskBox",null)
	if tb?.Down != null
	{
		tb.Down.Down = new ObjPointer(CurrentTaskBox,tb.GetType())
		tb.Down.Down.Up = tb.Down
	}

}
JITPrint := !(TIOStream f) -> void
{
	if not jitMode
		return void
	for it : passJITFuncs
	{
		it.1.PrintGlobal(f)
	}
}
_blankFunc := !() -> void
{
	//printf("not blank\n")
}
