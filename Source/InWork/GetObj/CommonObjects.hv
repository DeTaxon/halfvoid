GetItem := !(string name, Object^ start) -> Object^
{
	 stuf := QueueSet.{int}()
	 return GetItem2(name,start,stuf)
}
GetItem2 := !(string name, Object^ start,QueueSet.{int} Searched) -> Object^
{
	if jitMode 
	{
		if passJITFuncs.Contain(name)
		{
			return passJITFuncs[name].1
		}
	}

	iter := start
	while iter != null
	{
		if iter is in ObjParam
		{
			AsNeed := iter->{ObjParam^}
			if (AsNeed.MyStr == name) {
				if (not AsNeed.AskedGetUse) and AsNeed.IsFunc WorkBag.Push(iter,State_GetUse)
				return iter
			}
		}else
		if iter is TypeDef //iter.GetValue() == ":=type"
		{
			asDef := iter->{TypeDef^}
			if asDef.ItName == name return iter
		}else
		if iter.GetValue() == "(const)"
		{
			asC := iter->{ConstItem^}
			if asC.Name == name return iter
		}else
		if iter is ImportCmd //iter.GetValue() == "#import cp"
		{
			asN := iter->{ImportCmd^}
			fl := asN.GetFile()
			res := fl.VisibleParams.TryFind(name)
			if res != null {
				return res^[0]
			}


			Fnd := Searched.Contain(fl.fileId)

			if not Fnd
			{
				Searched.Push(fl.fileId)
				notSure := fl.Down

				if notSure != null
				{
					while notSure.Right != null
						notSure = notSure.Right
				}

				res := GetItem2(name,notSure,Searched)
				if res != null return res
			}
		}else if iter.Up? is BoxClass and name[0] == '$' //TODO maybe: work with append
		{
			asCl := iter.Up->{BoxClass^}
			resObj := asCl.ItAttrs.TryFind(name)
			if resObj != null
				return resObj^

		}


		if iter.Left != null iter = iter.Left 
		else
		{
			iter = iter.Up


			if iter != null
			{
				ItTp := iter.GetItem(name)
				if ItTp != null return ItTp
			}
		}
	}
	for SomeDef : DefsTable
	{
		if SomeDef?.ItName == name 
		{
			return SomeDef->{Object^}
		}
	}

	for itCS : CodeSpaces.Reverse
	{
		for itLib : itCS.codeLibs
		{
			res := itLib.VisibleParams.TryFind(name)
			if res != null return res^[0]
		}
	}
	for Modules {
		inMod := it.GetItem(name)
		if inMod != null return inMod
	}
	if GlobalDataBuiltins.Contain(name)
		return GlobalDataBuiltins[name]
	return null
}



ReplaceNode := !(Object^ what, Object^ with) -> Object^
{
	wiEnd := with

	while wiEnd.Right != null 
	{
		wiEnd.Up = what.Up
		wiEnd = wiEnd.Right
		if wiEnd.Line == null wiEnd.Line = what.Line
	}
	if wiEnd.Line == null wiEnd.Line = what.Line
	wiEnd.Up = what.Up

	if what.Left == null
	{
		if what.Up != null
		{
			what.Up.Down = with
		}
		with.Left = null
	}else{
		with.Left = what.Left
		with.Left.Right = with
	}

	wiEnd.Right = what.Right
	if wiEnd.Right != null wiEnd.Right.Left = wiEnd

	with.SetUp(what.Up)

	what.Up = null
	what.Left = null
	what.Right = null

	return with
}



SomeId := int
GetNewId := !() -> int
{
	SomeId += 1
	return SomeId
}

