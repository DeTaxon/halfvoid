
NaturalCall := class extend SomeFuncCall
{
	gcObjId := int

	copiedInputs := AVLMap.{int,int}

	this := !(BoxFunc^ func, Object^ Pars) -> void 
	{
		if Pars != null
		{
			Line = Pars.Line
		}
		if func.IsPassAttrs and Pars != null
		{
			inhAttrs = Pars.inhAttrs
		}
		Down = Pars
		
		RetId = GetNewId()
		ToCall = func
		if Pars != null Pars.SetUp(this&)
		if Pars != null TrimCommas(Down.Up)
		
		ToCall = ToCall.GetWrappedFunc()
		FType = ToCall.MyFuncType

		WorkBag.Push(this&,State_PreGetUse)
		WorkBag.Push(this&,State_MiddleGetUse)
	}
	
	PrintPreFuncName := virtual !(TIOStream f) -> void
	{

	}
	PrintFuncName := virtual !(TIOStream f) -> void
	{
		if ToCall != null
		f << "@" << ToCall.OutputName
	}

	PrintParamPres := virtual !(TIOStream f) -> void
	{
		RefsArr := FType.ParsIsRef
		for iter,i : Down
		{
			if RefsArr[i] iter.PrintPointPre(f)
			else iter.PrintPre(f)

			if copiedInputs.Contain(i) 
			{
				if ToCall.MyFuncType.ParsIsRef[i]
				{
					f << "store "
					iter.PrintPointUse(f)
					f << " , "
					iter.GetType().PrintType(f)
					f << "** %T" << copiedInputs[i] 
				}else{
					f << "store "
					iter.PrintUse(f)
					f << " , "
					iter.GetType().PrintType(f)
					f << "* %T" << copiedInputs[i] 
				}|
			}
		}
	}
	PrintCopiedPres := virtual !(TIOStream f) -> void
	{
		for iter,i : Down
		{
			if copiedInputs.Contain(i)
			{
				tId := copiedInputs[i]
				tpName := iter.GetType().GetName()
				if ToCall.MyFuncType.ParsIsRef[i]
					tpName = iter.GetType().GetPoint().GetName()
				f << "%TL" << tId << " = load " << tpName << " , " << tpName << "* %T" << tId << "\n"
			}
		}
	}
	PrintParamUses := virtual !(TIOStream f) -> void
	{
		PrintParamUsesInner(f,null)
	}
	PrintParamUsesInner := virtual !(TIOStream f,TypeFunc^ inFType) -> void
	{
		iter := Down
		RefsArr := FType.ParsIsRef

		i := 0
		if gotAlloc and not IsConstr
		{
			f << ToCall.MyFuncType.RetType.GetName() << "* "
			f << TName
			if iter != null f << " , "
			//i += 1
		}
		while iter != null
		{
			if inFType != null and i >= inFType.ParsCount and not inFType.IsVArgs
				break
			if i > 0  f << " , "

			if copiedInputs.Contain(i)
			{
				tId := copiedInputs[i]
				tpName := iter.GetType().GetName()
				if RefsArr[i]
					tpName = iter.GetType().GetPoint().GetName()
				f << tpName  << " %TL" << tId
			}else{
				if RefsArr[i] iter.PrintPointUse(f)
					else iter.PrintUse(f)
			}
			iter = iter.Right
			i += 1
		}
	}

	UseCall := virtual !(TIOStream f) -> void
	{
		PrintPreFuncName(f)
		PrintParamPres(f)

		UseCallInner(f,ToCall,true)
	}
	UseCallInner := virtual !(TIOStream f,BoxFunc^ callFunc,bool printPres) -> void
	{
		PrintCopiedPres(f)

		if (callFunc.MyFuncType.RetType != GTypeVoid and (not gotAlloc) and TName != null) or callFunc.IsRetRef
		{
			f << TName <<" = "	
		}
		f << "call "
		//callFunc.MyFuncType.PrintType(f)
		base := callFunc.MyFuncType
		base2 := base->{Type^}
		f << base2.GetName()
		f << "@" << callFunc.OutputName
		f << "("
		PrintParamUsesInner(f,callFunc.MyFuncType)
		f << ")"
		if DebugMode {
			newId := CreateDebugCall(this&) 
			if newId != -1{
				f << ", !dbg !" << newId
			}
		}
		if Line != null
		{
			f << "; Line: " << Line.LinePos << " File: " << Line.inFile.itStr 

		}
		f << "\n"
		if gcObjId > 0 and printPres
		{
			tn := FType.RetType.GetName() 
			f << "store " << tn << TName << " , "
			f << tn << "* %T" << gcObjId << "\n"
		}
	}
	Print := virtual !(int s) -> void {
		for s printf("->")
		printf("item: %s %s\n",GetValue(),ToCall.FuncName)
		End := this.Down
		while End != null
		{
			End.Print(s+1)
			End = End.Right
		}
	}
	DoTheWork := virtual !(int pri) -> void
	{
		if pri == State_PreGetUse
		{
			ExchangeParams()
		}
		if pri == State_MiddleGetUse
		{
			CheckReturn()
			if IsGCAnyPtr(FType.RetType) and not FType.RetRef
			{
				gcObjId = GetAlloc(this&,FType.RetType)
				assert(gcObjId > 0)
				GCMakeAware(this&,gcObjId)
			}
		}
	}
	GetDeferUsage := virtual !() -> int
	{
		res := 0
		for it : Down
			res = max(res,it.GetDeferUsage())
		return res
	}
	GetDeferUsageVerticalSize := virtual !() -> int
	{
		sum := 0
		for it : Down
			sum += it.GetDeferUsageVerticalSize()
		return sum
	}
	PrintDeferUse := virtual !(TIOStream f, BoxFuncContainer^ bd,BoxBlock^ blk, int depth,int^ labelIter) -> void
	{
		if Down != null
		{
			mxR := Down
			while mxR.Right != null
				mxR = mxR.Right
			while mxR != null
			{
				mxR.PrintDeferUse(f,bd,blk,depth,labelIter)
				mxR = mxR.Left
			}
		}
	}


	PrintDeferInBlock := virtual !(TIOStream f, int itId,int^ labelSetIter) -> void
	{
		for it : Down
			it.PrintDeferInBlock(f,itId,labelSetIter)
	}

}

NaturalCallWithDefer := class extend NaturalCall
{
	deferCall := BoxFuncBody^

	this := !(BoxFunc^ func, Object^ Pars,BoxFuncBody^ defTail) -> void 
	{
		deferCall = defTail
		this."NaturalCall.this"(func,Pars)
	}
	DoTheWork := virtual !(int pri) -> void
	{
		this."NaturalCall.DoTheWork"(pri)
		if pri == State_MiddleGetUse
		{
			WorkBag.Push(this&,State_PostGetUse)
		}
		if pri == State_PostGetUse
		{
			fnc := GetBoxFuncContainer(this&)
			if fnc != null
			{
				fnc.DoDefer()
			}
			for iter,i : Down
			{
				if not iter.IsConst
				{
					tp := iter.GetType()
					if deferCall.MyFuncType.ParsIsRef[i]
						tp = tp.GetPoint()
					inAlloc := GetAlloc(this&,tp)
					copiedInputs[i] = inAlloc
				}
			}
		}
	}
	UseCall := virtual !(TIOStream f) -> void
	{
		PrintPreFuncName(f)
		PrintParamPres(f)

		for it,i : Down
		{
			if i >= deferCall.MyFuncType.ParsCount
				break
		}

		UseCallInner(f,ToCall,true)
		f << "store i8 " << labelSetValue << " , i8* %DeferStack" << labelSetId << "\n"
	}
	GetDeferUsage := virtual !() -> int
	{
		return 1
	}
	GetDeferUsageVerticalSize := virtual !() -> int
	{
		sum := 1
		for it : Down
			sum += it.GetDeferUsageVerticalSize()
		return sum
	}
	PrintDeferUse := virtual !(TIOStream f, BoxFuncContainer^ bd,BoxBlock^ blk, int depth,int^ labelIter) -> void
	{
		
		curId := labelIter^
		labelIter^ -= 1
		f << "br label %DeferLabel" << curId << "\n"
		f << "DeferLabel" << curId << ":\n"
		
		UseCallInner(f,deferCall,false)

		if Down != null
		{
			mxR := Down
			while mxR.Right != null
				mxR = mxR.Right
			while mxR != null
			{
				mxR.PrintDeferUse(f,bd,blk,depth,labelIter)
				mxR = mxR.Left
			}
		}
	}


	labelSetId := int
	labelSetValue := int
	PrintDeferInBlock := virtual !(TIOStream f, int itId,int^ labelSetIter) -> void
	{
		for it : Down
			it.PrintDeferInBlock(f,itId,labelSetIter)
		labelSetId = itId
		labelSetValue = labelSetIter^
		//f << "store i8 " << labelSetIter^ << " , i8* %DeferStack" << itId << "\n"
		labelSetIter^ += 1
	}
}
