BoxClass := class extend BoxClassBase
{
	FakeParams := Queue.{FakeFieldParam^}
	StaticParams := AVLMap.{char^,GlobalParam^}

	defaultFuncsHolder := BoxClassFuncsHolder
	funcsHolders := AVLMap.{char^,BoxClassFuncsHolder}

	UnrollTemplate := BuiltInTemplateUnroll^
	AutoFieldTemplate := BuiltInTemplateAutoField^
	VirtualCheck := BuiltInCheckVirtualType^

	ExtendObjects2 := HybridQueue.{Object^,2}
	Parents := HybridQueue.{BoxClass^,4}

	ContainVirtual  := bool

	IsPacked := bool
	IsGC := bool

	ItVals := Queue.{ObjConstHolder^}
	ItConsts := Queue.{Object^}
	ItAttrs := AVLMap.{string,Object^}

	ClassName := string


	CreateDefault := !(char^ crtDef) -> void
	{
		switch crtDef
		{
		case "<=>"
			CreateTupleCmp()
		case "="
			CreateTupleSet()
		case void
			EmitError("Unsupported default operator "sbt + crtDef)
		}
	}

	GetClassOutputName := !() -> string
	{
		return "%Class"sbt + ClassId
	}

	
	metaFields := AVLMap.{char^,MetaFieldBox^}
	AddMetaField := !(char^ name, MetaFieldBox^ itMBox) -> void
	{
		metaFields[StrCopy(name)] = itMBox
	}

	ThislessFuncs := Queue.{BuiltIn2ThislessFunc^}
	ThislessTemplates := Queue.{BuiltInThislessTemplate^}
	GetWrappedFunc := !(char^ name ,List.{BoxFunc^} funcs, List.{BoxTemplate^} templs) -> void
	{
		gotFuncs := Queue.{BoxFunc^}()
		funcsCl := Queue.{BoxClass^}()

		gotTempls := Queue.{Tuple.{BoxTemplate^,BoxClass^}}() ; $temp

		checkClass := (BoxClass^ iterF) ==>
		{
			inMt := iterF.defaultFuncsHolder.methods.TryFind(name)
			if inMt != null for qIter : inMt^
			{
				if qIter.FuncName == name
				{
					gotFuncs.Push(qIter) ; $temp
					funcsCl.Push(iterF) ; $temp
				}
			}
			inTmp := iterF.defaultFuncsHolder.templates.TryFind(name)
			if inTmp != null for tmps : inTmp^
			{
				if tmps.FuncName == name
				{
					gotTempls.Emplace(tmps,iterF)
				}
			}
			for par : iterF.Parents
				checkClass(par)
		}
		checkClass(this&)		


		for gotFuncsIter : gotFuncs , funcsClIter : funcsCl
		{
			inTh := BoxFunc^()

			if ThislessFuncs[^].itFunc == gotFuncsIter
			{
				inTh = it
				break
			}


			if inTh == null
			{
				toCr := gotFuncsIter
				if not toCr.IsStatic {
					inThPre :=  new BuiltIn2ThislessFunc(toCr,this&->{BoxClass^},funcsClIter)
					ThislessFuncs.Push(inThPre)
					inTh = inThPre
				}
			}
			if inTh != null funcs.Push(inTh)
		}
		for templ : gotTempls
		{
			inTh := BoxTemplate^()

			if ThislessTemplates[^].itTemplate == templ.0
			{
				inTh = it
				break
			}
			if inTh == null
			{
				if not templ.0.IsStatic{
					inThPre := new BuiltInThislessTemplate(templ.0,this&,templ.1)
					ThislessTemplates.Push(inThPre)
					inTh = inThPre
					inTh.FuncName = name
				}
			}
			if inTh != null templs.Push(inTh)
		}
	}

	IsSameConsts := !(FuncInputBox itBox) -> bool
	{
		if itBox.itConsts.Size() != ItConsts.Size() {
			return false
		}

		for c,i : itBox.itConsts
		{
			if not CmpConstObjs(c,ItConsts[i])
				return false
		}
		if Up != null and Up.GetValue() == "!{}{...}"
		{
			asTmp := Up->{BoxClassTemplate^}
			for itr : asTmp.relAttrs
			{
				inItMap := ItAttrs.TryFind(itr)
				inOtMap := itBox.itAttrs.TryFind(itr)
				if inItMap == null and inOtMap != null return false
				if inItMap != null and inOtMap == null return false
			}
		}

		return true
	}

	GetStaticField := virtual !(string name) -> Object^
	{
		if StaticParams.Contain(name)
			return StaticParams[name]
		return null
	}
	GetItem := virtual !(string name) -> Object^
	{
		if ItVals[^].ItName == name
			return it.Down
		if StaticParams.Contain(name)
			return StaticParams[name]
		return null
	}

	this := !(Object^ item) -> void
	{
		exList := List.{Object^}
		this."this"(item,exList)
	}
	this := !(Object^ item, List.{Object^} exList) -> void
	{
		ExtendObjects2.Push(exList[^])
		ClassName = "anon"
		if item != null Line = item.Line	

		Down = item
		if Down != null
		{
			Down.SetUp(this&)
			Down.Left = null
		}
		WorkBag.Push(this&,State_PreGetUse)

		ClassId = GetNewId()
		ClassType = new TypeClass(this&)
		ClassType.metaId = ClassId
		UnrollTemplate = new BuiltInTemplateUnroll(this&)
		AutoFieldTemplate = new BuiltInTemplateAutoField(this&)
		VirtualCheck = new BuiltInCheckVirtualType(ClassType)

		if Down?.Down[^].GetValue() == "virtual" 
		{
			ContainVirtual = true
			break
		}
		WorkBag.Push(this&,State_Start)
		WorkBag.Push(this&,State_CheckBaseClass)
		WorkBag.Push(this&,State_ClassCheckParams)
		Classes.Push(this&)

	}
	
	Yodlers := AVLSet.{BoxFuncBody^}
	
	GetFieldParam := !(char^ name) -> MemParam^
	{
		if Params[^].ItName == name
			return it
		if FakeParams[^].ItName == name
			return it
		for par : Parents
		{
			return par.GetFieldParam(name)?
		}
		return null
	}
	
	Inherited := false
	InheritParams := !() -> void
	{
		if Inherited
			return void
		Inherited = true


		if Parents.Size() != 0 //TODOPARENT
		{
			Parents[0].InheritParams()
			IsGC = Parents[0].IsGC
			//InheritParams2()
			if Parents[0].ContainVirtual 
				ContainVirtual = true
			WorkBag.Push(this&,State_PrePrint)
		}
		
		for it : Params
		{
			tp := it.ResultType
			if (tp is TypePoint and tp.Base is TypeClass) or tp is TypeClass
			{
				cl := BoxClass^()
				if tp is TypeClass
				{
					cl = tp->{TypeClass^}.ToClass
				}else{
					cl = tp.Base->{TypeClass^}.ToClass
				}
				cl.InheritParams()

				if cl.IsGC and not IsGC
				{
					if Parents.Size() != 0 //TODOPARENT
						EmitError("can not turn class to gc type")
					if gcClass == null
						EmitError("internal error, no class TGCObject")
					Parents.Push(gcClass) //TODOPARENT
					IsGC = true
					if Parents[0].ContainVirtual //TODOPARENT
						ContainVirtual = true
					WorkBag.Push(this&,State_PrePrint)
				}
			}
		}
	}
	Inherited2 := false	
	InheritParams2 := !() -> void
	{
		if Inherited2 return void
		Inherited2 = true
		for Yodlers
		{
			extrField := it.ABox.GetAsType()
			it.yieldInClass = Params.Size()
			it.yieldInClassType = extrField
			if ContainVirtual
				it.yieldInClass += 1
			new FieldParam("yeldData"sbt + GetNewId(), extrField,this&)
		}
	}

	appendObjects := List.{BoxClassAppend^}

	DoTheWork := virtual !(int pri) -> void
	{
		if pri == State_Start
		{
			if ClassName != "anon"
				return void

			itr := Up
			while itr != null and itr.GetValue() != "i:=1" itr = itr.Up
			if itr != null{
				asN := itr->{ObjParam^}
				ClassName = asN.MyStr
			}
			if Down != null and itr != null
			{
				MakeItBlock(Down)
				Down.SetUp(this&)
				WorkBag.Push(Down,State_Start)
			}
		}
		if pri == State_CheckBaseClass
		{
			for ext2,i : ExtendObjects2
			{
				itType := ParseType(ext2,ItAttrs&)
				if itType == null
					EmitError("Can not extend type with index"sbt + i)
				if not itType is TypeClass
				{
					EmitError("can not extend non class type")
				}
				pParent := itType->{TypeClass^}.ToClass
				if pParent.IsGC
				{
					this.IsGC = true
				}
				Parents.Push(pParent)
			}
		}
		if pri == State_PreGetUse
		{
			InheritParams()
			TupleCreateWork()
			CheckPoisons()
		}
		if pri == State_ClassCheckParams
		{
			InheritParams2()
			ComputeVTable()		
		}
	}
	SetParents := !(pList) -> void
	{
		for par : pList
		{
			this.Parents.Push(par)
		}
	}

	//TODO: overload
	ItPoisons := AVLMap.{char^,Object^}
	checkedPoisons := bool 
	CheckPoisons := !() -> void
	{
		if checkedPoisons return void
		checkedPoisons = true

		addedFuncs := AVLSet.{char^}() //TODO MEM
		checkClass := (BoxClass^ prnt) ==> 
		{
			for it,name : prnt.ItPoisons
			{
				if addedFuncs.Contain(name)
					continue
				if not defaultFuncsHolder.methods.Contain(name) //TODO: poison + fake fields
				{
					addedFuncs.Insert(name) ; $temp

					newSub := new ObjParam(name,false) //TODO it is always make copy, i want on demand
					newSub.Down = it.Clone()
					newSub.Down.Up = newSub

					if Down.Down == null
					{
						Down.Down = newSub
					}else{
						itr8 := Down.Down
						while itr8.Right != null
							itr8 = itr8.Right
						itr8.Right = newSub
					}
					newSub.Up = Down
					WorkBag.Push(newSub,State_Start)
				}
			}
			for par : prnt.Parents
				checkClass(par)
		}
		for par : Parents
			checkClass(par)
	}
	GetValue := virtual !() -> string
	{
		return "{...}"
	}
	GetFunc := virtual !(string name,FuncInputBox itBox,bool iVir) -> BoxFunc^
	{
		Funcs := @temp new List.{BoxFunc^}
		Templs := @temp new List.{BoxTemplate^}

		if not iVir
		{
			itrF := this&
			while itrF != null
			{
				if vTypes[^].fName == name
				{
					Funcs.Push(it->{VTableFunction^}.funcWrapper) 
				}
				if itrF.Parents.Size() == 0 //TODOPARENT
					itrF = null
				else itrF = itrF.Parents[0]
			}
		}
		maybeForced := Find(name,'.')
		if maybeForced != -1
		{
			clName := StringSpan(name,maybeForced)
			if clName == ClassName
			{
				funcName := name[(maybeForced+1) .. 0].StrTmp()
				if vTypes[^].fName == funcName
				{
					Funcs.Push(it->{VTableFunction^}.fItem)
				}

				inMt := defaultFuncsHolder.methods.TryFind(funcName) //TODO: forced call to namespace
				if inMt != null for inMt^
				{
					if it.IsSameConsts(itBox) and not it.IsVirtual
					{
						Funcs.Push(it)
					}
				}
				inTmp := defaultFuncsHolder.templates.TryFind(funcName)
				if inTmp != null for inTmp^
				{
					Templs.Push(it)
				}
			}
		}



		//if itBox.itMetaPtr != null
		//{
			holder := defaultFuncsHolder&
			if itBox.itMetaPtr != null
				holder = itBox.itMetaPtr

			mtFncs := holder.methods.TryFind(name)
			if mtFncs != null
			{
				for fnc : mtFncs^
				{
					if ((not fnc.IsVirtual) or iVir) and fnc.IsSameConsts(itBox)
					{
						Funcs.Push(fnc)
					}
				}
			}
			mtTmplts := holder.templates.TryFind(name)
			if mtTmplts != null
				Templs.Push(mtTmplts^[^])

		if name == "." {
			if itBox.itConsts.Size() == 1 and itBox.itConsts[0] is ObjInt
			{
				if GetNmFunc == null
				{
					GetNmFunc = new TupleFuncGetItem(this&)
				}
				Templs.Push(GetNmFunc)
			}
			Templs.Push(UnrollTemplate->{BoxTemplate^})
		}
		bestFunc := GetBestFunc(itBox,Funcs^,Templs^)
		if bestFunc != null WorkBag.Push(bestFunc,State_GetUse)

		if bestFunc == null and name != "this"
		{
			for par : Parents
			{
				oldVal := Type^
				if name != "new"
				{
					oldVal = itBox.itPars[0].first
					itBox.itPars[0].first = par.ClassType //TODOPARENT
				}
				res :=  par.GetFunc(name,itBox,iVir) //TODOPARENT
				if name != "new" { itBox.itPars[0].first = oldVal }

				if res != null
					return res
			}
		}
		if name == "<=>" and tuplCmp != null 
		{
			return tuplCmp
		}
		if name == "=" and tuplSet != null
		{
			if tuplSet.GetPriority(itBox) != 255
			{
				return tuplSet.GetFunc(itBox)
			}
		}
		if name == "this" and tuplConstr != null and ComputePriorFunc(tuplConstr.MyFuncType,itBox,null) != 255
		{
			return tuplConstr
		}

		return bestFunc
	}
	
	ApplyConstants := !(TIOStream f,Object^ itm) -> void
	{
		if itm.GetType() is TypePoint
		{
			ApplyConstants(f,itm.GetName())
		}else{
			ApplyConstants(f,itm.GetPointName())
		}
	}
	ApplyConstants := !(TIOStream f,string itm) -> void
	{
		if TypeContainVTable(ClassType)
		{
			f << "call void(%Class" << ClassId << "*)@ClassExtraConstructor" << ClassId <<"(%Class" << ClassId << "* " 
			f << itm
			f << ")\n"
		}
	}
	PreAskField := virtual !(string name) -> void
	{
	}
}


