BoxClass := class extend BoxClassBase
{
	NotMineParams := int

	FakeParams := Queue.{FakeFieldParam^}
	StaticParams := AVLMap.{char^,GlobalParam^}

	defaultFuncsHolder := BoxClassFuncsHolder
	funcsHolders := AVLMap.{char^,BoxClassFuncsHolder}

	UnrollTemplate := BuiltInTemplateUnroll^
	AutoFieldTemplate := BuiltInTemplateAutoField^
	VirtualCheck := BuiltInCheckVirtualType^

	ExtendObject := Object^
	Parent := BoxClass^
	Childs := AVLSet.{BoxClass^}

	ContainVirtual  := bool

	IsPacked := bool
	IsGC := bool

	ItVals := Queue.{ObjConstHolder^}
	ItConsts := Queue.{Object^}
	ItAttrs := AVLMap.{string,Object^}

	ClassName := string


	CreateDefault := !(char^ crtDef) -> void
	{
		switch crtDef
		{
		case "<=>"
			CreateTupleCmp()
		case "="
			CreateTupleSet()
		case void
			EmitError("Unsupported default operator "sbt + crtDef)
		}
	}

	GetClassOutputName := !() -> string
	{
		return "%Class"sbt + ClassId
	}

	
	metaFields := AVLMap.{char^,MetaFieldBox^}
	AddMetaField := !(char^ name, MetaFieldBox^ itMBox) -> void
	{
		metaFields[StrCopy(name)] = itMBox
	}

	ThislessFuncs := Queue.{BuiltIn2ThislessFunc^}
	ThislessTemplates := Queue.{BuiltInThislessTemplate^}
	GetWrappedFunc := !(char^ name ,Queue.{BoxFunc^} funcs, Queue.{BoxTemplate^} templs) -> void
	{
		gotFuncs := Queue.{BoxFunc^}()
		funcsCl := Queue.{BoxClass^}()

		gotTempls := Queue.{Tuple.{BoxTemplate^,BoxClass^}}() ; $temp

		iterF := this&
		while iterF != null
		{
			inMt := iterF.defaultFuncsHolder.methods.TryFind(name)
			if inMt != null for qIter : inMt^
			{
				if qIter.FuncName == name
				{
					gotFuncs.Push(qIter) ; $temp
					funcsCl.Push(iterF) ; $temp
				}
			}
			inTmp := iterF.defaultFuncsHolder.templates.TryFind(name)
			if inTmp != null for tmps : inTmp^
			{
				if tmps.FuncName == name
				{
					gotTempls.Emplace(tmps,iterF)
				}
			}
			iterF = iterF.Parent
		}

		for gotFuncsIter : gotFuncs , funcsClIter : funcsCl
		{
			inTh := BoxFunc^()

			if ThislessFuncs[^].itFunc == gotFuncsIter
			{
				inTh = it
				break
			}


			if inTh == null
			{
				toCr := gotFuncsIter
				if not toCr.IsStatic {
					inThPre :=  new BuiltIn2ThislessFunc(toCr,this&->{BoxClass^},funcsClIter)
					ThislessFuncs.Push(inThPre)
					inTh = inThPre
				}
			}
			if inTh != null funcs.Push(inTh) ; $temp
		}
		for templ : gotTempls
		{
			inTh := BoxTemplate^()

			if ThislessTemplates[^].itTemplate == templ.0
			{
				inTh = it
				break
			}
			if inTh == null
			{
				if not templ.0.IsStatic{
					inThPre := new BuiltInThislessTemplate(templ.0,this&,templ.1)
					ThislessTemplates.Push(inThPre)
					inTh = inThPre
					inTh.FuncName = name
				}
			}
			if inTh != null templs.Push(inTh) ; $temp
		}
	}

	IsSameConsts := !(FuncInputBox itBox) -> bool
	{
		if itBox.itConsts.Size() != ItConsts.Size() {
			return false
		}

		for c,i : itBox.itConsts
		{
			if not CmpConstObjs(c,ItConsts[i])
				return false
		}
		if Up != null and Up.GetValue() == "!{}{...}"
		{
			asTmp := Up->{BoxClassTemplate^}
			for itr : asTmp.relAttrs
			{
				inItMap := ItAttrs.TryFind(itr)
				inOtMap := itBox.itAttrs.TryFind(itr)
				if inItMap == null and inOtMap != null return false
				if inItMap != null and inOtMap == null return false
			}
		}

		return true
	}

	GetStaticField := virtual !(string name) -> Object^
	{
		if StaticParams.Contain(name)
			return StaticParams[name]
		return null
	}
	GetItem := virtual !(string name) -> Object^
	{
		if ItVals[^].ItName == name
			return it.Down
		if StaticParams.Contain(name)
			return StaticParams[name]
		return null
	}

	this := !(Object^ item, BoxClass^ par,Object^ extItem) -> void 
	{
		ClassName = "anon"
		if item != null Line = item.Line	
		ExtendObject = extItem

		Down = item
		if Down != null
		{
			Down.SetUp(this&)
			Down.Left = null
		}
		WorkBag.Push(this&,State_PreGetUse)

		ClassId = GetNewId()
		ClassType = new TypeClass(this&)
		ClassType.metaId = ClassId
		UnrollTemplate = new BuiltInTemplateUnroll(this&)
		AutoFieldTemplate = new BuiltInTemplateAutoField(this&)
		VirtualCheck = new BuiltInCheckVirtualType(ClassType)

		SetParent(par)

		if par?.ContainVirtual ContainVirtual = true
		if Down != null and not ContainVirtual
		{
			if Down.Down[^].GetValue() == "virtual" 
			{
				ContainVirtual = true
				break
			}
		}
		WorkBag.Push(this&,State_Start)
		WorkBag.Push(this&,State_CheckBaseClass)
		WorkBag.Push(this&,State_ClassCheckParams)
		Classes.Push(this&)

	}
	
	Yodlers := AVLSet.{BoxFuncBody^}
	
	GetFieldParam := !(char^ name) -> MemParam^
	{
		if Params[^].ItName == name
			return it
		if FakeParams[^].ItName == name
			return it
		if Parent != null
			return Parent.GetFieldParam(name)
		return null
	}
	
	Inherited := false
	InheritParams := !() -> void
	{
		if Inherited
			return void
		Inherited = true


		if Parent != null
		{
			Parent.InheritParams()
			IsGC = Parent.IsGC
			//InheritParams2()
			if Parent.ContainVirtual 
				ContainVirtual = true
			WorkBag.Push(this&,State_PrePrint)
		}
		
		for it : Params
		{
			tp := it.ResultType
			if (tp is TypePoint and tp.Base is TypeClass) or tp is TypeClass
			{
				cl := BoxClass^()
				if tp is TypeClass
				{
					cl = tp->{TypeClass^}.ToClass
				}else{
					cl = tp.Base->{TypeClass^}.ToClass
				}
				cl.InheritParams()

				if cl.IsGC and not IsGC
				{
					if Parent != null 
						EmitError("can not turn class to gc type")
					if gcClass == null
						EmitError("internal error, no class TGCObject")
					Parent = gcClass
					IsGC = true
					if Parent.ContainVirtual 
						ContainVirtual = true
					WorkBag.Push(this&,State_PrePrint)
				}
			}
		}
	}
	Inherited2 := false	
	InheritParams2 := !() -> void
	{
		if Inherited2 return void
		Inherited2 = true
		if Parent != null
		{

			Parent.InheritParams2()
			Size := Parent.Params.Size()
			NotMineParams = Size
			for i : Size
			{
				Params.PushFront(Parent.Params[Size - i - 1])
			}
			for fakes : Parent.FakeParams FakeParams.PushFront(fakes)
		}
		for Yodlers
		{
			extrField := it.ABox.GetAsType()
			it.yieldInClass = Params.Size()
			it.yieldInClassType = extrField
			if ContainVirtual
				it.yieldInClass += 1
			new FieldParam("yeldData"sbt + GetNewId(), extrField,this&)
		}
	}

	appendObjects := List.{BoxClassAppend^}

	DoTheWork := virtual !(int pri) -> void
	{
		if pri == State_Start
		{
			if ClassName != "anon"
				return void

			itr := Up
			while itr != null and itr.GetValue() != "i:=1" itr = itr.Up
			if itr != null{
				asN := itr->{ObjParam^}
				ClassName = asN.MyStr
			}
			if Down != null and itr != null
			{
				MakeItBlock(Down)
				Down.SetUp(this&)
				WorkBag.Push(Down,State_Start)
			}
		}
		if pri == State_CheckBaseClass
		{
			if ExtendObject != null{
				newType := ParseType(ExtendObject,ItAttrs&)
				if newType == null{
					EmitError("Can not extend type\n")
				}else{
					if not newType is TypeClass{
						EmitError("wip\n")
					}else{
						PreParent := newType->{TypeClass^}
						SetParent(PreParent.ToClass)
						if PreParent.ToClass.IsGC
						{
							this.IsGC = true
						}
					}
				}
			}
		}
		if pri == State_PreGetUse
		{
			InheritParams()
			TupleCreateWork()
			CheckPoisons()
		}
		if pri == State_ClassCheckParams
		{
			InheritParams2()
			ComputeVTable()		
		}
	}
	SetParent := !(BoxClass^ p) -> void
	{
		Parent = p
		if p != null
		{
			p.Childs.Insert(this&)
		}
	}

	//TODO: overload
	ItPoisons := AVLMap.{char^,Object^}
	checkedPoisons := bool 
	CheckPoisons := !() -> void
	{
		if checkedPoisons return void
		checkedPoisons = true

		addedFuncs := AVLSet.{char^}()
		prnt := Parent
		while prnt != null
		{
			for it,name : prnt.ItPoisons
			{
				if addedFuncs.Contain(name)
					continue
				if not defaultFuncsHolder.methods.Contain(name) //TODO: poison + fake fields
				{
					addedFuncs.Insert(name) ; $temp

					newSub := new ObjParam(name,false)
					newSub.Down = it.Clone()
					newSub.Down.Up = newSub

					if Down.Down == null
					{
						Down.Down = newSub
					}else{
						itr8 := Down.Down
						while itr8.Right != null
							itr8 = itr8.Right
						itr8.Right = newSub
					}
					newSub.Up = Down
					WorkBag.Push(newSub,State_Start)
				}
			}
			prnt = prnt.Parent
		}
	}
	GetValue := virtual !() -> string
	{
		return "{...}"
	}
	GetFunc := virtual !(string name,FuncInputBox itBox,bool iVir) -> BoxFunc^
	{
		Funcs := Queue.{BoxFunc^}() ; $temp
		Templs := Queue.{BoxTemplate^}() ; $temp

		if not iVir
		{
			itrF := this&
			while itrF != null
			{
				if vTypes[^].fName == name
				{
					Funcs.Push(it->{VTableFunction^}.funcWrapper) 
				}
				itrF = itrF.Parent
			}
		}
		maybeForced := Find(name,'.')
		if maybeForced != -1
		{
			clName := StringSpan(name,maybeForced)
			if clName == ClassName
			{
				funcName := name[(maybeForced+1) .. 0].StrTmp()
				if vTypes[^].fName == funcName
				{
					Funcs.Push(it->{VTableFunction^}.fItem)
				}

				inMt := defaultFuncsHolder.methods.TryFind(funcName) //TODO: forced call to namespace
				if inMt != null for inMt^
				{
					if it.IsSameConsts(itBox) and not it.IsVirtual
					{
						Funcs.Push(it)
					}
				}
				inTmp := defaultFuncsHolder.templates.TryFind(funcName)
				if inTmp != null for inTmp^
				{
					Templs.Push(it)
				}
			}
		}



		//if itBox.itMetaPtr != null
		//{
			holder := defaultFuncsHolder&
			if itBox.itMetaPtr != null
				holder = itBox.itMetaPtr

			mtFncs := holder.methods.TryFind(name)
			if mtFncs != null
			{
				for fnc : mtFncs^
				{
					if ((not fnc.IsVirtual) or iVir) and fnc.IsSameConsts(itBox)
					{
						Funcs.Push(fnc)
					}
				}
			}
			mtTmplts := holder.templates.TryFind(name)
			if mtTmplts != null
				Templs.Push(mtTmplts^[^])

		if name == "." {
			if itBox.itConsts.Size() == 1 and itBox.itConsts[0] is ObjInt
			{
				if GetNmFunc == null
				{
					GetNmFunc = new TupleFuncGetItem(this&)
				}
				Templs.Push(GetNmFunc)
			}
			Templs.Push(UnrollTemplate->{BoxTemplate^})
		}
		bestFunc := GetBestFunc(itBox,Funcs,Templs)
		if bestFunc != null WorkBag.Push(bestFunc,State_GetUse)

		if bestFunc == null and this.Parent != null and name != "this"
		{
			oldVal := Type^
			if name != "new"
			{
				oldVal = itBox.itPars[0].first
				itBox.itPars[0].first = Parent.ClassType
			}
			res :=  this.Parent.GetFunc(name,itBox,iVir)
			if name != "new" { itBox.itPars[0].first = oldVal }

			return res
		}
		if name == "<=>" and tuplCmp != null 
		{
			return tuplCmp
		}
		if name == "=" and tuplSet != null
		{
			if tuplSet.GetPriority(itBox) != 255
			{
				return tuplSet.GetFunc(itBox)
			}
		}
		if name == "this" and tuplConstr != null and ComputePriorFunc(tuplConstr.MyFuncType,itBox,null) != 255
		{
			return tuplConstr
		}

		return bestFunc
	}
	GetParamNr := !(int x) -> int
	{
		if vTable.Size() != 0
			return x + 1
		return x
	}
	
	ApplyConstants := !(TIOStream f,Object^ itm) -> void
	{
		if itm.GetType() is TypePoint
		{
			ApplyConstants(f,itm.GetName())
		}else{
			ApplyConstants(f,itm.GetPointName())
		}
	}
	ApplyConstants := !(TIOStream f,string itm) -> void
	{
		if TypeContainVTable(ClassType)
		{
			f << "call void(%Class" << ClassId << "*)@ClassExtraConstructor" << ClassId <<"(%Class" << ClassId << "* " 
			f << itm
			f << ")\n"
		}
	}
	PreAskField := virtual !(string name) -> void
	{
	}
}


