AppendClass BoxClass
{
	PrintStruct := virtual !(TIOStream f) -> void
	{
		PrintVTable(f)
		
		needComma := false
		f << "%ClassParams" << ClassId << " = type{"
		if Parent != null
		{
			f << "%ClassParams" << Parent.ClassId
			needComma = true
		}
		if Params.Size() == 0
		{
			if needComma
				f << ","
			f << "i1"
		}else{
			for it, i : Params
			{
				if needComma f << ","
				f << it.ResultType.GetName()
				needComma = true
			}
		}
		f << "}\n"
			
		f << "%Class" << ClassId << " = type "
		if IsPacked f << "<"
		f << "{"
		if not vTable.IsEmpty()
		{
			f << "%ClassTableType" << ClassId << "*"
			f << ","
		}
		f << "%ClassParams" << ClassId
		f << "}"
		if IsPacked f << ">"
		f <<"\n"
		if DebugMode
		{
			//ClassType.ComputeAlignAndDeb()
			//exZ := @temp new List.{int}()
			//for cc : ClassType.debTable
			//{
			//	newII := GetNewId()
			//	f << "!" << newII << " = !DIDerivedType(tag: DW_TAG_member, name: \"" << cc.0 << "\" , scope: !" << ClassId
			//	if cc.1.Line != null
			//	{
			//		itrr := Up
			//		while itrr.Up != null itrr = itrr.Up
			//		f << " , file: !" << itrr->{BoxFile^}.fileId << " , line: " << cc.1.Line.LinePos 
			//	}
			//	f << " , baseType: !" << cc.1.ResultType.metaId << ", size: " << cc.3*8 << ", offset: " << cc.2*8 << ")\n"
			//	//!16 = !DIDerivedType(tag: DW_TAG_member, name: "x", scope: !14, file: !1, line: 5, baseType: !12, size: 32)
			//	exZ^ << newII
			//}
			//elmIds := GetNewId()
			//f << "!" << elmIds << " = !{"
			//for ccc,i : exZ^
			//{
			//	if i != 0 f << ","
			//	f << "!" << ccc
			//}
			//f << "}\n"
			//f << "!" << ClassId << " = !DICompositeType(tag: DW_TAG_structure_type, name: \"" << ClassName << "\""
			//f << ", elements: !"<< elmIds << ")\n"
			f << "!" << ClassId << " = !DICompositeType(tag: DW_TAG_structure_type, name: \"" << ClassName << "\""
			f << ", elements: !{})\n"
		}
	}
	PrintGlobal := virtual !(TIOStream f) -> void
	{
		PrintCreatedFuncs(f)
		StaticParams[^].PrintGlobal(f)
		f << "define void @ClassExtraConstructor" << ClassId << "(%Class" << ClassId << "* %this)\n"
		f << "{\n"
		if ContainVirtual
		{
			f << "%TmpPt" << ClassId << " = getelementptr %Class" << ClassId << " , %Class" << ClassId << "* "
			f << "%this"
			f << ", i32 0, i32 0\n"
			f << "store %ClassTableType" << ClassId << "* @ClassTableItem" << ClassId <<  ", %ClassTableType" << ClassId << "** %TmpPt" << ClassId << "\n"
		}
		if Params.Size() != 0 or Parent != null
		{
			f << "%Tsub = getelementptr %Class" << ClassId << " , %Class" << ClassId << "* %this , i32 0"
			if ContainVirtual
			{
				f << ", i32 1\n"
			}else{
				f << ", i32 0\n"
			}

			f << "call void @ClassExtraConstructorParams" << ClassId << "(%ClassParams" << ClassId << "* %Tsub)\n"
		}
		f << "	ret void\n"
		f << "}\n"

		f << "define void @ClassExtraConstructorParams" << ClassId << "(%ClassParams" << ClassId << "* %this)\n"
		f << "{\n"

		parentCount := 0
		if Parent != null
			parentCount = 1

		for itParm,i : this.Params
		{
			if not TypeContainVTable(itParm.ResultType)
				continue


			if itParm.ResultType is TypeArr
			{
				lays := Queue.{int}() ; $temp
				typeT := itParm.ResultType->{TypeArr^}
				itBaseT := TypeClass^()
				while true
				{
					lays.Push(typeT.Size)

					if typeT.Base is TypeArr {
						typeT = typeT.Base->{TypeArr^}
					}else{
						assert(typeT.Base is TypeClass)
						itBaseT = typeT.Base->{TypeClass^}
						break
					}
				}
				inCl := i + parentCount
				
				for itL,k : lays
				{
					
					f << "br label %L" << i <<"itr" << k << "PreStart\n"
					f << "L" << i << "itr" << k << "PreStart:\n"
					f << "br label %L" << i <<"itr" << k << "Start\n"
					f << "L" << i << "itr" << k << "Start:\n"
					f << "%L" << i << "itr" << k << "Itr = phi i32 [0," 
						<< "%L" << i << "itr" << k << "PreStart] ,"
						<< "[%L" << i << "itr" << k << "Itr2, "
						<< "%L" << i << "itr" << k << "PreEnd]\n"

				}
				f << "%Pre" << i << "Set = getelementptr %ClassParams" << ClassId << ", %ClassParams" << ClassId << "* %this"
					 << ", i32 0, i32 " << inCl
				for itL, k : lays
				{
					f << ",i32 %L" << i << "itr" << k << "Itr"
				}
				f << "\n"
				itBaseT.ToClass.ApplyConstants(f,"%Pre"sbt + i + "Set")

				k := lays.Size() - 1
				while k >= 0
				{	itL := lays[k]
					f << "br label %L" << i << "itr" << k << "PreEnd\n"
					f << "L" << i << "itr" << k << "PreEnd:\n"
					f << "%L" << i << "itr" << k << "Itr2 = add i32 1, %L" << i << "itr" << k << "Itr\n"
					f << "%L" << i << "itr" << k << "Test = icmp eq i32 %L" << i << "itr" << k << "Itr2 , "<< itL << "\n"
					f << "br i1 " << "%L" << i << "itr" << k << "Test ,"
						<<"label %L" << i << "itr" << k << "End ,"
						<<"label %L" << i << "itr" << k << "Start\n"
					f << "L" << i << "itr" << k << "End:\n"

					k -= 1
				}
			}
			if itParm.ResultType is TypeClass
			{
				clTyp := itParm.ResultType->{TypeClass^}
				classItm := clTyp.ToClass
				if classItm.ContainVirtual
				{
					pos := i + parentCount
					
					f << "%itrItm" << pos << " = getelementptr %ClassParams" << ClassId << " , %ClassParams" << ClassId
					f << "* %this" <<", i32 0, i32 " << pos <<"\n"
					classItm.ApplyConstants(f,"%itrItm"sbt + pos)
				}
			}

		}
		f << "ret void\n}\n"

		downs := new List.{Object^}() ; $temp
		if Down != null downs.Push(Down)
		//downs.Push(metaFields[^].Down) ; $temp

		for iterJ : downs^[^].Down
		{
			if iterJ.GetValue() == "i:=1"
			{
				if iterJ.Down.GetValue() == "!()"
				{
					asFunc := iterJ.Down->{BoxFunc^}
					if not asFunc.IsAssembler()
						iterJ.PrintGlobal(f)
				}
				if iterJ.Down.GetValue() == "!(){}"
				{
					iterJ.PrintGlobal(f)
				}
				if iterJ.Down is MetaFieldBox
				{
					iterJ.PrintGlobal(f)
				}
			}
		}
	}
}