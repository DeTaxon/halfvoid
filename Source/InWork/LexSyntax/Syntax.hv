InDataR := !(Object^ obj) -> bool
{
	if obj.IsDataR return true
	return false
}

InBlockData := !(Object^ obj) -> bool
{
	if InDataR(obj) return true
	switch(obj.GetValue())
	{
		case  "return()" return true
		case  "if()" return true
		case  "while()" return true
		case  "for()" return true
		case  "switch()" return true
		case  "~continue" return true
		case  "~break" return true
	}

	return false
}

RemoveTokens := !(Object^ iter, int n,tokenDict) -> void
{
	for i : n
	{
		val := iter.GetValue()
		if tokenDict[val].Contain(iter)
		{
			tokenDict[val].Remove(iter)
		}
		iter = iter.Right
	}
}

RuleUse := !(Object^ Obj,char^ N,!(void^)^->int R,tokenDict) -> bool
{
	GotStuff := false
	iter := Obj.Down

	while iter != null
	{
		Try := R(iter)
		if Try > 0
		{
			//RemoveTokens(iter,Try,tokenDict)
			if N == "~d"
			{
				iter = UNext(iter,new ObjData(),Try) 
			}else
			{
				if N == "~extra1"
				{
					iter = UNext(iter,new SLambda(),Try)
				}else{
					iter = UNext(iter,new ObjObj(N),Try)
				}
			}
			GotStuff = true
		}else{
			iter = iter.Right
		}
	}
	return GotStuff
}
RuleUse2 := !(Object^ Obj,char^ N,char^ keyObj,int offset,!(void^)^->int R,tokenDict) -> bool
{
	GotStuff := false

	for preIter : tokenDict[keyObj]
	{
		iter := preIter

		for c : offset
		{
			iter = iter.Left
			if iter == null
				break
		}

		if iter == null
			continue

		Try := R(iter)
		if Try > 0
		{
			//RemoveTokens(iter,Try,tokenDict)
			if N == "~d"
			{
				iter = UNext(iter,new ObjData(),Try) 
			}else
			{
				if N == "~extra1"
				{
					iter = UNext(iter,new SLambda(),Try)
				}else{
					iter = UNext(iter,new ObjObj(N),Try)
				}
			}
			return true
		}
	}
	return false
}

RuleUseReverse := !(Object^ Obj,char^ N,!(void^)^->int R,tokenDict) -> bool
{
	GotStuff := false
	iter := Obj.Down

	if iter == null return false

	while iter.Right != null iter = iter.Right

	while iter != null
	{
		Try := R(iter)
		if Try > 0
		{
			//RemoveTokens(iter,Try,tokenDict)
			switch N
			{
				case "~d"
					iter = UNext(iter,new ObjData(),Try)
				case "DecObj"
					iter = UNext(iter,new DecoratorHolder,Try)
				case void
					iter = UNext(iter,new ObjObj(N),Try)
			}
			GotStuff = true
		}else{
			iter = iter.Left
		}
	}
	return GotStuff
}

RuleUseSome := !(Object^ Obj,MiniMachineNodeOld^ MiniNode2,tokenDict) -> bool
{
	GotStuff := false
	iter := Obj.Down

	while iter != null
	{
		Try := RuleMachineOld(iter,MiniNode2)
		if Try > 0
		{
			//RemoveTokens(iter,Try,tokenDict)
			
			iter = UNext(iter,new ObjData(),Try) 
			GotStuff = true
		}else{
			iter = iter.Right
		}
	}
	return GotStuff
}

StupidWhile := !(Object^ begin,PriorityBagOld^ bag , tokenDict) -> bool
{
	//iter := begin.Down
	if RuleUse(begin,"~d",RuleMinus,tokenDict)
			return true

	GotStuff := false

	for iterBag : bag.Lines
	{
		if iterBag.Machine != null
		{
			needCheck := true
			if false and iterBag.uniqOnly
			{
				needCheck = false
				for uVal : iterBag.uniqs^
				{
					if tokenDict.Contain(uVal) and tokenDict[uVal].Size() != 0
					{
						needCheck = true
					}
				}
			}
			if needCheck and RuleUseSome(begin,iterBag.Machine,tokenDict) return true
		}else{
			switch iterBag.RawLine
			{
				case "#CallFunction"
					if RuleUse(begin,"~d",RuleCallFunction,tokenDict) return true
				case "#CallDecoratorCall"
					if RuleUseReverse(begin,"DecObj",RuleDecoratorCall,tokenDict) 
							return true
			}
		}
	}


	if RuleUse(begin,"~extra1",RuleSLambda,tokenDict) return true
	if RuleUse(begin,"Defer()",RuleDefer,tokenDict) return true
	if RuleUse(begin,"return()",RuleOneFunc,tokenDict) return true
	if RuleUse(begin,"i:=0",RuleParam,tokenDict) return true // for func 
	if RuleUse(begin,"i.{}:=0",RuleTypedefTemplate,tokenDict) return true // for func 
	if RuleUseReverse(begin,"if()",RuleIf,tokenDict) return true
	if RuleUse(begin,"while()",RuleWhile,tokenDict) return true
	if RuleUse(begin,"for()",RuleFor,tokenDict) 
			return true
	if RuleUse(begin,"switch()",RuleSwitch,tokenDict) 
			return true
	if RuleUse(begin,"case()",RuleCase,tokenDict) return true

	return false	
}

SyntaxCompress := !(Object^ begin, PriorityBagOld^ bag) -> bool
{
	if begin == null return true

	GotWork := true

	if bag == PriorityData
	{
		itr := begin.Down
		while itr != null
		{
			if itr.GetValue() == "()" SyntaxCompress(itr,bag)
			itr = itr.Right
		}
	}


	tokenDict := RBMap.{char^,RBSet.{Object^}}^
	
	if false {
		tokenDict = @temp new RBMap.{char^,RBSet.{Object^}}
		for itr : begin.Down
		{
			val := itr.GetValue()

			if val == "~{}type"
			{
				tokenDict^[val].Insert(itr)
				continue
			}

			if itr.IsDataR
				continue
			if val in  !["()","[]","~suffix"]
				continue
			tokenDict^[val].Insert(itr)
		}
	}

	while GotWork GotWork = StupidWhile(begin,bag,tokenDict^)

	return true
}


RuleMachineOld := !(void^ itr,MiniMachineNodeOld^ node) -> int
{
	iterU := itr->{Object^}
	iterNode := node
	ToRet := 0
	NowRet := 0

	while iterU != null
	{
		if iterU == null return ToRet
		iterVal := iterU.GetValue()
		isTType := iterU is ObjTemplateType
		if iterU.IsDataR iterVal = "~d"

		iterId := iterU.GetTokenId()
		if iterU.IsDataR iterId = 1

		inWNext := iterNode.WhatNext.TryFind(iterVal)
		if inWNext != null
		{
			iterNode = inWNext^
			NowRet += 1
			if iterNode.IsTerm 
			{
				ToRet = NowRet
			}
			if iterU.Line != iterU.Right?.Line and iterU.Right.GetValue() == "()"
			{
				return ToRet
			}
			iterU = iterU.Right
		}else
		{
			return ToRet
		}
	}
	return ToRet
}


RuleTypedefTemplate := !(void^ itr) -> int
{
	It := itr->{Object^}
	if It.Down == null return 0
	if It.Down.Right == null return 0
	if It.Down.Right.Right == null return 0
	if not ( It.Down is ObjIndent ) return 0
	if It.Down.Right.GetValue() != "." return 0
	if It.Down.Right.Right.GetValue() != "{}" return 0

	It = It.Right
	if It == null return 0
	if It.GetValue() != ":=" return 0

	It = It.Right
	if It == null return 0
	if It.GetValue() != "type" return 0

	It = It.Right
	if It == null return 0

	if InDataR(It) return 4
	return 0
}

RuleDecoratorCall := !(void^ itr) -> int
{
	It := itr->{Object^}
	if It == null
		return 0
	if It.GetValue() != "~{}type"
		return 0
	It = It.Right
	if It?.IsDataR
	{
		return  2
	}
	return 0
}

RuleParam := !(void^ itr) -> int
{
	size := 0

	It := itr->{Object^}

	if It.GetValue() != "~ind" and It.GetValue() != "~str" return 0

	It = It.Right
	if It == null return 0
	size += 1

	while It.GetValue() == ","
	{
		It = It.Right
		if It == null return 0
		
		if It.GetValue() != "~ind" and It.GetValue() != "~str" return 0

		It = It.Right
		if It == null return 0

		size += 2
	}

	if It.GetValue() != ":=" return 0

	It = It.Right
	if It == null return 0

	if It.GetValue() == "default"
	{
		return size + 2
	}
	
	if It.GetValue() == "extern"
	{
		It = It.Right
		if It == null return 0
		size += 1
	}
	
	if It.GetValue() == "weak"
	{
		It = It.Right
		if It == null return 0
		size += 1
	}
	if It.GetValue() == "static"
	{
		It = It.Right
		if It == null return 0
		size += 1
	}
	if It.GetValue() == "poison"
	{
		It = It.Right
		if It == null return 0
		size += 1
	}
	if It.GetValue() == "type"
	{
		It = It.Right
		if It == null return 0
		size += 1
	}

	if It.GetValue() == "ref"
	{
		It = It.Right
		if It == null return 0
		size += 1
	}
	if It.GetValue() == "virtual"
	{
		It = It.Right
		if It == null return 0
		size += 1
	}
	if It.GetValue() in !["thread_local","task_local"]
	{
		It = It.Right
		if It == null return 0
		size += 1
	}
	if It.GetValue() == "task_local"
	{
		It = It.Right
		if It == null return 0
		size += 1
	}

	if not InDataR(It) return 0

	It = It.Right
	if It == null return size + 2

	if It.GetValue() != "at" return size + 2

	It = It.Right
	if It == null return 0
	if not InDataR(It) return 0

	return size + 4
}
RuleSLambda := !(void^ itr) -> int
{
	It := itr->{Object^}

	siz := 3

	if not InDataR(It) return 0

	It = It.Right
	if It == null return 0

	if It.GetValue() != "=>" and It.GetValue() != "==>" return 0

	It = It.Right
	if It == null return 0

	if InDataR(It)
	{
		It = It.Right
		if It == null return 0
		siz += 1
	}

	if It.GetValue() == "[]"
	{
		It = It.Right
		if It == null return 0
		siz += 1 
	}

	if It.GetValue() == "{}" return siz
	if InDataR(It) return siz
	return 0
}
RuleCallFunction := !(void^ itr) -> int
{
	It := itr->{Object^}

	if It.Left != null
	{
		if It.Left.GetValue() == "." return 0
	}

	if not InDataR(It) return 0
	
	It = It.Right
	if It == null return 0

	if It.GetValue() != "()" return 0

	if It.Line != It.Left.Line return 0

	return 2
}
RuleMinus := !(void^ itr) -> int
{
	It := itr->{Object^}

	if It.Left != null
	{
		if It.Left.GetValue() == "[]" return 0
		if It.Left.GetValue() == "()" return 0
		if It.Left is ObjSuffix return 0 
		if It.Left.IsDataR return 0
	}
	if It.GetValue() != "-" return 0

	It = It.Right
	if It == null return 0

	if not It.IsDataR return 0
	
	It = It.Right
	if It == null return 2

	switch It.GetValue()
	{
		case "." return 0
		case "()" return 0
		case "[]" return 0
		case "^" return 0
		case "&" return 0
	}

	return 2
}
RuleDefer := !(void^ itr) -> int
{
	It := itr->{Object^}

	if It.GetValue() != "defer" and It.GetValue() != "on_exception" return 0

	It = It.Right
	if It == null return 0

	if not InDataR(It) return 0
	return 2
}

RuleOneFunc := !(void^ itr)-> int
{
	It := itr->{Object^}

	if  It.GetValue() != "return" and It.GetValue() != "yield" return 0

	It = It.Right
	if It == null return 0

	if not InDataR(It) return 0

	return 2
}

RuleIf := !(void^ itr)-> int
{
	It := itr->{Object^}

	if It.GetValue() != "if" return 0
	It = It.Right
	if It == null return 0

	if not InDataR(It) return 0
	It = It.Right
	if It == null return 0

	if It.GetValue() != "{}" and (not InBlockData(It)) and (It.GetValue() != "i:=1") return 0
	//if It.GetValue() != "{}" and (not InBlockData(It)) return 0
	It = It.Right
	if It == null return 3

	if It.GetValue() != "else" return 3
	It = It.Right
	if It == null return 3

	if It.GetValue() == "{}" or InBlockData(It)  return 5

	return 3
}
RuleSwitch := !(void^ itr) -> int
{
	It := itr->{Object^}

	if It.GetValue() != "switch" return 0

	It = It.Right
	if It == null return 0

	if not InDataR(It) return 0

	It = It.Right
	if It == null return 0

	if It.GetValue() != "{}" return 0

	return 3
}

RuleCase := !(void^ itr) -> int
{
	It := itr->{Object^}

	if It.GetValue() != "case" return 0

	It = It.Right
	if It == null return 0

	if InDataR(It) return 2
	return 0
}
RuleWhile := !(void^ itr)-> int
{
	It := itr->{Object^}

	if It.GetValue() != "while" return 0
	It = It.Right
	if It == null return 0

	if not InDataR(It) return 0
	It = It.Right
	if It == null return 0

	if It.GetValue() != "{}" and not InBlockData(It) return 0
	return 3
}

RuleFor := !(void^ itr)-> int
{
	It := itr->{Object^}
	Size := 3

	if It.GetValue() != "for" return 0
	It = It.Right
	if It == null return 0

	if not InDataR(It) return 0
	It = It.Right
	if It == null return 0

	if It.GetValue() == ","
	{
		It = It.Right

		if It == null return 0

		if not InDataR(It) return 0

		It = It.Right
		if It == null return 0
		Size += 2
	}

	if It.GetValue() == ":"
	{
		It = It.Right
		if It == null return 0

		if not InDataR(It) return 0
		It = It.Right
		if It == null return 0

		Size += 2
	}

	if It == null return 0


	while It.GetValue() == ","
	{
		It = It.Right
		if It == null return 0

		if It.GetValue() != "~ind" return 0

		It = It.Right
		if It == null return 0
		
		if It.GetValue() == ","
		{
			It = It.Right
			if It == null return 0

			if It.GetValue() != "~ind" return 0
			
			It = It.Right
			if It == null return 0

			Size += 2
		}
			
		if It.GetValue() != ":" return 0

		It = It.Right
		if not InDataR(It) return 0
		It = It.Right
		if It == null return 0

		Size += 4
	}

	if It.GetValue() != "{}" and not InBlockData(It) return 0
	return Size
}

