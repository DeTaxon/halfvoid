
MiniMachineNodeOld := class 
{
	WhatNext := AVLMap.{char^,MiniMachineNodeOld^}
	IsTerm := bool

	this := !() -> void
	{
		WhatNext."this"()
		IsTerm = false
	}
	GetNext := !(string item) -> MiniMachineNodeOld^
	{
		inIt := WhatNext.TryFind(item)
		if inIt != null return inIt^
		return null
	}
}

LexMachineInfo := class
{
	Machine := MiniMachineNodeOld^
	RawLine := char^

	this := !(MiniMachineNodeOld^ inM,char^ rLine) -> void
	{
		Machine = inM
		RawLine = rLine
	}
}
PriorityBagOld := class
{
	Opers := AVLSet.{string}
	Lines := List.{LexMachineInfo}

	this := !(char^ ptrChar, int mapSize) -> void
	{		
		//fileSpan := StringSpan(ptrChar,mapSize)

		//reg := "r?\"((\\\\ [^]) | [^\"\\\\])*\""reg

		//fileSpan.DivideStr("\n",ln ==> {
		//	
		//	RegExpReadText(reg&,ln.ptr,ln.itSize,(a,b,c) ==> {
		//		word := StringSpan(ln.ptr[b]&,c)
		//		printf("obj %s\n",word)
		//	})
		//})

		itS := 0
		while itS < mapSize
		{
			CurWords := Queue.{StringSpan}() ; $temp

			if ptrChar[itS] == '#'
			{
				strtT := itS
				while itS < mapSize and ptrChar[itS] != '\n'
				{
					itS++
				}
				nowLineQ := ptrChar[strtT..(itS - strtT)]
				nowLine := nowLineQ.Str()
				Lines.Emplace(null->{MiniMachineNodeOld^},nowLine)
				itS++
				continue
			}else{
				j := itS
				isLoading := false
				while itS < mapSize and ptrChar[itS] != '\n'
				{
					if isLoading
					{
						if ptrChar[itS] == '\"'
						{
							CurWords.Emplace(ptrChar[j]&,itS - j)
							isLoading = false
						}
					}else
					{
						if ptrChar[itS]  == '\"'
						{
							isLoading = true
							j = itS + 1
						}
					}
					itS++
				}
				itS++
			}
			if CurWords.NotEmpty()
			{
				newMach := new MiniMachineNodeOld()

				for rule : CurWords
				{
					items := rule.DivideStr(" ")

					machIter := newMach

					//while someWord != null
					for word : items
					{
						stW := word.Str()
						switch stW
						{
							case "d"
								stW = "~d"
							case "s"
								stW = "~suffix"
							case "@"
								stW = "~{}type"
							case "()"
							case "[]"
							case "{}"
							case void
								Opers.Insert(stW)
						}

						k := ref machIter.WhatNext[stW]

						if k == null
							k =  new MiniMachineNodeOld()
						machIter = k
					}
					machIter.IsTerm = true
				}
				Lines.Emplace(newMach,null->{char^})
			}
		}
	}
}