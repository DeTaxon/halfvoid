
MiniMachineNodeOld := class 
{
	WhatNext := AVLMap.{char^,MiniMachineNodeOld^}
	IsTerm := bool

	this := !() -> void
	{
		WhatNext."this"()
		IsTerm = false
	}
	GetNext := !(string item) -> MiniMachineNodeOld^
	{
		inIt := WhatNext.TryFind(item)
		if inIt != null return inIt^
		return null
	}
}

LexMachineInfo := class
{
	Machine := MiniMachineNodeOld^
	RawLine := char^

	uniqOnly := bool
	uniqs := AVLSet.{char^}^

	this := !(MiniMachineNodeOld^ inM,char^ rLine) -> void
	{
		Machine = inM
		RawLine = rLine
	}
}
PriorityBagOld := class
{
	Opers := AVLSet.{string}
	Lines := List.{LexMachineInfo}

	this := !(char^ ptrChar, int mapSize) -> void
	{		
		fileSpan := StringSpan(ptrChar,mapSize)

		reg := "r?\"((\\\\ [^]) | [^\"\\\\])*\""reg

		fileSpan.DivideStr("\n",ln ==> {
			if ln.Size() == 0
				return void
			if ln[0] == '#'
			{
				Lines.Emplace(null,ln.Str())
			}else{
				newMach := new MiniMachineNodeOld

				uns := new AVLSet.{char^}
				lineUniq := true

				ln.DivideStr(reg,word ==> {
					rawWord := word[1..-1]
					
					wordContainUniq := false
					machIter := newMach
					rawWord.DivideStr(" ",ruleWord ==> {
						stW := ruleWord.Str()
						switch stW
						{
							case "d" stW = "~d"
							case "s" stW = "~suffix"
							case "@" stW = "~{}type"
							case "()" case "[]" case "{}"
							case void
								wordContainUniq = true
								uns.Insert(stW)
								Opers.Insert(stW)
						}
						next := ref machIter.WhatNext[stW]
						if next == null
							next = new MiniMachineNodeOld
						machIter = next
					})
					if not wordContainUniq
						lineUniq = false
					machIter.IsTerm = true
				})

				Lines.Emplace(newMach,ln.Str())
				newLine := ref Lines.Back()
				newLine.uniqs = uns
				newLine.uniqOnly = lineUniq
			}
		})
		//for it : Lines
		//{
		//	printf("line %i %s\n",it.uniqOnly,it.RawLine)
		//}
	}
}