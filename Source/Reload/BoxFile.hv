AppendClass BoxFile
{
	ReloadFile := !(HotloadContext^ ctx,File^ newFile) -> void
	{
		thisData := newFile.GetBlob()
		toks := LoadFile(newFile,thisData,true)

		ReloadFunctions(ctx,newFile,thisData,toks)
		ReloadClasses(ctx,newFile,thisData,toks)
	}

	ReloadClasses := !(HotloadContext^ ctx, File^ newFile, Blob^ thisData, Token^ toks) -> void
	{
		classes := ParseClasses(toks)

		newHashs := AVLMap.{Token^,u32}
		classNames := List.{Tuple.{String^,Token^}}

		for iter : classes
		{
			stVal := iter.Down.Right

			name := String^
			if stVal.Left is TokenString
			{
				name = stVal.Left->{TokenString^}.Value
			}else if stVal.Left is TokenIndent
			{
				name = stVal.Left->{TokenIndent^}.Value.GetString()
			}else{
				assert(false)
			}
			c := PClassParser(stVal.Right)

			newHashs[iter] = c.ComputeHash(thisData)
			classNames.Push(!{name,iter})
		}

		notFoundClass := List.{BoxClassBody^}
		for cls : FileClasses
		{
			if cls.hash in newHashs.Values
				continue

			foundClass := Token^
			className := String^

			for it : classNames
			{
				if it.0^ != cls.ItName
					continue
				foundClass = it.1
				className = it.0
			}
			if foundClass != null
			{
				cls.ReloadClass(ctx,foundClass.Down.Right.Right,thisData)
				cls.hash = PClassParser(foundClass.Down.Right.Right).ComputeHash(thisData)
			}
		}
	}

	ReloadFunctions := !(HotloadContext^ ctx, File^ newFile, Blob^ thisData, Token^ toks) -> void
	{
		
		fncs := ParseFunctions(toks)

		newHashs := AVLMap.{Token^,u32}
		newFuncNames := List.{Tuple.{String^,Token^}}

		for iter : fncs
		{
			stVal := iter.Down.Right

			c := PFunctionParser(stVal.Right)
			crc := c.ComputeHash(thisData)
			newHashs[iter] = crc

			name := String^
			if stVal.Left is TokenString
			{
				name = stVal.Left->{TokenString^}.Value
			}else if stVal.Left is TokenIndent
			{
				name = stVal.Left->{TokenIndent^}.Value.GetString()
			}else{
				assert(false)
			}

			newFuncNames.Emplace(name,iter)
		}

		foundFunctions := AVLSet.{Token^}

		for c : Functions
		{
			if c is not in BoxFuncTemplateBody
				continue
			thisFunc := c->{BoxFuncTemplateBody^}
			
			foundFunc := Token^
			for it : newFuncNames
			{
				if it.0^ != thisFunc.Name
					continue
				foundFunc = it.1
				break
			}

			if foundFunc != null
			{
				foundFunctions.Insert(foundFunc)
			}

			if thisFunc.hash in newHashs.Values
				continue

			if foundFunc != null
			{
				//TODO check header types
				d := PFunctionParser(foundFunc.Down.Right.Right)
				thisFunc.ReloadFunctions(ctx,d,thisData)
			} else {
				DeleteFunction(thisFunc)
			}
		}
		for it : newFuncNames
		{
			if foundFunctions.Contain(it.1)
				continue

			d := PFunctionParser(it.1.Down.Right.Right)
			CreateFunc(GetConstStringSpan(it.0.AsStringSpan()),false,d&,null)
		}
		
	}
	DeleteFunction := !(BoxFuncTemplate^ delFunc) -> void
	{
		Functions.DeleteIf(@1 == delFunc)
		CodeSpaces[^].Templates[^].DeleteIf(@1 == delFunc) //TODO optimize
	}
}
