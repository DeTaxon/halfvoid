TryParseEnum := !(Token^ tkn) -> BoxEnum^
{
	if tkn == null or tkn.Down == null or tkn.Down.GetValue() != "enum"
		return null
	
	resEnum := new BoxEnum(tkn.Down)

	return resEnum
}

BoxEnum := class extend BoxUnit
{
	ItType := TypeEnum^
	ReadyState := THatch
	Values := HybridQueue.{Tuple.{BoxExeString^,BoxEnumValue^},10}
	EnumToken := Token^
	Parent := BoxEnum^

	CStrTable := GlobalVar2^

	this := !(Token^ datToken) -> void
	{
		ItType = new TypeEnum()
		ItType.ToEnum = this&
		EnumToken = datToken
	}

	GetType := !() -> void
	{
		AwaitReadyState()
		return itType
	}

	AwaitReadyState := !() -> void
	{
		ParseBody()
		ReadyState.Await()
	}

	startedParse := bool
	ParseBody := !() -> void
	{
		if startedParse
			return void
		startedParse = true

		SubWork(() ==>{
			iter := EnumToken.Right

			baseType := GTypeInt->{TypeStandard^}

			if iter.GetValue() == "extend"
			{
				iter = iter.Right

				exType := ParseType(iter)

				if exType == null
					iter.EmitError("unknown extended type")

				if IsInt(exType)
				{
					baseType = exType->{TypeStandard^}
				}else if exType is TypeEnum{
					asEnum := exType->{TypeEnum^}.ToEnum

					asEnum.AwaitReadyState()
					baseType = asEnum.ItType

					for it : asEnum.Values
					{
						Values.Emplace(it.0,it.1)
					}
					Parent = asEnum
				}else{
					iter.EmitError("unknown extended type")
				}
				

				iter = iter.Right.Down
			}else{
				iter = iter.Down
			}

			while iter != null
			{
				if iter.GetValue() != ","
				{
					if iter is TokenString
					{
						Values.Emplace(GetExeString(iter->{TokenString^}.Value),null->{BoxEnumValue^})
					}else{
						iter.EmitError("Unknown use of enum")
					}
				}
				iter = iter.Right
			}
			ItType.Base = baseType
			ItType.IRName = baseType.IRName
			ItType.MetaInfo = baseType.MetaInfo
			ItType.ItSize  = baseType.ItSize
			ItType.ItAlign = baseType.ItAlign

			ReadyState.Emit()
		})
	}

	GetEnum := !(StringSpan val) -> BoxExeObj^
	{
		AwaitReadyState()
		for it,i : Values
		{
			if it.0.val == val
			{
				if it.1 == null
					it.1 = new BoxEnumValue(ItType,i)
				return it.1
			}
		}
		return null
	}
	storeFunc := BoxFunc^
	GetSetFunc := !() -> BoxFunc^
	{
		AwaitReadyState()
		if storeFunc == null
			storeFunc = new BuiltInPrimeStore(GetFuncType(![ItType,ItType],![true,false],GTypeVoid))
		return storeFunc
	}
	cmpFunc := BoxFunc^
	GetCmpFunc := !() -> BoxFunc^
	{
		AwaitReadyState()
		if cmpFunc == null
			cmpFunc = new BuiltInIntBase(GetFuncType(![ItType,ItType],GTypeBool),"icmp eq")
		return cmpFunc
	}
}

TypeEnum := class extend TypeStandard
{
	ToEnum := BoxEnum^
	this := !() -> void
	{
		super("i32","Enum","!DIBasicType(name: \"enum\", size: 32, align: 32,encoding: DW_ATE_signed)",4,4)
	}
	GetAlign := virtual !() -> int
	{
		ToEnum.AwaitReadyState()
		return super()
	}
	GetSize := virtual !() -> int
	{
		ToEnum.AwaitReadyState()
		return super()
	}
}

BoxEnumValue := class extend BoxExeObj
{
	ItValue := int
	this := !(TypeEnum^ itType, int itValue) -> void
	{
		ObjType = itType
		ItValue = itValue
	}
	PrintUse := virtual !(LLVMWriteContext^ ctx) -> void
	{
		ctx.writeStream^ << ItValue
	}
	PrintConst := virtual !(LLVMWriteContext^ ctx) -> void
	{
		ctx.writeStream^ << ItValue
	}
}

GetEnumMethodCall := !(Token^ itm,BoxExeObj^ vr,BoxExeObj^[] objs,BoxExeConstObj^[] consts) -> BoxExeObj^
{
	if itm.Down.Right.Right is not TokenIndent
		return null

	itName := itm.Down.Right.Right->{TokenIndent^}.Value
	if itName == "ToCStr"
	{
		return CreateFuncCall(StringSpan("internalEnumToCString"),![vr])
	}
}

enumGetCStrTable := !(Type^ enumType) -> BoxExeObj^
{
	if enumType is not in TypeEnum
		return null
	tp := enumType->{TypeEnum^}.ToEnum

	tp.AwaitReadyState()

	if tp.CStrTable == null
	{
		valCount := tp.Values.Size()
		globType := GTypeChar.GetPoint().GetArray(tp.Values.Size() + 1)
		tp.CStrTable = CreateGlobalVar(StringSpan("."),globType,false)

		setArr := new ClassArray(globType)
		for it : tp.Values
		{
			setArr.Value.Push(it.0)
		}
		setArr.Value.Push(GObjNull)

		tp.CStrTable.value = setArr 
	}

	return tp.CStrTable.proxy&
}
