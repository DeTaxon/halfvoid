
GUsingCacheFile := bool
GCacheFile := ZipRWFile^

OpenCacheFile := !(char^ fileName) -> void
{
	GUsingCacheFile = true
	GCacheFile = new ZipRWFile(fileName)
	
	
	blobCacheMeta := GCacheFile.TryGetFile("BlobCache.txt")
	if blobCacheMeta != null
	{
		mp := blobCacheMeta.GetMap()

		spn := StringSpan(mp.Get()->{char^},mp.Size())

		spn.DivideStr("\n", x ==> {
			while true
			{
				val := x
				yield void
				CacheBlobList.Emplace()
				newEntry := ref CacheBlobList[CacheBlobList.Size() - 1]
				newEntry.key = val.GetString()
				newEntry.fileName = x.GetString()
				yield void
			}
		})
	}
}


BlobCacheData := class
{
	key := String^
	fileName := String^
	value := BoxRawData^
	changed := bool
	loaded := bool

	this := !() -> void {}
	"=" := default
}

CacheChangedBlobData := bool
CacheBlobList  := List.{BlobCacheData} //TODO Optimize

CacheBlobByStringReg := !(StringView value, !()&-> BoxRawData^ cb) -> BoxRawData^
{
	if not GUsingCacheFile
		return cb()

	for it : CacheBlobList
	{
		if it.key == value
		{
			if not it.loaded
			{
				fileInZip := GCacheFile.TryGetFile(it.fileName)
				assert( fileInZip != null)
				if fileInZip != null
				{
					mp := fileInZip.GetMap()//TODO case of empty file
					cpyData := malloc(mp.Size()) //TODO memory leak?
					memcpy(cpyData,mp.Get(),mp.Size())
					newBlob := new BoxRawData(cpyData->{u8^},mp.Size())
					it.loaded = true
					return newBlob
				}
			}
		}
	}

	CacheChangedBlobData = true
	newBlob := cb()

	newId := 0
	buf := char[255]
	while true
	{
		found := false
		sprintf(buf[0]&,"CacheBlob%i",newId)
		for it : CacheBlobList
		{
			if it.fileName == buf
			{
				found = true
				break
			}
		}
		if found
		{
			newId += 1
		}else{
			break
		}
	}

	CacheBlobList.Emplace()
	newEntry := ref CacheBlobList[CacheBlobList.Size() - 1]
	newEntry.key = value.GetString()

	newEntry.fileName = new String(buf[0]&)
	newEntry.value = newBlob
	newEntry.changed = true
	newEntry.loaded = true

	return newBlob
}
FinilizeCache := !() -> void
{
	if not GUsingCacheFile
		return void
	
	if CacheChangedBlobData
	{
		assert(CacheBlobList.Size() != 0)

		MetaCache := TEchoStream
		for it : CacheBlobList
		{
			if it.changed
			{
				vl := TArraySpan.{u8}(it.value.Value,it.value.ValueSize)
				GCacheFile.WriteFile(it.fileName,vl&)
			}
			MetaCache << it.key << "\n" << it.fileName << "\n"
		}
		metaData := MetaCache.GetString()
		
		vl := TArraySpan.{u8}(metaData.Str()->{u8^},metaData.Size())
		GCacheFile.WriteFile("BlobCache.txt",vl)
	}

	//for it : CodeSpaces
	//{
	//	for fl : it.Files
	//	{
	//		itPath := fl.file.GetPath()
	//		SerializeTokens(itPath,fl.fileTokens)
	//	}
	//}
}

SerializeTokens := !(StringView fName,Token^ tkn) -> void
{
	streamedLine := FileLine^

	if tkn == null
	{
		dat := TArraySpan.{u8}(null,0)
		GCacheFile.WriteFile(fName,dat)
	}else{
		echo := TEchoStream
		SerializeTokenInner(echo&,tkn,streamedLine)

		wackyData := echo.GetString()
		dat := TArraySpan.{u8}(wackyData.NonNullStr()->{u8^},wackyData.Size())
		GCacheFile.WriteFile(fName,dat)
	}

}

SerializeTokenInner := !(Stream^ strm, Token^ itToken,FileLine^& streamedLine) -> void
{
	assert(itToken != null)
	x := s32
	if streamedLine != itToken.Line
	{
		streamedLine = itToken.Line
		x = 1
		strm.Write(x&,4)
		strm.Write(itToken.Line.Line&,4)
	}
	subs := s32
	itr := itToken.Down
	while itr != null
	{
		subs += 1
		itr = itr.Right
	}
	
	strm.Write(subs&,4)
	if itToken is Token
	{
		x = 100
		strm.Write(x&,4)
	}else if itToken is TokenDecor
	{
		decor := itToken->{TokenDecor^}
		x = 101
		strm.Write(x&,4)
		x = decor.Value.Size()
		strm.Write(x&,4)
		strm^ << decor.Value
	}else if itToken is TokenData
	{
		x = 102
		strm.Write(x&,4)
	}else if itToken is TokenBlockData
	{
		x = 103
		strm.Write(x&,4)
	}else if itToken is TokenNull
	{
		x = 104
		strm.Write(x&,4)
	}else if itToken is TokenNone
	{
		x = 105
		strm.Write(x&,4)
	}else if itToken is TokenBool
	{
		x = 106
		strm.Write(x&,4)
		if itToken->{TokenBool^}.Parsed
		{
			x = 1
		}else{
			x = 0
		}
		strm.Write(x&,4)
	}else if itToken is TokenWayControl
	{
		decor := itToken->{TokenWayControl^}
		x = 107
		strm.Write(x&,4)
		x = decor.Value.Size()
		strm.Write(x&,4)
		strm^ << decor.Value
	}else if itToken is TokenSuffix
	{
		decor := itToken->{TokenSuffix^}
		x = 108
		strm.Write(x&,4)
		x = decor.Value.Size()
		strm.Write(x&,4)
		strm^ << decor.Value
	}else if itToken is TokenSymbol
	{
		decor := itToken->{TokenSymbol^}
		x = 109
		strm.Write(x&,4)
		x = decor.Value.Size()
		strm.Write(x&,4)
		strm^ << decor.Value
	}else if itToken is TokenIndent
	{
		decor := itToken->{TokenIndent^}
		x = 110
		strm.Write(x&,4)
		x = decor.Value.Size()
		strm.Write(x&,4)
		strm^ << decor.Value
	}else if itToken is TokenTemplateType
	{
		decor := itToken->{TokenTemplateType^}
		x = 111
		strm.Write(x&,4)
		x = decor.Value.Size()
		strm.Write(x&,4)
		strm^ << decor.Value
	}else if itToken is TokenString
	{
		decor := itToken->{TokenString^}
		x = 112
		strm.Write(x&,4)
		x = decor.Value.Size()
		strm.Write(x&,4)
		strm^ << decor.Value
	}else if itToken is TokenDouble
	{
		decor := itToken->{TokenDouble^}
		x = 112
		strm.Write(x&,4)
		x = decor.Value.Size()
		strm.Write(x&,4)
		strm^ << decor.Value
	}else if itToken is TokenInt
	{
		decor := itToken->{TokenInt^}
		x = 113
		strm.Write(x&,4)
		x = decor.Value.Size()
		strm.Write(x&,4)
		strm^ << decor.Value
	}else if itToken is TokenString
	{
		decor := itToken->{TokenInt^}
		x = 114
		strm.Write(x&,4)
		x = decor.Value.Size()
		strm.Write(x&,4)
		strm^ << decor.Value
	} else {
		printf("hm %s\n",itToken.GetValue())
		assert(false)
	}

	itr = itToken.Down
	while itr != null
	{
		SerializeTokenInner(strm,itr,streamedLine)
		itr = itr.Right
	}
}


