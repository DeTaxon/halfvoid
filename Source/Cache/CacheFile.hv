
GUsingCacheFile := bool
GCacheFile := ZipRWFile^
CFile := CacheFile^

OpenCacheFile := !(char^ fileName) -> void
{
	GUsingCacheFile = true
	CFile = new CacheFile(fileName)
	GCacheFile = CFile.zipFile
}


TryGetCacheOfFile := !(vRepoFile^ fl) -> Blob^
{
	if not GUsingCacheFile
		return null
	inRep := GCacheFile.TryGetFile(fl.GetPath())
	if inRep == null
		return null
	fileTime := fl.GetModificationTime()
	cacheTime := inRep.GetModificationTime()

	if (fileTime - cacheTime)->{s64} > 0 //TODO fileTime > cacheTime does not work
	{
		return null
	}else{
		mp := inRep.GetMap()
		resBlob := new BlobOnVector(mp.Size())
		if mp.Size() != 0
			memcpy(resBlob.GetPointer(),mp.Get(),mp.Size())
		return resBlob
	}
}



CacheBlobByStringReg := !(StringView value, !()&-> BoxRawData^ cb) -> BoxRawData^
{
	if not GUsingCacheFile
		return cb()

	cb2 := cb
	resBlob := BoxRawData^
	blb := CFile.CacheBlobByString(value,() ==> {
		resBlob = cb2()
		bl := new BlobOnVector(resBlob.ValueSize)
		memcpy(bl.GetPointer(),resBlob.Value,bl.Size())
		return bl->{Blob^}
	})
	
	if resBlob != null
		return resBlob
	
	why := malloc(blb.Size())
	memcpy(why,blb.GetPointer(),blb.Size())
	resBlob = new BoxRawData(why->{u8^},blb.Size())
	return resBlob

}
FinilizeCache := !() -> void
{
	if not GUsingCacheFile
		return void
	
	CFile.Flush()

	for it : CodeSpaces
	{
		for fl : it.Files
		{
			if fl.tokensChanged
			{
				SerializeTokens(fl.file,fl.fileTokens)
			}
		}
	}
	GCacheFile.Flush()
}



