
ConstStrings := AVLMap.{char^,StringSpan}

GetConstStringSpan := !(StringSpan val) -> ref StringSpan
{
	return GetConstString(val.GetString().Str())
}
GetConstString := !(char^ val) -> ref StringSpan
{
	if ConstStrings.Contain(val)
		return ConstStrings[val]
	stSize := strlen(val)
	v2 := malloc(stSize + 1)->{char^}
	memcpy(v2,val,stSize)
	v2[stSize] = 0
	spn := StringSpan(v2,stSize)
	ConstStrings[v2] = spn
	return ConstStrings[val]
}


PackedExeObj := class extend BoxExeObj
{
	preCalls := List.{BoxExeObj^}
	mainCall := BoxExeObj^	
	postCalls := List.{BoxExeObj^}

	GetType := virtual !() -> Type^
	{
		return mainCall.GetType()
	}
	IsMem := virtual !() -> bool
	{
		return mainCall.IsMem()
	}
	PrintDefaultUse := virtual !(LLVMWriteContext^ ctx) -> void
	{
		if IsMem()
		{
			PrintPointPre(ctx)
		}else{
			PrintPre(ctx)
		}
	}
	PrintPointPre := virtual !(LLVMWriteContext^ ctx) -> void
	{
		preCalls[^].PrintDefaultUse(ctx)
		mainCall.PrintPointPre(ctx)
		postCalls[^].PrintDefaultUse(ctx)
	}
	PrintPointUse := virtual !(LLVMWriteContext^ ctx) -> void
	{
		mainCall.PrintPointUse(ctx)
	}
	PrintPre := virtual !(LLVMWriteContext^ ctx) -> void
	{
		preCalls[^].PrintDefaultUse(ctx)
		mainCall.PrintPre(ctx)
		postCalls[^].PrintDefaultUse(ctx)
	}
	PrintUse := virtual !(LLVMWriteContext^ ctx) -> void
	{
		mainCall.PrintUse(ctx)
	}

}
BlankObjectExe := class extend BoxExeObj
{
	IsRefObj := bool
	this := !(Type^ tp,bool isRef) -> void
	{
		ObjType = tp
		IsRefObj = isRef
	}
	IsMem := virtual !() -> bool
	{
		return IsRefObj
	}
}
