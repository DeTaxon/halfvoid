TryGetSuffixCall := !(Token^ itm) -> BoxExeObj^
{
	if itm.Down?.Right? is TokenSuffix
	{
	}else{
		return null
	}

	downVal := TryGetExeCall(itm.Down)
	if downVal == null
		return null

	suffixName := itm.Down.Right->{TokenSuffix^}.Value

	if suffixName == "reg" and downVal is BoxExeString and not DisableScary//todo make it possible to create Blobs in library
	{
		
		regBlob := BoxRawData^
		regBlobSize := int

		if not RegexpBlobs.Contain(suffixName)
		{
			lx := LexBuilder
			stName := downVal->{BoxExeString^}.val.GetString()
			lx.ApplyReg(stName.Str())
			machine :=  lx.GenerateMachine() //TODO_CACHE

			blobSize := RegexpAsBlob->TypeSize + machine.ComputeBlobSize()
			newBlobVoid := malloc(blobSize)
			ZeroMem(newBlobVoid->{RegexpAsBlob^}^)
			machine.SerializeToMap(newBlobVoid->{RegexpAsBlob^}.blobData[0]&)

			regBlob = new BoxRawData(newBlobVoid->{u8^},blobSize)
			blobDatas.Push(regBlob)

			RegexpBlobs[suffixName] = !{regBlob,regBlobSize}
		}else{
			regBlob = RegexpBlobs[suffixName].0
			regBlobSize = RegexpBlobs[suffixName].1
		}


		objs := CheckExeDownList
		objs.Push(regBlob)
		objs.Push(GetExeInt(regBlobSize))
		cnsts := List.{BoxExeConstObj^}
		res := CreateFuncCall(StringSpan("internalRegexpRetrive"),objs,cnsts)
		assert(res != null)
		return res
	}

	stt := TEchoStream
	stt << "suffix " << suffixName

	st := GetConstString(stt.GetString().Str())
	objs := CheckExeDownList
	objs.Push(downVal)
	resFunc := CreateFuncCall(st,objs)
	if resFunc == null
		itm.EmitError("suffix call not found")
	return resFunc
}

RegexpBlobs := AVLMap.{StringSpan,Tuple.{BoxRawData^,int}}
