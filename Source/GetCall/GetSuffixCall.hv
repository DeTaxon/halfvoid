TryGetSuffixCall := !(Token^ itm) -> BoxExeObj^
{
	if itm.Down?.Right? is TokenSuffix
	{
	}else{
		return null
	}

	downVal := TryGetExeCall(itm.Down)
	if downVal == null
		return null

	suffixName := itm.Down.Right->{TokenSuffix^}.Value

	if suffixName == "reg" and downVal is BoxExeString and not DisableScary//todo make it possible to create Blobs in library
	{
		
		regBlob := BoxRawData^
		regBlobSize := int


		stName := downVal->{BoxExeString^}.val.GetString()

		if not RegexpBlobs.Contain(stName)
		{
			regBlob = CacheBlobByStringReg(stName, x ==> {
				lx := LexBuilder
				lx.ApplyReg(stName.Str())
				machine :=  lx.GenerateMachine()

				blobSize := RegexpAsBlob->TypeSize + machine.ComputeBlobSize()
				newBlobVoid := malloc(blobSize)
				ZeroMem(newBlobVoid->{RegexpAsBlob^}^)
				machine.SerializeToMap(newBlobVoid->{RegexpAsBlob^}.blobData[0]&)

				return new BoxRawData(newBlobVoid->{u8^},blobSize)
			})
			
			blobDatas.Push(regBlob)
			RegexpBlobs[stName] = !{regBlob,regBlobSize}
		}else{
			regBlob = RegexpBlobs[stName].0
			regBlobSize = RegexpBlobs[stName].1
		}


		objs := CheckExeDownList
		objs.Push(regBlob)
		objs.Push(GetExeInt(regBlobSize))
		cnsts := List.{BoxExeConstObj^}
		res := CreateFuncCall(StringSpan("internalRegexpRetrive"),objs,cnsts)
		assert(res != null)
		return res
	}

	stt := TEchoStream
	stt << "suffix " << suffixName

	st := GetConstString(stt.GetString().Str())
	objs := CheckExeDownList
	objs.Push(downVal)
	resFunc := CreateFuncCall(st,objs)
	if resFunc == null
		itm.EmitError("suffix call not found")
	return resFunc
}

RegexpBlobs := AVLMap.{String^,Tuple.{BoxRawData^,int}}
