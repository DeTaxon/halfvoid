TryGetAndOrCall := !(Token^ itm) -> BoxExeObj^
{
	oper := itm.Down.Right.GetValue()

	qc := QCatch^
	stackSize := UnitStack.Size()

	if oper == "or"
	{
		qc = new QCatch
		UnitStack.PushFront(qc)
	}
	cl1 := TryGetExeCall(itm.Down)
	if cl1 == null
		return null

	while stackSize < UnitStack.Size()
		UnitStack.Pop()

	cl2 := TryGetExeCall(itm.Down.Right.Right)
	if cl2 == null
		return null

	if oper == "or"
		return new BoxOr(cl1,cl2,qc)
	return new BoxAnd(cl1,cl2)
}


BoxAndOr := class extend BoxExeObj
{
	LeftCall := BoxExeObj^
	RightCall := BoxExeObj^

	resId := int
	TruePath := BoxLabel^
	NextPath := BoxLabel^
	FalsePath := BoxLabel^
	EndLabel := BoxLabel^

	CommonInit := !(BoxExeObj^ cl1,BoxExeObj^ cl2) -> void
	{
		LeftCall = cl1
		RightCall = cl2

		ObjType = GTypeBool

		TruePath = new BoxLabel()
		FalsePath = new BoxLabel()
		if NextPath == null
			NextPath = new BoxLabel()
		EndLabel = new BoxLabel()
	}

	IsMem := virtual !() -> bool { return false }

	PrintUse := virtual !(LLVMWriteContext^ ctx) -> void
	{
		ctx.writeStream^ << "%T" << resId
	}
	PrintStep1 := virtual !(LLVMWriteContext^ ctx) -> void
	{
		LeftCall.PrintPre(ctx)

	}
	PrintStep3 := virtual !(LLVMWriteContext^ ctx) -> void
	{
		f := ctx.writeStream

		NextPath.PrintLabelCreate(ctx)
		RightCall.PrintPre(ctx)

		PrintBranch(ctx,RightCall,TruePath,FalsePath)

		TruePath.PrintLabelCreate(ctx)
		EndLabel.PrintGo(ctx)
		FalsePath.PrintLabelCreate(ctx)
		EndLabel.PrintGo(ctx)

		EndLabel.PrintLabelCreate(ctx)
		f^ << "%T" << resId << " = phi i1 [1,"
		TruePath.PrintLabel(ctx)
		f^ << "], [0,"
		FalsePath.PrintLabel(ctx)
		f^ << "]"
		if DebugMode 
			f^ << ", !dbg !" << GDebugLineCallId
		f^ << "\n"
	}
}
BoxAnd := class extend BoxAndOr
{
	this := !(BoxExeObj^ cl1,BoxExeObj^ cl2) -> void
	{
		CommonInit(cl1,cl2)
	}
	PrintPre := virtual !(LLVMWriteContext^ ctx) -> void
	{
		resId = ctx.GetNewId()
		PrintStep1(ctx)
		PrintBranch(ctx,LeftCall,NextPath,FalsePath)
		PrintStep3(ctx)
	}
}
BoxOr := class extend BoxAndOr
{
	this := !(BoxExeObj^ cl1,BoxExeObj^ cl2,QCatch^ qc) -> void
	{
		if qc != null
			NextPath = qc.ItLabel
		CommonInit(cl1,cl2)
	}
	PrintPre := virtual !(LLVMWriteContext^ ctx) -> void
	{
		resId = ctx.GetNewId()
		PrintStep1(ctx)
		PrintBranch(ctx,LeftCall,TruePath,NextPath)
		PrintStep3(ctx)
	}
}
PrintBranch := !(LLVMWriteContext^ ctx, BoxExeObj^ cmp, BoxLabel^ onTrue, BoxLabel^ onFalse) -> void
{
	f := ctx.writeStream

	f^ << "br i1 "
	cmp.PrintUse(ctx)
	f^ << ", label "
	onTrue.PrintLabel(ctx)
	f^ << ", label "
	onFalse.PrintLabel(ctx)
	if DebugMode
		f^ << ", !dbg !" << GDebugLineCallId
	f^ << "\n"
}
