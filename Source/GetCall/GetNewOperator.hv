TryGetNewDeleteOperator := !(Token^ itm) -> BoxExeObj^
{
	if itm.Down == null
		return null

	objPos := itm.Down
	allocObj := BoxExeObj^

	if objPos.GetValue() not in !["new","delete"]
	{
		if objPos.Right?.GetValue() == "." 
			and objPos.Right.Right?.GetValue() in !["new","delete"]
		{
			allocObj = TryGetExeCall(itm.Down)
			if allocObj == null
				return null
			objPos = objPos.Right.Right
		}else{
			return null
		}
	}

	if allocObj == null
	{
		allocObj = CreateFuncCall("GetAllocator",![])
	}

	assert(allocObj != null)

	if objPos.GetValue() == "new"
	{
		resObj := new PackedExeObj

		tp := ParseType(objPos.Right)
		if tp == null
		{
			CurrentWork?.SetErrorMessage(objPos.Right.MakeError("Unknown type"))
			return null
		}

		resCall := BoxExeObj^
		resVar := LocalVar^

		typeSize := GetExeInt(tp.GetSize())

		if allocObj != null
		{
			consts := Vector.{BoxExeConstObj^}
			createCall := innerTryGetMethodCall("AllocMem",allocObj,![typeSize,GBoolFalse],consts)

			if createCall == null
				return null

			resVar = ToLocalVar(GetExchange2(createCall,tp.GetPoint(),false))

			//resVar.extraWork.Push(CreateFuncCall("memset",![resVar.CreateVarCall(),0hv,typeSize]))

			if tp is in TypeClass //TODO only if virtual?
			{
				initer := CreateFuncCall("internalHVInitClass",![new PtrToRef(resVar.CreateVarCall())])
				resVar.extraWork.Push(initer)
			}

		}else{
			fnc := TemplateInternalNewOne.GetFunc(![],![tp])
			assert(fnc != null)
			resCall = fnc.CreateCall(![])
			resVar = ToLocalVar(resCall)
		}

		if objPos.Right.Right?.GetValue() == "()"
		{
			iObjs := FuncInputObjects
			iObjs.Objs.Push(resVar.CreateVarCall())
			if not CheckFuncCallBrackets(objPos.Right.Right,iObjs&)
				return null

			if tp is TypeClass
			{
				cls := tp->{TypeClass^}.ToClass
				callFunc := BoxUnit^
				zeroConsts := List.{BoxExeConstObj^}
				cls.GetMethods("this",x ==> {
					callFunc = GetBestFunc(x,iObjs.Objs,zeroConsts)
				})
				if callFunc == null
				{
					CurrentWork?.SetErrorMessage(objPos.Right.Right.MakeError("Constructor not found"))
					return null
				}
				assert(callFunc is in BoxFunc)

				constrCall := callFunc->{BoxFunc^}.CreateCall(iObjs.Objs,iObjs&)
				resVar.extraWork.Push(constrCall)

				assert(constrCall != null)

			}else{
				assert(false)
			}
		}
		return new ConstructorCallWrapper(resVar,resVar.CreateVarCall())
	}
	if objPos.GetValue() == "delete"
	{
		dwn := TryGetExeCall(objPos.Right)
		if dwn == null
			return null

		if allocObj != null
		{
			consts := Vector.{BoxExeConstObj^}
			return innerTryGetMethodCall("FreeMem",allocObj,![dwn],consts)
		}

		return FunctionInternalDelete.CreateCall(![dwn])
	}
}
