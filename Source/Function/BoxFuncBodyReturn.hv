AppendClass BoxFuncBody
{
	returnHolder := ReturnsHolder
	//inlineFunctions := List.{FuncInlineWrapper^}

	printResultVar := bool //TODO way too weird
	createVoidResultVar := bool

	CheckReturnStep := !() -> void
	{
		assert(Attrs.IsAutoResult)

		ObjType = returnHolder.CheckReturnStep(ObjType->{TypeFunc^})

		ResultTypeHatch.Emit()
	}
	ResolveReturnVars := !() -> void
	{
		returnHolder.ResolveReturnVars()
	}
	CreateResultVar := !() -> void
	{
		assert(ResultVar == null)

		tp := ObjType->{TypeFunc^}
		
		if tp.ResultType != GTypeVoid
		{
			resSpn := StringSpan("result")
			if tp.ResultType.IsComplexReturn() and not tp.ResultRef
			{
				ResultVar = new LocalVar(resSpn,tp.ResultType,true,true)
				getRes := new GetFuncResultVar(ResultVar,tp.ResultType.GetPoint())
				ResultVar.SetCall(getRes)
			}else{
				rFuncType := tp.ResultType
				if tp.ResultRef
					rFuncType = rFuncType.GetPoint()

				ResultVar = new LocalVar(resSpn,rFuncType,true,false)
				access := new FuncLocalVarAccess(ResultVar,rFuncType)
				ResultVar.SetCall(access)

				createCall := new FuncLocalVarCleanup(access)
				ResultVar.createVar.Push(createCall)

				printResultVar = true
			}
		}else
		{
			resSpn := StringSpan("result")
			ResultVar = new FuncInputVar(resSpn,GTypeVoid,true,false)
			ResultVar.SetCall(GObjVoid)
		}
	}
}
ReturnsHolder := class extend BoxUnit
{
	IsAutoResult := bool
	ResultRef := bool
	ResultType := Type^
	ResultVar := LocalVar^
	Returns := HybridQueue.{ReturnHalfState^,4}

	ReturnBlock := BoxBlock^
	ExitLabel := BoxLabel^

	CheckReturnStep := !(TypeFunc^ fncType) -> TypeFunc^
	{
		resType := GTypeNone
		returnNonMem := false

		for it : Returns
		{
			if not it.IsReturnMem()
				returnNonMem = true

			st := it.GetSetType()

			if resType == GTypeNone
			{
				resType = st
			}else{
				if resType == GTypeVoid
				{
					resType = st
				}else{
					resType = TypeFight(resType,st)
				}
			}

			if resType == null
				it.errorToken.EmitError("can not create type that satisfy all return objects")
		}
	
		result = fncType
		if resType != GTypeNone
		{
			retRef := true
			if returnNonMem
				retRef = false
			retRef = false
			result = FuncTypeSetResult(fncType,resType,retRef)
		}
		ResultType = resType
	}
	ResolveReturnVars := !() -> void
	{
		Returns[^].ResolveStep()
	}
	Reset := !() -> void
	{
		ResultType = null
		ResultVar = null
		ExitLabel = null
		Returns.Destroy()
	}
}
