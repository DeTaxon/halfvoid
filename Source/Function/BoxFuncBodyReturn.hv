AppendClass BoxFuncBody
{
	returnHolder := ReturnsHolder
	//inlineFunctions := List.{FuncInlineWrapper^}

	printResultVar := bool //TODO way too weird

	CheckReturnStep := !() -> void
	{
		assert(Attrs.IsAutoResult)

		ObjType = returnHolder.CheckReturnStep(ObjType->{TypeFunc^})

		ResultTypeHatch.Emit()
	}
	ResolveReturnVars := !() -> void
	{
		returnHolder.ResolveReturnVars()
	}
	CreateResultVar := !() -> void
	{
		assert(ResultVar == null)

		tp := ObjType->{TypeFunc^}
		
		if tp.ResultType != GTypeVoid
		{
			resSpn := StringSpan("result")
			if tp.ResultType.IsComplexReturn() and not tp.ResultRef
			{
				getRes := new GetFuncResultVar(tp.ResultType.GetPoint())
				ResultVar = new LocalVar(resSpn,tp.ResultType,true,true)
				ResultVar.SetCall(getRes)
			}else{
				rFuncType := tp.ResultType
				if tp.ResultRef
					rFuncType = rFuncType.GetPoint()

				ResultVar = new LocalVar(resSpn,rFuncType,true,false)
				access := new FuncLocalVarAccess(99999,rFuncType) //TODO better result name
				ResultVar.SetCall(access)

				createCall := new FuncLocalVarCleanup(access)
				ResultVar.createVar.Push(createCall)

				printResultVar = true
			}
		}else
		{
			resSpn := StringSpan("result")
			ResultVar = new FuncInputVar(resSpn,GTypeVoid,true,false)
			ResultVar.SetCall(new GetLocalVarVoid()) //TODO i could unit all of the new GetLocalVarVoid()
		}
	}
}
ReturnsHolder := class extend BoxUnit
{
	IsAutoResult := bool
	ResultRef := bool
	ResultType := Type^
	ResultVar := LocalVar^
	Returns := HybridQueue.{ReturnHalfState^,4}

	ReturnBlock := BoxBlock^
	ExitLabel := BoxLabel^

	CheckReturnStep := !(TypeFunc^ fncType) -> TypeFunc^
	{
		resType := GTypeNone

		for it : Returns
		{
			st := it.GetSetType()

			if resType == GTypeNone
			{
				resType = st
			}else{
				if resType == GTypeVoid
				{
					resType = st
				}else{
					resType = TypeFight(resType,st)
				}
			}

			if resType == null
				it.errorToken.EmitError("can not create type that satisfy all return objects")
		}
	
		result = fncType
		if resType != GTypeNone
		{
			result = FuncTypeSetResult(fncType,resType,false)
		}
		ResultType = resType
	}
	ResolveReturnVars := !() -> void
	{
		Returns[^].ResolveStep()
	}
}
