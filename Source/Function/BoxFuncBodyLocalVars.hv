AppendClass BoxFuncBody
{
	LocalVars := List.{LocalVar^}
	LocalVarsDeferChecks := List.{LocalVar^}

	LocalVariablesStep := !() -> void
	{
		if IsGenerator()
			return void
		for it, i : LocalVars
		{
			tp := it.GetBaseType()

			access := new FuncLocalVarAccess(i,tp)
			it.SetCall(access)

			createCall := new FuncLocalVarCleanup(access)
			it.createVar.Push(createCall)

			if it.itName.Size() >= 1 and it.itName[0] != '.'
			{
				it.createVar.Push(new FuncLocalDebugInfoDeclare(it.proxy&,it))
			}

			if tp is TypeClass
			{
				objs := CheckExeDownList
				objs.Push(access)
				cnsts := List.{BoxExeConstObj^}
				fnc := TemplateInternalInitClass.GetFunc(objs,cnsts)

				assert(fnc != null)

				it.createVar.Push(fnc.CreateCall(objs))

				if IsGCClass(tp)
				{
					defGuard := new LocalVar(StringSpan(".anon"),GTypeBool,true,false)
					defGuard.createVar.Push(new FuncLocalVarCleanup(defGuard.CreateVarCall()))
					defGuard.SetCall(new FuncLocalVarAccess(LocalVarsDeferChecks.Size() + 1000,GTypeBool)) //TODO unconst

					LocalVarsDeferChecks.Push(defGuard)
					
					objsI := CheckExeDownList
					objsI.Push(defGuard.CreateVarCall())
					objsI.Push(GBoolTrue)
					setTrue := CreateFuncCall(StringSpan("="),objsI)

					it.createVar.Push(setTrue)

					InternalsHatch.Await()
					noObjs := CheckExeDownList
					destrCall := innerTryGetMethodCall(StringSpan("Destroy"),access,noObjs,cnsts)
					createCall.deferCall = new FuncLocalCallIfTrue(defGuard.CreateVarCall(),destrCall)
				}

			}
			if IsGCPtr(tp)
			{
				defGuard := new LocalVar(StringSpan(".anon"),GTypeBool,true,false)
				defGuard.createVar.Push(new FuncLocalVarCleanup(defGuard.CreateVarCall()))
				defGuard.SetCall(new FuncLocalVarAccess(LocalVarsDeferChecks.Size() + 1000,GTypeBool)) //TODO unconst

				LocalVarsDeferChecks.Push(defGuard)

				objs := CheckExeDownList
				objs.Push(access)
				destrCall := GFuncGCSetNull.CreateCall(objs)
				createCall.deferCall = new FuncLocalCallIfTrue(defGuard.CreateVarCall(),destrCall)
			}
		}
	}
	LocalVariablesForYield := !(BoxClass^ lambdaClass) -> void
	{
		yieldVars := lambdaClass.GetField(StringSpan("yieldVars"))

		assert(yieldVars != null)

		tpl := GetYieldTuple()
		cnsts := List.{BoxExeConstObj^}
		cnsts.Push(GetConstType(tpl.ItType))

		asRawPar := new FuncInputParam(GTypeVoidP,false,StringSpan("%par0")) //TODO: way too bad
		for it, i : LocalVars
		{
			tp := it.GetBaseType()
			pth := tpl.GetFieldByIndex(i)

			asCls := GetExchange2(asRawPar.CreateCall(),lambdaClass.ItType.GetPoint(),false)

			Objs2 := CheckExeDownList
			Objs2.Push(asCls)
			yieldPtr := yieldVars.CreateCall(Objs2)
			assert(yieldPtr != null)

			objs3 := CheckExeDownList
			objs3.Push(yieldPtr)
			access := pth.CreateCall(objs3)

			it.SetCall(access)

			createCall := new FuncLocalVarCleanup(access)
			it.createVar.Push(createCall)

			if tp is TypeClass
			{
				objs := CheckExeDownList
				objs.Push(access)
				cnsts := List.{BoxExeConstObj^}
				fnc := TemplateInternalInitClass.GetFunc(objs,cnsts)

				assert(fnc != null)

				it.createVar.Push(fnc.CreateCall(objs))

				if IsGCClass(tp)
				{
					InternalsHatch.Await()
					noObjs := CheckExeDownList
					destrCall := innerTryGetMethodCall(StringSpan("Destroy"),access,noObjs,cnsts)
					createCall.deferCall = new BoxDefer(destrCall)
				}
			}
		}
		asRawPar.PopulateCalls()
	}
	PrintLocalVars := !(LLVMWriteContext^ ctx) -> void
	{
		f := ctx.writeStream

		for it,i : LocalVars
		{
			tp := it.GetBaseType()
			f^ << "%Var" << i << " = alloca "
			tp.PrintType(ctx)
			f^ << "\n"
		}
		for it,i : LocalVarsDeferChecks
		{
			tp := it.GetBaseType()
			f^ << "%Var" << (i + 1000) << " = alloca "
			tp.PrintType(ctx)
			f^ << "\n"
			it.PrintCode(ctx)
		}
	}
}

FuncLocalVarCleanup := class extend BoxExeObj
{
	getVal := BoxExeObj^
	deferCall := BoxExeObj^

	baseType := Type^
	this := !(BoxExeObj^ gV) -> void
	{
		baseType = gV.GetType()
		getVal = GetExchange2(new UnrefFuncCall(gV),GTypeVoidP,false)
	}
	PrintDefaultUse := virtual !(LLVMWriteContext^ ctx) -> void
	{
		f := ctx.writeStream
		getVal.PrintPre(ctx)

		f^ << "call  void @llvm.memset.inline.p0.p0i8.i32(i8* "
		getVal.PrintUse(ctx)
		f^ << ", i8 0, i32 " << baseType.GetSize() << ",i1 false)"
		if DebugMode
			f^ << ", !dbg !" << GDebugLineCallId
		f^ << "\n"

		if deferCall != null
			ctx.deferObjects.PushFront(deferCall)
	}
}

FuncLocalVarAccess := class extend BoxExeObj
{
	varIndex := int
	unrefInd := int

	this := !(int ind, Type^ varType) -> void
	{
		ObjType = varType
		varIndex = ind
	}
	IsMem := virtual !() -> bool { return true }
	PrintPointUse := virtual !(LLVMWriteContext^ ctx) -> void
	{
		ctx.writeStream^ << "%Var" <<varIndex
	}
	PrintPre := virtual !(LLVMWriteContext^ ctx) -> void
	{
		unrefInd = ctx.GetNewId()
		f := ctx.writeStream

		f^ << "%TUnref" << unrefInd << " = load "
		ObjType.PrintType(ctx)
		f^ << " , "
		ObjType.PrintType(ctx)
		f^ << "* "
		PrintPointUse(ctx)
		f^ << "\n"
	}
	PrintUse := virtual !(LLVMWriteContext^ ctx) -> void
	{
		ctx.writeStream^ << "%TUnref" << unrefInd
	}
}
FuncLocalCallIfTrue := class extend BoxExeObj
{
	GetVar := BoxExeObj^
	DownCall := BoxExeObj^
	TrueBranch := BoxLabel2
	FalseBranch := BoxLabel2
	storeFalse := BoxExeObj^

	this := !(BoxExeObj^ varPtr,BoxExeObj^ dwn) -> void
	{
		GetVar = varPtr
		DownCall = dwn
		TrueBranch."this"()
		FalseBranch."this"()

		objs := CheckExeDownList
		objs.Push(varPtr)
		objs.Push(GBoolFalse)
		storeFalse = CreateFuncCall(StringSpan("="),objs)
	}
	PrintDefer := virtual !(LLVMWriteContext^ ctx) -> void
	{
		TrueBranch.CreateId(ctx)
		FalseBranch.CreateId(ctx)

		GetVar.PrintPre(ctx)
		PrintBranch(ctx,GetVar,TrueBranch&,FalseBranch&)
		TrueBranch.PrintLabelCreate(ctx)
		DownCall.PrintDefaultUse(ctx)
		storeFalse.PrintDefaultUse(ctx)
		FalseBranch.PrintGo(ctx)
		FalseBranch.PrintLabelCreate(ctx)
	}
}
FuncLocalDebugInfoDeclare := class extend BoxExeObj
{
	getVar := BoxExeObj^
	baseVar := LocalVar^
	debId := int
	this := !(BoxExeObj^ varPtr,LocalVar^ lVar) -> void
	{
		getVar = varPtr
		baseVar = lVar
		debId = GetNewId()

		if baseVar.isReference
			baseVar.GetType().MakeDebugRef()
	}
	PrintDefaultUse := virtual !(LLVMWriteContext^ ctx) -> void
	{
		if not DebugMode
			return void

		getVar.PrintPointPre(ctx)

		f := ctx.writeStream

		f^ << "call void @llvm.dbg.declare(metadata "
		inType := baseVar.GetType()
		inType = NormalizeType(inType)
		inType.PrintType(ctx)
		if baseVar.isReference
			f^ << "*"
		f^ << "* " 
		getVar.PrintPointUse(ctx)
		f^ << " , metadata !" << debId << " , metadata !DIExpression()) , !dbg !" << GDebugLineCallId << "\n"

		ctx.funcDebugMetas.Push(this&)
	}
	PrintDebugPostFuncMeta := virtual !(LLVMWriteContext^ ctx) -> void
	{
		f := ctx.writeStream

		pType := baseVar.GetType()
		f^ << "!" << debId << " = !DILocalVariable(name: \"" << baseVar.itName << "\" , scope:!" << GDebugScopeId << " , file:!" << GDebugFileId
		f^ << ", line: " << 0 << ", type:!"
		if baseVar.isReference
		{
			f^ <<pType.MakeDebugRef().MetaId
		}else{
			f^ <<pType.MetaId
		}
		f^ << ")\n"
	}
}
FuncLocalDebugInfoValue := class extend BoxExeObj
{
	getVar := BoxExeObj^
	baseVar := LocalVar^
	debId := int
	this := !(BoxExeObj^ varPtr,LocalVar^ lVar) -> void
	{
		getVar = varPtr
		baseVar = lVar
		debId = GetNewId()

		if baseVar.isReference
			baseVar.GetType().MakeDebugRef()
	}
	PrintDefaultUse := virtual !(LLVMWriteContext^ ctx) -> void
	{
		if not DebugMode
			return void

		getVar.PrintPre(ctx)

		f := ctx.writeStream

		f^ << "call void @llvm.dbg.value(metadata "
		inType := baseVar.GetType()
		inType = NormalizeType(inType)
		inType.PrintType(ctx)
		if baseVar.isReference
			f^ << "*"
		f^ << " " 
		getVar.PrintUse(ctx)
		f^ << " , metadata !" << debId << " , metadata !DIExpression()) , !dbg !" << GDebugLineCallId << "\n"

		ctx.funcDebugMetas.Push(this&)
	}
	PrintDebugPostFuncMeta := virtual !(LLVMWriteContext^ ctx) -> void
	{
		f := ctx.writeStream

		pType := baseVar.GetType()
		f^ << "!" << debId << " = !DILocalVariable(name: \"" << baseVar.itName << "\" , scope:!" << GDebugScopeId << " , file:!" << GDebugFileId
		f^ << ", line: " << 0 << ", type:!"
		if baseVar.isReference
		{
			f^ <<pType.MakeDebugRef().MetaId
		}else{
			f^ <<pType.MetaId
		}
		f^ << ")\n"
	}
}
