BoxFunc := class extend BoxFuncContainer
{
	MyFuncType := TypeFunc^
	MyFuncParamNames := RawArray.{char^}
	FuncName := string
	OutputName := string
	IsSuffix := bool
	IsVirtual := bool
	IsMethod := bool
	IsRetComplex := bool
	IsRetRef := bool
	IsStatic := bool
	IsSelfReturn := bool
	IsPassAttrs := bool

	CountAttrs := bool

	VirtualId := int

	MethodType := Type^

	ItConsts := Queue.{Object^}
	ItAttrs := AVLMap.{string,Object^}
	ItVals := List.{ObjConstHolder^}

	vargsName := string
	funcUserParamsCount := int

	DefaultValues := RawArray.{FuncDefValue}

	vargTypeBarrier := Object^


	GetType := virtual !() -> Type^
	{
		return MyFuncType
	}
	IsAssembler := virtual !() -> bool
	{
		return false
	}
	GenerateCall := virtual !(Object^ pars) -> BaseFuncCall^
	{
		return null
	}
	GetItem := virtual !(string name) -> Object^
	{
		if ItVals[^].ItName == name
			return it.Down
		return null
	}
	
	IsSameConsts := !(FuncInputBox itBox) -> bool
	{
		if itBox.itConsts.Size() != ItConsts.Size() 
			return false

		if CountAttrs
		{
			if itBox.itAttrs.Size() < ItAttrs.Size() 
				return false
			for val,key : itBox.itAttrs
			{
				sRes :=  ItAttrs.TryFind(key)
				if sRes != null
				{
					if not CmpConstObjs(val,sRes^)
						return false
				}else{
					if val is ObjBool
					{
						asBool := val->{ObjBool^}
						if asBool.MyBool
							return false
					}else{
						return false
					}
				}
			}
		}

		for ct,i : itBox.itConsts , tc : ItConsts
		{
			if not CmpConstObjs(ct,tc) 
			{
				return false
			}
		}
		return true
	}

	ItConstsTT := List.{Object^}
	ParseConsts := !(Object^ cons) -> void
	{
		if cons != null
		{
			for iter : cons.Down
			{
				if iter.GetValue() == ","
					continue

				if iter.IsConst
				{
					ItConsts.Push(iter.Clone())
					ItConstsTT.Push(null)
					continue
				}
				typ := ParseType(iter)
				if typ != null
				{
					ItConsts.Push(new ObjType(typ))
					ItConstsTT.Push(null)
					continue
				}

				stdL := Queue.{string}()
				if ContainTType(iter,stdL)
				{
					ItConsts.Push(null->{Object^})
					ItConstsTT.Push(iter)
				}else{
					ErrorLog.Push("can not parse object in .{}\n")
				}
			}
		}
	}

	ParseParams := !(Object^ root, Object^ outObj,bool IsTempl) -> bool
	{
		return ParseParams(root,outObj,IsTempl,null)
	}
	ParseParams := !(Object^ root, Object^ outObj,bool IsTempl, TypeFunc^ parentFunc) -> bool
	{
		SyntaxCompress(root,LexHVInputVars)
		//SyntaxCompress(root,LexHVFileRoot)
		Pars := List.{Object^}
		Pars.allocator = gTemporaryPool&

		InputVars := @temp new List.{Tuple.{
			char^,  //name
			Type^, 
			bool, //IsRef
			Object^, //DefValue
			int // DefValue modifier
		}}
		TypsDefValues := Queue.{Object^}() ; $temp
		TypsDefValuesModifier := @temp new List.{int}
		IsVargsL := false
		ContainTT := false
		defVals := 0

		RetTyp := null->{Type^}
		if GetValue() == "!()" RetTyp =  ParseType(outObj)
		if IsSelfReturn
		{
			RetTyp = MethodType
			IsRetRef = true
		}

		Stuff := @temp new List.{Object^}

		if RetTyp != null
		{
			if RetTyp is TypeArr or RetTyp is TypeClass
			{
				if not IsRetRef this.IsRetComplex = true
			}
		}
		if FuncName == "new" IsStatic = true

		if MethodType != null and (not IsStatic)
		{
			InputVars.Emplace("this",MethodType,true,null,0)
		}

		Stuff.Push(root.Down[^])

		breakPars := (!()&->void subCall) ==> 
		{
			while not Stuff.IsEmpty()
			{
				if Stuff^[0].GetValue() == ","
				{
					Stuff.Pop()
					subCall()
					Pars.Clear()
				}else{
					Pars.Push(Stuff.Pop())
				}
			}
		}

		if Stuff.Size() != 0 Stuff.Push(@temp new ObjSymbol(","))

		indType := 0

		breakPars(() ==>{
			if Pars.Size() == 1
			{
				if Pars[0].GetValue() == "..."
				{
					IsVargsL = true
					return void
				}
				if Pars[0].GetValue() == "~ind"
				{
					itType := Type^()
					isRef := false
					if parentFunc != null
					{
						tId := InputVars.Size()
						if parentFunc.ParsCount > tId
						{
							itType = parentFunc.Pars[tId]
							isRef = parentFunc.ParsIsRef[tId]
						}
					}

					InputVars.Emplace((Pars[0]->{ObjIndent^}).MyStr,itType,isRef,null,0)
					return void
				}

				itr := Pars[0]
				if itr is ObjData and itr.Down? is ObjIndent and itr.Down.Right?.GetValue() == "..."
				{
					asIn := itr.Down->{ObjIndent^}
					vargsName = asIn.MyStr
					return void
				}
				
				EmitError("unknown error\n")
				
			}
			if Pars.Size() >= 2 and Pars[1].GetValue() == "..."
			{
				if Pars.Size() == 2 and Pars[0] is ObjIndent
				{
					vargsName = Pars[0]->{ObjIndent^}.MyStr
				}
				if Pars.Size() == 3
				{
					assert(false) //TODO implement
				}
				return void
			}

			if Pars.Size() == 2 or Pars.Size() == 5 //TODO too bad way
			{
				if Pars[0].Down?.Right.GetValue() == "..."
				{
					vargTypeBarrier = Pars[0].Down.Right
					if not Pars[1] is ObjIndent {
						EmitError("it should be indent")
					}
					vargsName = Pars[1]->{ObjIndent^}.MyStr
				}else{
					IsParRef := false
					MayType := Type^()
					if Pars[0].Down?.Right?.GetValue() == "&"
					{
						MayType = ParseType(Pars[0].Down)
						IsParRef = true
					}else{
						MayType = ParseType(Pars[0])
					}
					indType += 1
					MayName := ""

					if MayType == null and not ContainTType(Pars[0])
					{
						if ContainTType(Pars[0]) or ContainTT
						{
							ContainTT = true
						}else
						{
							if not IsTempl
							{
								EmitError("can not parse type at "sbt + indType + "\n")
							}
						}
					}

					defValue := Object^
					defValueMod := 0
					if Pars[1] is ObjIndent
					{
						MayName = (Pars[1]->{ObjIndent^}).MyStr

						if Pars.Size() == 5 and Pars[2].GetValue() == "="
						{
							assert(Pars[3].GetValue() == "static")
							fieldType := 0
							switch(Pars[3].GetValue())
							{
								case "static" fieldType = DefValueMod_Static
								case "field" fieldType = DefValueMod_Field
								case void assert(false)
							}
							defVals += 1
							IsParRef = true
						}
					}else{
						if Pars[1].Down?.Right?.GetValue() == "=" and Pars[1].Down is ObjIndent
						{
							MayName = (Pars[1].Down->{ObjIndent^}).MyStr
							defVals += 1
						}else{
							EmitError("only indentificators allowed, got "sbt + Pars[1].GetValue() + "\n")
						}
					}

					InputVars.Emplace(StrCopy(MayName),MayType,IsParRef,defValue,defValueMod)
				}	
			}
		})
		MyFuncType = null

		if defVals != 0
		{
			DefaultValues.Resize(defVals)
			for toSet : DefaultValues, vl : InputVars^
			{
				toSet.Value = vl.3
				toSet.ValueModifier = vl.4
			}
		}

		if InputVars.Size() != 0
		{
			MyFuncParamNames.Reserve(InputVars.Size())
			for it : InputVars^
				MyFuncParamNames.Create() = it.0
		}
		

		typsArr := RawArray.{Type^}
		typsIsRef := RawArray.{bool}

		_SetAllocator(typsArr,gTemporaryPool&)
		_SetAllocator(typsIsRef,gTemporaryPool&)

		typsArr.Resize(InputVars.Size())
		typsIsRef.Resize(InputVars.Size())

		for inp : InputVars^, setType : typsArr, setIsRef : typsIsRef
		{
			setType = inp.1
			setIsRef = inp.2
		}

		MyFuncType = GetFuncType(typsArr.Data(),typsIsRef.Data(),InputVars.Size(),RetTyp,IsRetRef,IsVargsL,false)
		funcUserParamsCount = MyFuncType.ParsCount

		if MyFuncParamNames.Size() != 0 and MyFuncType.ParsCount != 0
		{
			if MyFuncParamNames[0] == "this" IsMethod = true
		}

		return true
	}
	SetReturnType := !(Type^ toSet) -> void
	{
		this.IsRetComplex = false
		if toSet is TypeArr  or toSet is TypeClass
		{
			if not this.IsRetRef this.IsRetComplex = true
		}
		if MyFuncType.RetType != toSet
		{
			MyFuncType = ExchangeFuncType(MyFuncType,toSet)
		}			
	}
	ParseBlock := virtual !() -> void
	{
	}

	GetValue := virtual !() -> string
	{
		return "!()"
	}
	ApplyDeferUse := virtual !(int depth) -> void
	{
	}
}

PrintFuncBodySkobs := !(TIOStream f,TypeFunc^ fType,RawArray.{char^} names,string fName,string Extra,int itId) -> void
{
	f << "define " //TODO "dso_local "

	IsRetComplex := false

	if not fType.RetRef
	{
		IsRetComplex = IsComplexType(fType.RetType)
	}

	if IsRetComplex f << "void"
	else 
	{
		fType.RetType.PrintType(f)
		if fType.RetRef f << "*"
	}

	f << " @" << fName

	f << "("
	
	if Extra != null
	{
		f <<	Extra
		if IsRetComplex or fType.ParsCount != 0 
			f << " , "
	}
	if IsRetComplex 
	{
		f << fType.RetType.GetName() << "* %" << ReturnName
		if fType.ParsCount != 0 f << " , "
	}
	for i : fType.ParsCount
	{
		if i > 0 f << " , "
		if i < names.Size()
		{
			if fType.ParsIsRef[i]
				fType.Pars[i].GetPoint().PrintType(f)
			else	fType.Pars[i].PrintType(f)
			f << " %" <<names[i]
		}else{
			if fType.ParsIsRef[i]
				fType.Pars[i].GetPoint().PrintType(f)
			else	fType.Pars[i].PrintType(f)
			f << " %Extra" << itId << "Param" << i
		}
	}
	if fType.IsVArgs
	{
		if fType.ParsCount > 0 f << " , "
		f << "..."
	}
	f << ")"
}
