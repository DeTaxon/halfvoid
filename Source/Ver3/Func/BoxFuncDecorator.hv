AppendClass BoxFunc
{
	wrappedSearched := bool
	wrappedFunc := BoxFunc^
	GetWrappedFunc := virtual !() -> BoxFunc^
	{
		if wrappedSearched
			return wrappedFunc
		wrappedSearched = true
		wrappedFunc = this&
		ParseBlock()


		
		if Up? is in ObjParam
		{
			iter := Up.Left
			while iter != null
			{
				if not iter.IsCmdMod()
					break
				if iter is ObjTemplateType
				{
					if wrappedFunc == this& and this& is BoxFuncBody and this&->{BoxFuncBody^}.deferTail != null
					{
						EmitError("Can not decorate function with defer_tail\n")
					}

					dcName := iter->{ObjTemplateType^}.MyStr
					wrappedFunc = wrappedFunc.SearchGetDecorator(dcName)

					if wrappedFunc == null
						EmitError("Decorator <"sbt + dcName + "> not found")
					wrappedFunc.ParseBlock()
				}
				iter = iter.Left
			}
		}

		return wrappedFunc
	}
	SearchGetDecorator := !(char^ name) -> BoxFunc^
	{
		assert(MyFuncType != null)

		fncName := ("@"sbt + name + " func")->{char^}
		
		//itBox := @temp new FuncInputBox()
		//itBox.itPars.Emplace(MyFuncType.GetPoint(),false)
		//for c : MyFuncType.ParsCount
		//{
		//	itBox.itPars.Emplace(
		//		MyFuncType.Pars[c],
		//		MyFuncType.ParsIsRef[c]
		//		)
		//}

		//dFunc := FindFunc(fncName,this&,itBox^,false)

		//if dFunc != null
		//{
		//	decoratorFunc = dFunc
		//	decoratorHaveFunc = true
		//	return void
		//}

		itBox2 := @temp new FuncInputBox()
		itBox2.itConsts.Push(@temp new ObjFuncPointer(this&))
		for c : MyFuncType.ParsCount
		{
			itBox2.itPars.Emplace(
				MyFuncType.Pars[c],
				MyFuncType.ParsIsRef[c]
				)
		}
		dFunc := FindFunc(fncName,this&,itBox2^,false)

		if dFunc != null
		{
			return dFunc
		}
		return null

	}
}
}
