BoxWhile := class extend Object
{
	MyId := int
	this := !(Object^ DaRet) -> void
	{
		Down = DaRet.Down
		MyId = GetNewId()
		labelEnd = new BoxLabelAnon()
	}
	DoTheWork := virtual !(int pri) -> void
	{
		if visitedWork[pri] return void
		else visitedWork << pri

		if pri == State_Start
		{
			WorkBag.Push(this&,State_Syntax)
			Down.SetUp(this&)
			PopOutNode(Down)

			MakeItBlock(Down.Right)
			while TryParseMacro(Down,this&) != null {}
		}
		if pri == State_Syntax
		{
			WorkBag.Push(Down[^],State_Start)
			WorkBag.Push(this&,State_GetUse)
		}
		if pri == State_GetUse
		{
			if Down.GetType() != GTypeBool
			{
				if TypeCmpForWhileIf(Down.GetType(),GTypeBool) != 255
				{
					if BoxExc(Down,GTypeBool,false) == null
						EmitError("compiler error: can not convert\n")
				}else{
					EmitError("can not use type as while statement\n")
				}
			}
		}
	}
	
	labelEnd := BoxLabel^
	labelContinue := BoxLabel^
	labelBreak := BoxLabel^
	PrintInBlock := virtual !(TIOStream f) -> void
	{
		if Down.Right.Right == null
		{
			f << "br label %Check" << MyId << "\n"
			f << "Check" << MyId << ":\n"
			Down.PrintPre(f)
			f << "br "
			Down.PrintUse(f)
			f << ", label %OnTrue" << MyId << " , label %" << labelEnd.GetLabel() << "\n"
			f << "OnTrue" << MyId << ":\n"
			Down.Right.PrintDeferInBlock(f,deferId,deferLabel&)
			Down.Right.PrintInBlock(f)
			f << "\nbr label %Check" << MyId << "\n"
			
			if labelContinue != null
			{
				labelContinue.PrintLabel(f)
				Down.Right->{BoxBlock^}.PrintDeferInBlockUse(f)
				f << "br label %Check" << MyId << "\n"
			}

			if labelBreak != null
			{
				labelBreak.PrintLabel(f)
				Down.Right->{BoxBlock^}.PrintDeferInBlockUse(f)
				f << "br label %" << labelEnd.GetLabel() << "\n"
			}

			labelEnd.PrintLabel(f)
		}

	}

	GetDeferUsageVerticalSize := virtual !() -> int
	{
		return Down.Right.GetDeferUsageVerticalSize()	
	}
	PrintDeferUse := virtual !(TIOStream f, BoxFuncContainer^ bd,BoxBlock^ blk, int depth,int^ labelIter) -> void
	{
		Down.Right.PrintDeferUse(f,bd,blk,depth,labelIter)
	}

	deferId := int
	deferLabel := int
	PrintDeferInBlock := virtual !(TIOStream f, int itId,int^ labelSetIter) -> void
	{
		//Down.Right.PrintDeferInBlock(f,itId,labelSetIter)
		deferId = itId
		deferLabel = labelSetIter^
		labelSetIter^ += Down.Right.GetDeferUsageVerticalSize()
	}

	GetOutPath := virtual !(Object^ itm, int typ, int size) -> BoxLabel^
	{
		if typ == PATH_RETURN or typ == PATH_YIELD
		{
			return Up.GetOutPath(this&,typ,size) //poke
		}
		if typ == PATH_CONTINUE
		{
			if size == 0{
				if labelContinue == null
					labelContinue = new BoxLabelAnon()
				return labelContinue
			}
			return Up.GetOutPath(itm,typ,size - 1)
		}
		if typ == PATH_BREAK
		{
			if size == 0{
				if labelBreak == null
					labelBreak = new BoxLabelAnon()
				return labelBreak
			}
			return Up.GetOutPath(itm,typ,size - 1)
		}
		return null
	}

	GetBadLabel := virtual !(Object^ prebNode) -> BoxLabel^
	{
		return labelEnd
	}
	GetValue := virtual !() -> string
	{
		return "~while()"
	}
}
