BoxCodeSpace := class
{
	Files := List.{BoxFile^}

	Templates := AVLMap.{StringSpan,List.{BoxFuncTemplate^}}
	Functions := AVLMap.{StringSpan,List.{BoxFunc^}}
	Globals := AVLMap.{StringSpan,List.{BoxUnit^}}

	ExchangeTableFuncs :=  HybridQueue.{BoxUnit^,10}
	ExchangeTableTemplates := HybridQueue.{BoxUnit^,10}

	Modules := List.{ModuleInterface^}

	AddTemplate := !(StringSpan name, BoxFuncTemplate^ newTempl) -> void
	{
		Templates[name].Push(newTempl)
		if name == "->{}"
			ExchangeTableTemplates.Push(newTempl)
	}
	AddFunction := !(StringSpan name, BoxFunc^ newFnc) -> void
	{
		Functions[name].Push(newFnc)
		if name == "->{}"
			ExchangeTableFuncs.Push(newFnc)
	}
}


BoxFile := class extend BoxUnit
{
	fileId := int
	file := vRepoFile^
	fileMap := FileView^
	fileSize := int
	fileName := StringSpan

	loaded := THatch

	AllClasses := List.{BoxClass^}

	fileTokens := Token^
	tokensChanged := bool

	ParsedTokens := AVLSet.{Token^}

	this := !(vRepoFile^ inFile) -> void
	{
		fileId = GetNewId()
		file = inFile
		fileMap = file.GetMap()
		fileSize = file.Size()
	}
	GetName := !() -> StringSpan
	{
		result = fileName
	}

	LoadFiles := !() -> void
	{
		tokens := Token^

		blb := TryGetCacheOfFile(file)
		if blb != null
		{
			if blb.Size() == 0
				return void
			s := StreamReadBlob(blb.GetPointer(),blb.Size())
			fileTokens = LoadCachedTokens(s&,this&)
		}
		if fileTokens == null
		{
			tokens = GetObjectsFromMemory(this&,fileMap.Get()->{char^},fileSize)

			if tokens == null
				return void

			tokensChanged = true

			fileTokens = new Token

			fileTokens.Down = tokens
			itr := tokens
			while itr != null
			{
				itr.Up = fileTokens
				itr = itr.Right
			}

			SyntaxCompress(fileTokens,LexHVFileRoot)
		}
	}
	ParseClasses := !() -> void
	{
		if fileTokens == null
			return void

		LoadSpace()

		iter := fileTokens.Down
		while iter != null
		{
			if iter.Down?.Right?.GetValue() == ":="
			{}else{
				iter = iter.Right
				continue
			}
			stVal := iter.Down.Right


			cls := TryParseClass(stVal.Right)

			if cls == null
			{
				iter = iter.Right
				continue
			}
			

			name := StringSpan
			if stVal.Left is TokenString
			{
				name = stVal.Left->{TokenString^}.Value
			}else if stVal.Left is TokenIndent
			{
				name = stVal.Left->{TokenIndent^}.Value
			}else{
				assert(false)
			}

			if cls is in BoxClass
			{
				cls2 := cls->{BoxClass^}
				cls2.SetName(name)
				clsVar := new TypeVar(name,cls2.ItType)
				TypesDatabase[name] = clsVar
			} else if cls is in BoxClassTemplate
			{
				cls3 := cls->{BoxClassTemplate^}
				cls3.SetName(name)
				templateVar := new TemplateTypeVar(name,cls3)
				TypesDatabase[name] = templateVar
			}else{
				assert(false)
			}

			ParsedTokens.Insert(iter)

			iter = iter.Right
		}
	}
	ParseAppendClasses := !() -> void
	{
		if fileTokens == null
			return void

		LoadSpace()
		iter := fileTokens.Down
		while iter != null
		{
			if iter.Down?.GetValue() == "AppendClass"
			{} else{
				iter = iter.Right
				continue
			}
			CheckAppendHolder(iter)
			ParsedTokens.Insert(iter)
			iter = iter.Right
		}
	}
	ParseTypedefs := !() -> void
	{
		if fileTokens == null
			return void

		LoadSpace()
		iter := fileTokens.Down
		while iter != null
		{
			if iter.Down?.Right?.Right?.GetValue() == "type"
			{
				res := TryParseTypedefTemplate(iter)

				if res != null
				{
					assert(res is TypedefTemplateVar)
					asTemplate := res->{TypedefTemplateVar^}
					TypesDatabase[asTemplate.Name] = asTemplate
					ParsedTokens.Insert(iter)
				}
			}
			iter = iter.Right
		}
	}
	ParseFunctions := !() -> void
	{
		if fileTokens == null
			return void

		LoadSpace()
		iter := fileTokens.Down
		while iter != null
		{
			if iter.Down?.Right?.GetValue() == ":="
			{}else{
				iter = iter.Right
				continue
			}
			stVal := iter.Down.Right

			if stVal.Right == null
			{
				iter = iter.Right
				continue
			}

			c := PFunctionParser(stVal.Right)
			if not c.IsFound()
			{
				iter = iter.Right
				continue
			}

			isSuffix := false
			name := StringSpan
			if stVal.Left is TokenString
			{
				name = stVal.Left->{TokenString^}.Value
				isSuffix = true
			}else if stVal.Left is TokenIndent
			{
				name = stVal.Left->{TokenIndent^}.Value
			}else{
				assert(false)
			}

			fnc := c.CreateObject()
			assert(fnc != null)
			assert(fnc is in BoxFuncTemplate)
			res := new TemplateFuncVar(name,isSuffix,fnc->{BoxFuncTemplate^})

			ParsedTokens.Insert(iter)
			res.MemObj.SetName(res.Name)
			CurrentCodeSpace.AddTemplate(res.Name,fnc->{BoxFuncTemplate^})

			iter = iter.Right
		}
	}

	LoadSpace := !() -> void
	{
		CurrentFile = this&
		foundSpace := false
		for spc : CodeSpaces
		{
			for fil : spc.Files
			{
				if fil == this&
				{
					CurrentCodeSpace = spc&
					foundSpace = true
					break
				}
			}
			if foundSpace
				break
		}
		assert(foundSpace)

	}
	Parse := !() -> void
	{
		fileName = GetConstString(file.GetName().Str())

		LoadSpace()

		defer loaded.Emit()

		if fileTokens == null
			return void

		CurrentScope = this&
		iter := fileTokens.Down

		while iter != null
		{
			if ParsedTokens.Contain(iter)
			{
				iter = iter.Right
				continue
			}

			vr := TryParseVarInFile(iter)


			if vr == null
			{
				if iter.Down?.Right?.GetValue() == ":=" and iter.Down is TokenIndent
				{
					vr = new GlobalVar2(iter.Down->{TokenIndent^}.Value,iter.Down.Right.Right)
					GlobalVars2.Push(vr->{GlobalVar2^})
				}
			}

			if vr != null
			{
				if vr is TypeVar or vr is TemplateTypeVar
				{
					if vr is TypeVar
					{
						TypesDatabase[vr->{TypeVar^}.Name] = vr
					}else{
						//CurrentCodeSpace.Globals[vr->{TypeVar^}.Name].Push(vr)
						TypesDatabase[vr->{TemplateTypeVar^}.Name] = vr
					}
				}else if vr is in GlobalVar2
				{
					glb := vr->{GlobalVar2^}
					CurrentCodeSpace.Globals[glb.itName].Push(vr)
				}else if vr is in TypedefTemplateVar
				{
					TypesDatabase[vr->{TypedefTemplateVar^}.Name] = vr
				}else if vr is in NamedVar
				{
					v := vr->{NamedVar^}
					CurrentCodeSpace.Globals[v.Name].Push(vr)
				}else {
				}

				vr.Work()
			}else{
				cmdRes := TryGetCommand(iter)
				if cmdRes == null
				{
					printf("some error %s\n",iter.GetValue())
					iter.Print(0)
					iter.EmitError("Unknown object")
				}
			}
			iter = iter.Right
		}
	}
	PrintCode := virtual !(LLVMWriteContext^ ctx) -> void
	{
		if DebugMode //later
		{
			f := ctx.writeStream
			pth := file.GetPath()
			if fsIsExist(pth.Str()) //TODO to something better
			{
				pth2 := uvRealpath(pth.Str())
				if pth2->{void^} == null
					pth2 = pth
				f^ << "!" << fileId  << " = !DIFile(filename: \"" 
				f^ << pth2.Str() << "\", directory: \""
				f^ <<  "/" <<"\")\n"
			}else{
				f^ << "!" << fileId  << " = !DIFile(filename: \"" 
				f^ << file.GetName() << "\", directory: \""
				f^ <<  "/" <<"\")\n"
			}
		}
	}
}
TryParseVarInFile := !(Token^ obj) -> BoxUnit^
{
	if obj == null or obj.Down == null
		return null

	iter := obj.Down

	if iter.Right == null
		return null
	if iter.Right?.GetValue() != ":="
		return null

	name := StringSpan
	if iter is TokenIndent
	{
		name = iter->{TokenIndent^}.Value
	}else if iter is TokenString
	{
		name = iter->{TokenString^}.Value
	}

	varToken := iter.Right.Right

	if varToken == null
		return null

	if varToken.Down?.GetValue() == "enum"
	{
		en := TryParseEnum(varToken)
		assert(en != null)
		return new TypeVar(name,en.ItType)
	}
	
	if varToken.GetValue() == "thread_local"
	{
		return null
	}
	
	if varToken.GetValue() == "task_local"
	{
		return new TaskLocalVarDelayed(name,varToken.Right)
	}

	return null
}
