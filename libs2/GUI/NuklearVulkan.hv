NuklearVulkanContext := class //extend TGCObject
{
	itContext := void^
	vInstance := VulkanDefaultInstance^

	atlasData := nk_font_atlas 
	atlasTexture := TVkTexture^

	textList := List.{Tuple.{int,float,float,float,float}}
	renderMesh := TVkMesh^


	MakeDraw := !() -> void
	{
		DrawCode(itContext)
	}
	DrawCode := virtual !(void^ nk) -> void
	{
	}


	InputCheck := !(GLFWWindow^ wn) -> void
	{
		nk_input_begin(itContext)
		nk_input_motion(itContext,wn.MouseX,wn.MouseY)
		nk_input_button(itContext,NK_BUTTON_LEFT,wn.MouseX,wn.MouseY,wn.M1Pressed)
		nk_input_button(itContext,NK_BUTTON_RIGHT,wn.MouseX,wn.MouseY,wn.M2Pressed)
		nk_input_end(itContext)
	}

	Clear := !() -> void
	{
		nk_clear(itContext)
	}

	Init := !(VulkanDefaultInstance^ vi) -> void
	{
		vInstance = vi
		Nuklear_init() //TODO once

		itContext = calloc(nk_context_size(),1)

		ax := 0
		ay := 0
		nk_font_atlas_init_default(atlasData&)
		nk_font_atlas_begin(atlasData&)

		fnt2 := nk_font_atlas_add_default(atlasData&,24,null)

		//ttf := FSGetFile("./Pacifico.ttf")
		//ttfMap := ttf.GetMap()
		//fnt := nk_font_atlas_add_from_memory(atls_data,ttfMap.Get(),ttfMap.Size(),24,null)

		imgABC := nk_font_atlas_bake(atlasData&,ax&,ay&,NK_FONT_ATLAS_RGBA32)

		atlasTexture = vInstance.CreateTexture()
		atlasTexture.CreateObject(ax,ay)

		tempMem := vInstance.itStageMemory
		tempMem.TransferData(TArraySpan.{u8}(imgABC->{u8^},ax*ay*4))
		vStageCpyToImage(vInstance,atlasTexture.itImg,ax,ay) //TODO refactor

		nk_font_atlas_end(atlasData&,atlasTexture,null)

		nk_init_default(itContext,fnt2->{void^^}[1]&)

		nk_style_load_all_cursors(itContext,atlasData.cursors[0]&)
	}
	CreateRenderPass := !(int imageFormat) -> TRenderPass^
	{
		return vInstance.CreateRenderPass(![
			TRenderPassFrame(imageFormat,	VK_IMAGE_LAYOUT_UNDEFINED,VK_IMAGE_LAYOUT_PRESENT_SRC_KHR),
		],false)
	}

	RenderStep := !() -> void
	{
		layT := nk_draw_vertex_layout_element[4]
		layT[0].attribute = NK_VERTEX_POSITION
		layT[0].format = NK_FORMAT_FLOAT
		layT[0].offset = 0
		layT[1].attribute = NK_VERTEX_TEXCOORD
		layT[1].format = NK_FORMAT_FLOAT
		layT[1].offset = 4*2
		layT[2].attribute = NK_VERTEX_COLOR
		layT[2].format = NK_FORMAT_R8G8B8A8
		layT[2].offset = 4*4
		layT[3].attribute = NK_VERTEX_ATTRIBUTE_COUNT
		layT[3].format = NK_FORMAT_COUNT
		layT[3].offset = 0

		cfg := nk_convert_config
		cfg.vertex_size = 4*4 + 4
		cfg.vertex_layout = layT[0]&
		cfg.vertex_alignment = 4
		cfg.circle_segment_count = 22
		cfg.curve_segment_count = 22
		cfg.arc_segment_count = 22
		cfg.global_alpha = 1.0f
		cfg.shape_AA = 1
		cfg.line_AA = 1

		vBuf := u8[1024]
		iBuf := u8[1024]
		cmds := u8[1024]

		nk_buffer_init_default(cmds[0]&)

		vRealVertBuf := Vector.{u8}(16*1024)
		vRealIndBuf := Vector.{u8}(16*1024)

		nk_buffer_init_fixed(vBuf[0]&,vRealVertBuf.GetPointer(),16*1024) //TODO cleanup
		nk_buffer_init_fixed(iBuf[0]&,vRealIndBuf.GetPointer(),2048)
		res := nk_convert(itContext,cmds[0]&,vBuf[0]&,iBuf[0]&,cfg&)

		assert(res == 0)

		textList.Destroy()
		cmd := nk__draw_begin(itContext,cmds[0]&)->{nk_draw_command^}
		while cmd != null
		{
			//printf("step %p %i\n",cmd.texture,cmd.elem_count)
			textList.Emplace(cmd.elem_count,cmd.clip_rect.x,cmd.clip_rect.y,cmd.clip_rect.w,cmd.clip_rect.h)
			cmd = nk__draw_next(cmd,cmds[0]&,itContext)->{nk_draw_command^}
		}

		if renderMesh == null
		{
			renderMesh = vInstance.CreateMesh(vRealVertBuf&,vRealIndBuf&,VKType(VType_UInt16,1))
		}else{
			renderMesh.TransferData(vRealVertBuf&,vRealIndBuf&)
		}

		nk_buffer_free(vBuf[0]&)
		nk_buffer_free(iBuf[0]&)
		nk_buffer_free(cmds[0]&)
	}

	drawLayout := TShaderInput^
	textShader := vShader^ 
	
	nuklearPool := TDescriptorPool^ 
	nuklearDescp := VkDescriptorSet
	CreateShader := !(TRenderPass^ pass) -> void
	{
		drawLayout = pass.CreateLayout(![
			VKType(VType_Float,2),
			VKType(VType_Float,2),
			VKType(VType_UInt8,4)
		],![
			new TImageSet(1)
		],![
			new TVertexPushConstant(2*4)
		],
		1
		)

		textShader = drawLayout.CreateShader(#FileLocal("TextVertCompiled.vert"),#FileLocal("TextFragCompiled.frag"))

		nuklearPool = drawLayout.CreateDescriptorPool(0,100) //TODO unconst
		nuklearDescp = nuklearPool.CreateDescriptor()
		
		vSetTexture(vInstance,nuklearDescp,atlasTexture,vInstance.SamplerNearest)
	}

	Draw := !(VkCommandBuffer cmdB,int w, int h) -> void
	{
		offsets := VkDeviceSize

		textShader.ApplyShaderToQueue(vInstance,cmdB,w->{float},h->{float})

		scales := float[2]
		scales[0] = 1.0 / w
		scales[1] = 1.0 / h
		vInstance.Funcs.vkCmdPushConstants(cmdB,drawLayout.Get(),VK_SHADER_STAGE_VERTEX_BIT,0,4*2,scales&)

		sts := VkDescriptorSet[1]
		sts[0] = nuklearDescp
		vInstance.Funcs.vkCmdBindDescriptorSets(cmdB,VK_PIPELINE_BIND_POINT_GRAPHICS,drawLayout.Get(),0,1,sts[0]&,0,null)

		renderMesh.Bind(cmdB)

		index_offset := 0
		for it : textList
		{
			//TODO use max min
			nX := it.1
			if nX < 0 
				nX = 0
			nY := it.2
			if nY < 0 
				nY = 0

			nW := it.3
			if nW + nX >= w
				nW = w - nX

			if nW <= 0
				continue
			nH := it.4
			if nH + nY >= h
				nH = h - nY
			if nH <= 0
				continue

			sc := VkRect2D
			sc.offset.x = nX
			sc.offset.y = nY
			sc.extent.width = nW
			sc.extent.height = nH

			vInstance.Funcs.vkCmdSetScissor(cmdB,0,1,sc&)
			vInstance.Funcs.vkCmdDrawIndexed(cmdB,it.0,1,index_offset,0,0)
			index_offset += it.0
		}
	}
	
	Destroy := virtual !() -> void
	{
	}
}
