SimpleWindow := class extend VulkanDefaultInstance
{

	itWin := GLFWGoAround^
	nuklearContext := NuklearGoAroundContext^

	mainRenderPass := TRenderPass^
	drawLayout := TShaderInput^
	drawShader := vShader^

	this := !(int w, int h,char^ title) -> void
	{

		PreferSimpleGPU()
		
		itWin = new GLFWGoAround
		itWin.backContext = this&
		itWin.Init(w,h,title)
		Init()

		initCreateStageMemory()

		nuklearContext = new NuklearGoAroundContext
		nuklearContext.Init(this&)

		CreateSurface(itWin.windowHandle)

		mainRenderPass = nuklearContext.CreateRenderPass(SwapImageFormat)

		CreateSwapchain(mainRenderPass,w,h)

		nuklearContext.CreateShader(mainRenderPass)

		InitWindow(nuklearContext)

		drawLayout = mainRenderPass.CreateLayout(![
			VKType(VType_Float,2),
			VKType(VType_Float,2),
			VKType(VType_UInt8,4)
		],![
			new TImageSet(1)
		],![
			new TVertexPushConstant(4*4)
		],
		1
		)
		drawShader = drawLayout.CreateShader(#File("TextVert2Compiled.vert"),#File("TextFrag2Compiled.frag"))


		nuklearPool = drawLayout.CreateDescriptorPool(0,100) //TODO unconst
		nuklearDescp = nuklearPool.CreateDescriptor()
		vSetTexture(this&,nuklearDescp,nuklearContext.atlasTexture,SamplerNearest)
	}


	nuklearPool := TDescriptorPool^ 
	nuklearDescp := VkDescriptorSet

	fpsLimited := bool
	fpsPeriod := float
	SetFPSLimit := !(int fpsCount) -> void
	{
		assert(fpsCount >= 0)
		if fpsCount == 0
		{
			fpsLimited = false
		}else{
			fpsLimited = true
			fpsPeriod = 1 / fpsCount
		}
	}

	Run := !() -> void
	{
		step1Cmd := TVkCommandBuffer(this&,itDrawCommandPool)

		lastTime := GetSteadyTime() - 1 //sec

		while not itWin.ShouldClose()
		{
			surfaceIndex := u32
			drawRes := true
			DrawGetImage(surfaceIndex&,drawRes&)

			if drawRes
			{

				if fpsLimited
				{
					itTime := GetSteadyTime()
					diffTime := itTime - lastTime
					if diffTime < fpsPeriod
					{
						TSleep(fpsPeriod - diffTime)
					}
					lastTime = GetSteadyTime()
				}

				step1Cmd.Reset()
				step1Cmd.Start()
				
				StartTextDraw(step1Cmd.Get(),GetSurfaceFramebuffer(surfaceIndex))

				nuklearContext.InputCheck(itWin)
				nuklearContext.MakeDraw()
				nuklearContext.RenderStep()
				nuklearContext.Clear()

				nuklearContext.Draw(step1Cmd.Get(),GetSurfaceWidth(),GetSurfaceHeight())

				w := GetSurfaceWidth()
				h := GetSurfaceHeight()
				
				drawShader.ApplyShaderToQueue(this&,step1Cmd.Get(),w->{float},h->{float})
				sts := VkDescriptorSet[1]
				sts[0] = nuklearDescp
				Funcs.vkCmdBindDescriptorSets(step1Cmd.Get(),VK_PIPELINE_BIND_POINT_GRAPHICS,drawLayout.Get(),0,1,sts[0]&,0,null)
				DrawVulkan(step1Cmd.Get(),GetSurfaceWidth(),GetSurfaceHeight())

				StopTextDraw(step1Cmd.Get())

				step1Cmd.Stop()

				step1Cmd.Submit(DrawQueue,null)

				DrawPresentImage(surfaceIndex)
				
			}else{
				CreateSwapchain(mainRenderPass,itWin.Width,itWin.Height)
			}

			//hm := u64 //TODO
			//hm = not_b hm
			//Funcs.vkWaitForFences(LogicalDevice,1,itGlobFence&,0,hm)

			itWin.PollEvents()
			itWin.SwapBuffers()
		}
	}

	StartTextDraw := !(VkCommandBuffer cmd,VkFramebuffer frm ) -> void
	{
		imgBarCPre := VkImageMemoryBarrier[2]
	
		beginInfo := VkRenderPassBeginInfo()
	
		clrValues := float[13]
	
		clrValues[0] = 0.0
		clrValues[1] = 0.5
		clrValues[2] = 1.0
		clrValues[4] = 1.0f
		clrValues[5] = 0.0f
		clrValues[6] = 0.0f
		clrValues[7] = 1.0f
	
		clrValues[8] = 0.0f
		clrValues[9] = 1.0f
		clrValues[10] = 0.0f
		clrValues[11] = 0.0f
	
		beginInfo.renderPass = mainRenderPass.Get()
		beginInfo.framebuffer = frm
		beginInfo.renderArea.extent.width = GetSurfaceWidth() //surfAb.currentExtent.width
		beginInfo.renderArea.extent.height = GetSurfaceHeight() //surfAb.currentExtent.height
		beginInfo.clearValueCount = 1
		beginInfo.pClearValues&->{void^^}^ = clrValues[0]&->{void^}
		
		Funcs.vkCmdBeginRenderPass(cmd,beginInfo&,VK_SUBPASS_CONTENTS_INLINE) //TODO remove vk.Funcs
	}
	StopTextDraw := !(VkCommandBuffer cmd) -> bool
	{
		Funcs.vkCmdEndRenderPass(cmd) //TODO remove vk.Funcs
	}

	InitWindow := virtual !(void^ nk) -> void
	{
	}
	DrawCode := virtual !(void^ nk,int w, int h) -> void
	{
	}
	DrawVulkan := virtual !(VkCommandBuffer cmd,int w, int h) -> void
	{

	}	
	
	MouseMoved := virtual !(double x, double y) -> void
	{
	}

	KeyChanged := virtual !(int key, int scancode, bool pressed) -> void
	{
	}
	MousePressed := virtual !(int buttonNum, bool pressed, int mods) -> void //if pressed is false => released
	{
	}
}

NuklearGoAroundContext := class extend NuklearVulkanContext
{
	DrawCode := virtual !(void^ nk) -> void
	{
		wn := vInstance->{SimpleWindow^}
		wn.DrawCode(nk,wn.GetSurfaceWidth(),wn.GetSurfaceHeight())
	}
}

GLFWGoAround := class extend GLFWWindow
{
	backContext := SimpleWindow^

	MouseMoved := virtual !(double x, double y) -> void
	{
		backContext.MouseMoved(x,y)
	}

	KeyChanged := virtual !(int key, int scancode, bool pressed) -> void
	{
		backContext.KeyChanged(key,scancode,pressed)
	}
	MousePressed := virtual !(int buttonNum, bool pressed, int mods) -> void //if pressed is false => released
	{
		backContext.MousePressed(buttonNum,pressed,mods)
	}
}