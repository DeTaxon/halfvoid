AVLSet.{@DATA} := type ContainerCommonSet.{AVLTree,DATA}
//RBSet.{@DATA} := type ContainerCommonSet.{RBTree,DATA}
ContainerCommonSet := class .{@TreeType,@DATA} extend TGCObject
{
	itTree := TreeType.{DATA}
	itSize := int

	this := !() -> void
	{
	}

	Insert := !(DATA dat) -> void
	{
		resl := CommonTreeNode.{DATA}^
		if itTree.FindOrCreate(dat,resl&)
		{
			resl.data = dat
			itSize += 1
		}	
	}
	Remove := !(DATA dat) -> void
	{
		resl := itTree.FindNode(dat)
		if resl != null {
			if DATA->TypeGroup == "Pointer"
			{
				resl.data = null
			}
			itTree.RemoveNode(resl)
			itSize -= 1
		}
	}
	Contain := !(DATA dat) -> bool
	{
		resl := itTree.FindNode(dat)
		return resl != null
	}
	Destroy := virtual !() -> void
	{
		itTree.Destroy()
		itSize = 0
	}
	//Contain := !(!(DATA)&->int cmpFunc) -> bool
	//{
	//	return itTree.FindNode(cmpFunc) != null
	//}
	//"==" := !(ContainerCommonSet.{@AnType,DATA} toCmp) -> bool
	//{
	//	if Size() != toCmp.Size()
	//		return false
	//	for it : this
	//		if not toCmp.Contain(it)
	//			return false
	//	return true
	//}
	"for" := !() -> !()&->DATA&
	{
		x := () ==> DATA& {
			itr := itTree.Start
			stk := List.{CommonTreeNode.{DATA}^}
			while itr != null or stk.Size() != 0
			{
				if itr == null
				{
					itr = stk.Pop()
					yield itr.data
					itr = itr.Right
				}else{
					stk.PushFront(itr)
					itr = itr.Left
				}
			}
		}
		return x.Capture()
	}
	//Reverse := fake
	//{
	//	"~For" := !() -> !()& -> DATA&
	//	{
	//		return _createIterator(true)
	//	}
	//}
	Size := !() -> int { return itSize }
	//"in" := !(DATA val) -> bool
	//{
	//	return Contain(val)
	//}

	ToArray := !() -> TVector.{DATA}^
	{
		result = new TVector.{DATA}(Size())
		i := 0
		for it : this
		{
			result^[i] = it
			i += 1
		}
	}
}
