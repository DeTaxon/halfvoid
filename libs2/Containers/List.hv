ListNode := class .{@T}
{
	data := T
	next := ListNode.{T}^
	prev := ListNode.{T}^
}

List := class.{@T} extend TGCObject
{
	start := ListNode.{T}^
	end := ListNode.{T}^

	itSize := int

	Push := !(T itm) -> void
	{
		newNode := createNode()
		if itSize == 0
		{
			start = newNode
			end = newNode
		}else{
			end.next = newNode
			newNode.prev = end
			end = newNode
		}
		itSize += 1
		newNode.data = itm
	}
	PushFront := !(T itm) -> void
	{
		newNode := createNode()
		if itSize == 0
		{
			start = newNode
			end = newNode
		}else{
			start.prev = newNode
			newNode.next = start
			start = newNode
		}
		itSize += 1
		newNode.data = itm
	}
	Pop := !() -> T
	{
		assert(itSize >= 1)
		result = start.data
		if itSize == 1
		{
			destroyNode(start)
			start = null
			end = null
		}else{
			nd := start
			start = start.next
			destroyNode(nd)
		}
		itSize -= 1
	}
	"[]" := !(int ind) -> T&
	{
		if ind < 0
			return this[itSize + ind]
		assert(ind >= 0 and ind < itSize)

		itr := start
		for i : ind
		{
			itr = itr.next
		}
		return itr.data
	}
	Size := !() -> int { return itSize }
	Destroy := virtual !() -> void
	{
		itr := start
		while itr != null
		{
			nd := itr
			itr = itr.next
			destroyNode(nd)

			start = null
			end = null
			itSize = 0
		}
	}
	//DeleteIf := !( !(T&)&->bool cb) -> void
	//{
	//	itr := Start
//
	//	while itr != null
	//	{
	//		if false //cb(itr.data)
	//		{
	//			if itSize == 1
	//			{
	//				destroyNode(start)
	//				start = null
	//				end = null
	//				itr = null
	//			}else if itr == start
	//			{
	//				start = itr.next
	//				deleteNode(itr)
	//				itr = start
	//			}else if itr == end
	//			{
	//				end = itr.prev
	//				deleteNode(itr)
	//				itr = null
	//			}else{
	//				itNode := itr
	//				itr = itNode.next
	//				itNode.prev.next = itNode.next
	//				itNode.next.prev = itNode.prev
	//			}
	//			itSize -= 1
//
	//		}else{
	//			itr = itr.next
	//		}
	//	}
	//}
	destroyNode := !(ListNode.{T}^ nd) -> void
	{
		if T->IsGCPointer
		{
			nd.data = null
		}
		delete nd
	}
	createNode := !() -> ListNode.{T}^
	{
		return new ListNode.{T}
	}
	"for" := !() -> TListIterator.{T}
	{
		result.iter = start
	}
}


TListIterator := class .{@T}
{
	iter := ListNode.{T}^
	HaveValue := !() -> bool
	{
		result = iter != null
	}
	"()" := !() -> T&
	{
		old := iter
		iter = iter.next
		return old.data
	}
}
