

EnterTaskThreadCycle := !(bool isMainThread) -> void
{
	TaskCheckMutex.Lock()
	
	while true
	{
		ct := CurrentThread

		if ct.DeleteTasks.Size() != 0
		{
			delTask := ct.DeleteTasks.Pop()
			ct.AllTasks.Remove(delTask)
			delTask.Destroy()
			delTask = null
			continue
		}


		doTask := ct.PopReadyTask()

		if doTask != null
		{
			doTask.switchToTask()
			continue
		}

		//TODO prioritize least busy thread to work on event loop
		if TaskLoopWorkCounter != 0 and not someoneOnLoop
		{
			someoneOnLoop = true

			nowTime := GetSteadyTime()
	
			while TaskTimersArray.Size() != 0 and TaskTimersArray[0].0 <= nowTime
			{
				TaskTimersArray[0].1.resume()
				TaskTimersArray[0].1 = null //TODO GC collection,  make it automaticly somehow
				cc := TaskTimersArray.Pop()
				cc.1 = null //TODO GC problem, tuples does not support it
				TaskLoopWorkCounter -= 1
			}
			waitTime := 1->{double}
			if TaskTimersArray.Size() != 0
			{
				waitTime = TaskTimersArray[0].0 - nowTime
			}
			if TaskLoopWorkCounter != 0
			{
				TaskCheckMutex.Unlock()
				TaskCodePollWork(waitTime)
				TaskCheckMutex.Lock()
			}
			someoneOnLoop = false
		}else{
			TaskPausedWorkers += 1
			if TaskPausedWorkers == TaskAdditionalWorkers.Size() + 1
			{
				cntr := TaskMainTaskWorker.AllTasks.Size()
				for it : TaskAdditionalWorkers
				{
					cntr += it.AllTasks.Size()
				}
				if cntr == 0
				{
					TaskQuitProgram = true
					TaskWaitTasksConVar.NotifyAll()
				}else{
					if TaskMainTaskWorker.PendingTasks.Size() != 0
						TaskWaitTasksConVar.NotifyAll()
					TaskWaitTasksConVar.Wait(TaskCheckMutex)
				}
			}else{
				TaskWaitTasksConVar.Wait(TaskCheckMutex)
			}
			TaskPausedWorkers -= 1
		}

		if TaskQuitProgram
			break
	}

	TaskCheckMutex.Unlock()

	if isMainThread
	{
		for it : TaskAdditionalWorkers
		{
			it.itThread.Join()
		}
	}
}
someoneOnLoop := bool
TaskLoopWorkCounter := int
