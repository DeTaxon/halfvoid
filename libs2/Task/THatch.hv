THatchCounter := class
{
	counter := int
	subHatch := THatch

	Inc := !() -> void
	{
		counter += 1
	}
	Dec := !() -> void
	{
		counter -= 1
		if counter == 0
			subHatch.Emit()
	}
	WaitZero := !() -> void
	{
		if counter != 0
			subHatch.Await()
	}
}

THatchLock := !(void^ k) -> void { TLock(k) }
THatchUnlock := !(void^ k) -> void { TUnlock(k) }

THatch := class
{
	flag := bool
	next_wakeup := TITaskPausePoint^

	Emit := !() -> void
	{
		THatchLock(this&)
		TaskCheckMutex.Lock()
		flag = true
		itr := next_wakeup
		while itr != null
		{
			itr.itTask.resume()
			itr.itTask = null
			itr = itr.next_point
		}
		TaskWaitTasksConVar.NotifyAll()
		TaskCheckMutex.Unlock()
		THatchUnlock(this&)
	}
	Await := !() -> void
	{
		if flag
			return void
		THatchLock(this&)
		pt := TITaskPausePoint
		//pt.Pause(next_wakeup&)
		pt.next_point = next_wakeup
		next_wakeup = pt&
		pt.itTask = CurrentTask
		THatchUnlock(this&)
		CurrentThread.switchToMain()
	}
}

TITaskPausePoint := class
{
	itTask := Task^	
	next_point := TITaskPausePoint^
}

TaskGetHatchWork := !() -> TaskData^
{
	if pausePoint == null
		return null
	retVal := pausePoint.itTask
	pausePoint = pausePoint.next_point
	return retVal
}

// debugTemp := List.{TITaskPausePoint^}
// hatchAbandoned := bool

// pausePoint := TITaskPausePoint^


// CheckHatchError := !() -> TaskData^
// {
// 	if debugTemp.Size() != 0
// 	{
// 		printf("abandoned count %i\n",debugTemp.Size())
// 		hatchAbandoned = true
// 		return debugTemp[0].itTask
// 	}
// }
