CacheFile := class extend TGCObject
{
	zipFile := ZipRWFile^

	this := !(StringView fName) -> void
	{
		zipFile = new ZipRWFile(fName)

	}


	Flush := !() -> void
	{
		for it : stringModules
		{
			it->{CacheStringModule^}.Flush()
		}
		zipFile.Flush()
	}
	TryGetCacheValue := !(vRepoFile^ fl) -> Blob^
	{
		inRep := zipFile.TryGetFile(fl.GetPath())
		if inRep == null
			return null
		fileTime := fl.GetModificationTime()
		cacheTime := inRep.GetModificationTime()

		if (fileTime - cacheTime)->{s64} > 0 //TODO fileTime > cacheTime does not work
		{
			return null
		}else{
			mp := inRep.GetMap()
			resBlob := new BlobOnVector(mp.Size())
			if mp.Size() != 0
				memcpy(resBlob.GetPointer(),mp.Get(),mp.Size())
			return resBlob
		}
	}
	WriteCacheOfFile := !(vRepoFile^ fl,Blob^ data) -> void
	{
		itPath := fl.GetPath()
		zipFile.WriteFile(itPath,data)
	}

	stringModules := AVLMap.{String^,void^} //TODO way to make weak references
	GetStringModule := !(StringView name) -> CacheStringModule^
	{
		stName := name.GetString()
		
		if stringModules.Contain(stName)
			return stringModules[stName]->{CacheStringModule^}

		result = new CacheStringModule(stName,this&)
		stringModules[stName] = result
	}
}

CacheStringModule := class extend TGCObject
{
	base := CacheFile^
	moduleName := String^

	this := !(String^ nm, CacheFile^ bs) -> void
	{
		base = bs
		moduleName = nm

		LoadMeta()
	}
	CacheChangedBlobData := bool
	CacheBlobList  := List.{BlobCacheData} //TODO Optimize
	CacheBlobByString := !(StringView value, !()&->Blob^  cb) -> Blob^
	{
		for it : CacheBlobList
		{
			if it.key == value
			{
				if not it.loaded
				{
					fileInZip := base.zipFile.TryGetFile(it.fileName)
					assert( fileInZip != null)
					if fileInZip != null
					{
						mp := fileInZip.GetMap()
						newBlob := new BlobOnVector(mp.Size()->{s64})
						memcpy(newBlob.GetPointer(),mp.Get(),mp.Size())
						it.loaded = true
						it.value = newBlob
						return newBlob
					}
				}else{
					return it.value
				}
			}
		}
	
		CacheChangedBlobData = true
		newBlob :=cb()
	
		newId := 0
		buf := char[255]
		while true
		{
			found := false
			sprintf(buf[0]&,"CacheBlob%i",newId)
			for it : CacheBlobList
			{
				if it.fileName == buf
				{
					found = true
					break
				}
			}
			if found
			{
				newId += 1
			}else{
				break
			}
		}
	
		CacheBlobList.Emplace()
		newEntry := ref CacheBlobList[CacheBlobList.Size() - 1]
		newEntry.key = value.GetString()
	
		newEntry.fileName = new String(buf[0]&)
		newEntry.value = newBlob
		newEntry.changed = true
		newEntry.loaded = true
	
		return newBlob
	}
	LoadMeta := !() -> void
	{
		blobCacheMeta := base.zipFile.TryGetFile("BlobCache.txt")
		if blobCacheMeta != null
		{
			mp := blobCacheMeta.GetMap()

			spn := StringSpan(mp.Get()->{char^},mp.Size())

			spn.DivideStr("\n", x ==> {
				while true
				{
					val := x
					yield void
					CacheBlobList.Emplace()
					newEntry := ref CacheBlobList[CacheBlobList.Size() - 1]
					newEntry.key = val.GetString()
					newEntry.fileName = x.GetString()
					yield void
				}
			})
		}
	}
	Flush := !() -> void
	{
		if CacheChangedBlobData
		{
			assert(CacheBlobList.Size() != 0)

			MetaCache := TEchoStream
			for it : CacheBlobList
			{
				if it.changed
				{
					base.zipFile.WriteFile(it.fileName,it.value)
				}
				MetaCache << it.key << "\n" << it.fileName << "\n"
			}

			tempBlob := new BlobOnVector(MetaCache.Size())
			MetaCache.Read(tempBlob.GetPointer(),tempBlob.Size())
			
			base.zipFile.WriteFile("BlobCache.txt",tempBlob)
		}
	}
}

BlobCacheData := class
{
	key := String^
	fileName := String^
	value := Blob^
	changed := bool
	loaded := bool

	this := !() -> void {}
	"=" := default
}
