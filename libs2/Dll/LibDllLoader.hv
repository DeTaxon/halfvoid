image_dos_signature := 0x5a4d
image_dos_header := packed_class
{
	e_magic := u16
	e_cblp := u16
	e_cp := u16
	e_crlc := u16
	e_cparhdr := u16
	e_minalloc := u16
	e_maxalloc := u16
	e_ss := u16
	e_csum := u16
	e_ip := u16
	e_ip := u16
	e_cs := u16
	e_lfarlc := u16
	e_ovno := u16
	e_res := u16[4]
	e_oemid := u16
	e_oeminfo := u16
	e_res2 := u16[10]
	e_lfanew := s32 //LONG
}

image_file_header := packed_class
{
	Machine := u16
	NumberOfSections := u16
	TimeDateStamp := u32
	PointerToSymbolTable := u32
	NumberOfSymbols := u32
	SizeOfOptionalHeader := u16
	Characteristics := u16
}
image_data_directory := packed_class
{
	VirtualAddress := u32
	Size := u32
}
image_optional_header64 := packed_class
{
	Magic := u16
	MajorLinkerVersion := u8
	MinorLinkerVersion := u8
	SizeOfCode := u32
	SizeOfInitializedData := u32
	SizeOfUninitializedData := u32
	AddressOfEntryPoint := u32
	BaseOfCode := u32
	ImageBase := void^
	SectionAligment := u32
	FileAligment := u32
	MajorOperatingSystemVersion := u16
	MinorOperatingSystemVersion := u16
	MajorImageVersion := u16
	MinorImageVersion := u16
	MajorSubsystemVersion := u16
	MinorSubsystemVersion := u16
	Win32VersionValue := u32
	SizeOfImage := u32
	SizeOfHeaders := u32
	CheckSum := u32
	Subsystem := u16
	DllCharacteristics := u16
	SizeOfStackReserve := u64
	SizeOfStackCommit := u64
	SizeOfHeapReserve := u64
	SizeOfHeapCommit := u64
	LoaderFlags := u32
	NumberOfRvaAndSizes := u32
	DataDirectory := image_data_directory[16]
}
image_nt_header64_signature := 0x4550 //0x00004550
image_nt_header64 := packed_class
{
	Signature := u32
	FileHeader := image_file_header
	OptionalHeader := image_optional_header64
}

image_section_header := packed_class
{
	Name := char[8]
	VirtualSize := u32
	//PhysicalAddress := u32 at VirtualSize
	VirtualAddress := u32
	SizeOfRawData := u32
	PointerToRawData := u32
	PointerToRelocations := u32
	PointerToLinenumbers := u32
	NumberOfRelocations := u16
	NumberOfLinenumbers := u16
	Characteristics := u32
}

image_import_descriptor := packed_class
{
	Characteristics := u32
	//OriginalFirstTrunk := u32 at Char
	TimeDateStamp := u32
	ForwardedChain := u32
	Name := u32
	FirstThunk := u32
}

image_export_descriptor := packed_class
{
	Characteristics := u32
	TimeDateStamp := u32
	MajorVersion := u16
	MinorVersion := u16
	Name := u32
	Base := u32
	NumberOfFunctions := u32
	NumberOfNames := u32
	AddressOfFunctions := u32
	AddressOfNames := u32
	AddressOfNameOrdinals := u32
}
image_import_by_name := packed_class
{
	Hint := u16
	Name := char[1]
}
image_base_relocation := packed_class
{
	VirtualAddress := u32
	SizeOfBlock := u32
}
image_tls_directory64 := packed_class
{
	StartAddressOfRawData := u64
	EndAddressOfRawData := u64
	AddressOfIndex := u64
	AddressOfCallBacks := u64
	SizeOfZeroFill := u32
	Characteristics := u32
}



IMAGE_SCN_MEM_EXECUTE := 0x20000000
IMAGE_SCN_MEM_READ := 0x40000000
IMAGE_SCN_MEM_WRITE := 0x80000000

win32DllLoadData := class
{
	loadedMem := void^
	loadedMemSize := size_t
	exportFunctions := AVLMap.{char^,void^}
}

win32LoadLibrary := !(void^ memPtr,size_t memSize) -> win32DllLoadData^
{
	dos_part := memPtr->{image_dos_header^}

	nt_part := memPtr->{u8^}[dos_part.e_lfanew]&->{image_nt_header64^}
	//TODO:Check host
	//TODO:Check aligment
	sections := nt_part.OptionalHeader&->{char^}[nt_part.FileHeader.SizeOfOptionalHeader]&->{image_section_header^}
	//TODO:Check 4GB span boundry
	//TODO newMem := VirtualAlloc(nt_part.OptionalHeader.ImageBase,nt_part.OptionalHeader.SizeOfImage,MEM_RESERVE,PAGE_READWRITE)
	//TODO: memory leak, delete on close

	hdrs := malloc(mt_part.OptionalHeader.SizeOfHeaders) //VirtualAlloc(newMem,nt_part.OptionalHeader.SizeOfHeaders,MEM_COMMIT,PAGE_READWRITE)

	memcpy(hdrs,memPtr,nt_part.OptionalHeader.SizeOfHeaders)

	//getSectionSize := (int sId,int^ sSize) ==> 
	//{
	//	sSize^ = 0
	//	for j : nt_part.FileHeader.NumberOfSections
	//	{
	//		if sId == j continue
	//		if sections[sId].VirtualAddress > sections[j].VirtualAddress continue

	//		sizeSec := sections[j].VirtualAddress - sections[sId].VirtualAddress
	//		if sSize^ == 0
	//		{
	//			sSize^ = sizeSec
	//		}else{
	//			if sizeSec < sSize^ sSize^ = sizeSec
	//		}
	//	}
	//}

	for i : nt_part.FileHeader.NumberOfSections
	{
		section := ref sections[i]
		dest := void^()
		//if sections[i].SizeOfRawData == 0
		//{
		//	sSize := 0
		//	getSectionSize(i,sSize&)

		//	if sSize != 0
		//	{
		//		dest2 := VirtualAlloc(newMem + section.VirtualAddress,sSize,MEM_COMMIT,PAGE_READWRITE)
		//		memset(dest2,0,sSize)
		//	}
		//	
		//}else{
		//	dest = VirtualAlloc(newMem + section.VirtualAddress,section.SizeOfRawData,MEM_COMMIT,PAGE_READWRITE)
		//}
		//if dest != null
		//{
		//	memcpy(newMem + section.VirtualAddress,memPtr + section.PointerToRawData,section.SizeOfRawData)
		//}
	}

	//if newMem != nt_part.OptionalHeader.ImageBase
	//{
	//	memDiff := size_t
	//	memLess := false
	//	if newMem > nt_part.OptionalHeader.ImageBase
	//	{
	//		memDiff = newMem - nt_part.OptionalHeader.ImageBase
	//	}else{
	//		memDiff = nt_part.OptionalHeader.ImageBase - newMem
	//		memLess = true
	//	}

	//	baseReloc := ref nt_part.OptionalHeader.DataDirectory[5]
	//	reloc := (newMem + baseReloc.VirtualAddress)->{image_base_relocation^}

	//	while reloc.VirtualAddress != 0
	//	{
	//		dest := newMem + reloc.VirtualAddress
	//		relInfo := (reloc + 1)->{u16^}
	//		
	//		nextReloc := (reloc->{void^} + reloc.SizeOfBlock)->{image_base_relocation^}
	//		while true
	//		{
	//			if relInfo >= nextReloc
	//				break
	//			relType := relInfo^ >> 12
	//			relOffset := relInfo^ and_b 0xFFF

	//			switch relType
	//			{
	//				case 3
	//					pathAddr32 := dest + relOffset
	//					if memLess
	//					{
	//						pathAddr32->{u32^}^ -= memDiff
	//					}else{
	//						pathAddr32->{u32^}^ += memDiff
	//					}
	//				case 10
	//					pathAddr64 := dest + relOffset
	//					if memLess
	//					{
	//						pathAddr64->{u64^}^ -= memDiff
	//					}else{
	//						pathAddr64->{u64^}^ += memDiff
	//					}
	//			}

	//			relInfo = relInfo + 1	
	//		}
	//		reloc = nextReloc
	//	}
	//}

	//imprtDir := ref nt_part.OptionalHeader.DataDirectory[1]
	//
	//dirS := (newMem +imprtDir.VirtualAddress)->{image_import_descriptor^}

	//i := 0
	//while true
	//{
	//	nowD := ref dirS[i]
	//	if nowD.Name == 0 break
	//	itLib := Library((newMem + nowD.Name)->{char^}) //TODO: ref count
	//	fT2 := (newMem + nowD.FirstThunk)->{void^^}
	//	fThunk := fT2
	//	
	//	if nowD.Characteristics != 0
	//	{
	//		fThunk = newMem + nowD.Characteristics
	//	}
	//	while fThunk^ != null
	//	{
	//		if (fThunk->{u64^}^ >> 63) != 0
	//		{
	//			printf("nope\n") //TODO
	//			assert(false)
	//		}else{
	//			mm := (newMem + fThunk->{u64^}^)->{image_import_by_name^}
	//			fT2^ = itLib.Get(mm.Name[0]&)
	//		}
	//		fThunk += 1
	//		fT2 += 1
	//	}

	//	i += 1
	//}
	//for i : nt_part.FileHeader.NumberOfSections
	//{
	//	section := ref sections[i]
	//	dest := void^()

	//	setFlag := 1
	//	isRead := ((section.Characteristics and_b IMAGE_SCN_MEM_READ) != 0)
	//	isWrite := ((section.Characteristics and_b IMAGE_SCN_MEM_WRITE) != 0)
	//	isExecute := ((section.Characteristics and_b IMAGE_SCN_MEM_EXECUTE) != 0)
	//	
	//	if isRead and not isWrite setFlag = PAGE_READONLY
	//	if isRead and isWrite setFlag = PAGE_READWRITE
	//	if not isRead and isWrite setFlag = PAGE_WRITECOPY
	//	
	//	if isExecute setFlag = setFlag << 4 
	//	setFlag = PAGE_EXECUTE_READWRITE //TODO: get shared pages chracteristics

	//	oldPg := u32
	//	if sections[i].SizeOfRawData == 0
	//	{
	//		sSize := 0
	//		getSectionSize(i,sSize&)

	//		if sSize != 0
	//		{
	//			VirtualProtect(newMem + section.VirtualAddress,sSize,setFlag,oldPg&)
	//		}
	//	}else{
	//		resV := VirtualProtect(newMem + section.VirtualAddress, section.SizeOfRawData,setFlag,oldPg&)
	//	}
	//}

	//tlsDir := ref nt_part.OptionalHeader.DataDirectory[9]
	//if tlsDir.VirtualAddress != 0
	//{
	//	cdb := (newMem + tlsDir.VirtualAddress)->{image_tls_directory64^}
	//	callbV := cdb.AddressOfCallBacks&->{void^^}^
	//	callb := callbV->{!(void^,int,void^)^^->void}
	//	while callb^ != null
	//	{
	//		callb^(newMem,1,null)
	//		callb = callb + 1
	//	}
	//	//assert(false)
	//}

	//if nt_part.OptionalHeader.AddressOfEntryPoint != 0
	//{
	//	entry := (newMem + nt_part.OptionalHeader.AddressOfEntryPoint)->{!(void^,u32,void^)^->void}
	//	//entry(newMem,1,null)
	//	//entry(newMem,2,null)
	//}

	//exprtDir := ref nt_part.OptionalHeader.DataDirectory[0]
	//exS := (newMem + exprtDir.VirtualAddress)->{image_export_descriptor^}

	//resDat := new win32DllLoadData

	//for j : exS.NumberOfNames
	//{
	//	nameRef := (newMem + exS.AddressOfNames + j*4)->{u32^}
	//	itName := newMem + nameRef^
	//	funcRef := (newMem + exS.AddressOfFunctions + j*4)->{u32^}
	//	itFunc := (newMem + funcRef^)->{!()^->void}
	//	resDat.exportFunctions[itName->{char^}] = itFunc
	//}
	//return resDat
}
