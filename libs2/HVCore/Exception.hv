
gExceptionPtrIndex := task_local int
gExceptionStackArr := task_local void^[256]
gExceptionStackSize := task_local int[256]

internalEnterGCFunction := !(void^^ arr,int maxSize) -> void
{
	assert(gExceptionPtrIndex < 256)
	gExceptionStackArr[gExceptionPtrIndex] = arr
	gExceptionStackSize[gExceptionPtrIndex] = maxSize
	gExceptionPtrIndex += 1
}
internalLeaveGCFunction := !() -> void
{
	gExceptionPtrIndex -= 1
}


IException := class extend TGCObject
{
	GetMessage := virtual !() -> String^
	{
		assert(false)
	}
}

gTryCatchInd := task_local int
gTryCatchObj := task_local Tuple.{void^,bool,int,int}[16]
gTryCatchException := task_local IException^

internalEnterTryCatch := !(void^ ptr,bool cleanGC,int gcInUse) -> void
{
	gTryCatchObj[gTryCatchInd].0 = ptr
	gTryCatchObj[gTryCatchInd].1 = cleanGC
	gTryCatchObj[gTryCatchInd].2 = gcInUse
	gTryCatchObj[gTryCatchInd].3 = gExceptionPtrIndex
	gTryCatchInd += 1
}
internalLeaveTryCatch := !() -> void
{
	gTryCatchInd -= 1
}
internalThrowException := !(IException^ e) -> void
{
	if gTryCatchInd == 0
	{
		printf("Exception %s\n",e.GetMessage().Str()) //TODO make it better
		assert(false)
		exit(0)
	}
	assert(gTryCatchInd != 0 and gExceptionPtrIndex != 0)
	gTryCatchException = e

	nowCatch := gTryCatchObj[gTryCatchInd - 1]&
	while gExceptionPtrIndex > nowCatch.3
	{
		gExceptionPtrIndex -= 1
		internalHVGCSetNullArray(gExceptionStackArr[gExceptionPtrIndex]->{TGCIObject^^},0,gExceptionStackSize[gExceptionPtrIndex] - 1)
	}
	if nowCatch.1
	{
		ind := gExceptionPtrIndex - 1
		internalHVGCSetNullArray(gExceptionStackArr[ind]->{TGCIObject^^},nowCatch.2,gExceptionStackSize[ind] - 1)
	}
	llvmLongJump(nowCatch.0)
}
internalGetException := !() -> IException^
{
	result = gTryCatchException
}


Exception := class extend IException //TODO!!
{
	thisMsg := String^
	this := !(char^ msg) -> void
	{
		thisMsg = new String(msg)
	}

	this := !(StringView msg) -> void
	{
		thisMsg = msg.GetString()
	}
	GetMessage := virtual !() -> String^
	{
		return thisMsg
	}
}
