TILambda := class extend TGCObject
{
	IsFinished := virtual !() -> bool
	{
		return false
	}

	getCaptureVar := virtual !() -> void^ { return null }
	getYieldState := virtual !() -> ref int {  } //TODO assert
	getYieldVars := virtual !() -> void^ { return null }
	getGCVars := virtual !() -> void^ { return null }
}

TLambda := class .{@FuncPtr} extend TILambda
{
	callFunc := FuncPtr
	//"()" := !(args...)
	//{
	//	return this.callFunc(this&,argc...)
	//}
	Capture := virtual !() -> TLambda.{FuncPtr}^
	{
		return null
	}
}
TLambdaImp := class .{@FuncPtr,@CapTypePtr,@YieldTuple} extend TLambda.{FuncPtr}
{
	capPtr := CapTypePtr
	yieldState := int
	lambdaVars := YieldTuple

	IsFinished := virtual !() -> bool { return yieldState < 0 }
	getCaptureVar := virtual !() -> void^ {  result = capPtr }
	getYieldState := virtual !() -> ref int { return yieldState }
	getYieldVars := virtual !() -> void^ { return lambdaVars& }

	Capture := virtual !() -> TLambda.{FuncPtr}^
	{
		newLambda := new TLambdaImpCaptured.{FuncPtr,CapTypePtr,YieldTuple}
		newLambda.callFunc = callFunc

		if capPtr == null
		{
			i := 0
			for it : newLambda.thisCapturedVars->AllFields
			{
				i += 1
			}
			if i != 0
			{
				printf("wow %s\n",CapTypePtr->TypeName)
				for it : newLambda.thisCapturedVars->AllFields
				{
					printf("hah %s\n",it->TypeName)
				}
				assert(capPtr != null)
			}
		}
		for setField : newLambda.thisCapturedVars->AllFields , getField : this.capPtr^->AllFields
		{
			if getField->TypeGroup == "Class"
			{
				assert(false) //TODO , check for operator = not implemented
			}else{
				if getField->TypeGroup == "Array"
				{
				}else{
					setField = getField
				}
			}
		}

		for setField : newLambda.lambdaVars->AllFields , getField : this.lambdaVars->AllFields
		{
			if getField->TypeGroup == "Class"
			{
				//assert(false) //TODO , check for operator = not implemented
			}else{
				if getField->TypeGroup == "Array"
				{

				}else{
					setField = getField
				}
			}
		}
		newLambda.capPtr = newLambda.thisCapturedVars&

		return newLambda
	}
	Destroy := virtual !() -> void
	{
		internalGCClearClass(lambdaVars)
	}
}
TLambdaImpCaptured := class .{@FuncPtr,@CapType^,@YieldTuple} extend TLambdaImp.{FuncPtr,CapType^,YieldTuple}
{
	thisCapturedVars := CapType
	getCaptureVar := virtual !() -> void^ {  result = thisCapturedVars& }
	Destroy := virtual !() -> void
	{
		internalGCClearClass(thisCapturedVars)
		internalGCClearClass(lambdaVars)
	}
}

internalHVLambdaCall := !(@T lmb,args...) -> void // return type replaced by compiler on result type of @FuncType
{
	return lmb.callFunc(lmb&,args...)
}
internalHVLambdaGetCaptures := !(void^ lmbd) .{@T} -> T^
{
	result = lmbd->{TILambda^}.getCaptureVar()->{T^}
}
internalHVLambdaGetYieldState := !(void^ lmbd) -> ref int
{
	return lmbd->{TILambda^}.getYieldState()
}

internalHVLambdaGetYieldTuple := !(void^ lmbd) .{@LambdaVarsTuple} -> LambdaVarsTuple^
{
	return lmbd->{TILambda^}.getYieldVars()->{LambdaVarsTuple^}
}


internalHVCreateLambda := !(@FuncPtr fnc,@CaptureTuple^ CaptureVars).{@YieldVars} -> TLambdaImp.{FuncPtr,CaptureTuple^,YieldVars}
{
	if CaptureVars == null
	{
		c := CaptureTuple

		i := 0
		for it : c->AllFields
		{
			i += 1
		}
		if i != 0
		{
			printf("AHA %i\n",i)
		}
		assert( i == 0)
	}

	result.callFunc = fnc
	result.capPtr = CaptureVars
}
