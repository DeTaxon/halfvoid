
ZipRWFile := class extend TGCObject
{
	fileZipName := String^
	fileExists := bool
	fileData := List.{zipIntEntry}
	fileMap := MappedFile^

	this := !(StringView inFileName) -> void
	{
		fileZipName = inFileName.GetString()
		if fsIsExist(fileZipName.Str())
		{
			fileExists = true
			fileMap = new MappedFile(fileZipName.Str(),FILE_READ and_b FILE_WRITE)
			ZipParse(fileMap.Get(),fileMap.Size(),fileData)
		}
	}
	TryGetFile := !(StringView fileName) -> vZipEntry2^ 
	{
		for it : fileData
		{
			if it.fileName == fileName
			{
				result = new vZipEntry2 //TODO memory leak
				result.zipSize = it.dataSize
				result.realSize = it.dataSize
				result.ptrToObj = fileMap.Get()->{u8^}[it.offsetToData]&
				return void
			}
		}
		return null
	}
	WriteFile := !(StringView fileName, u8[] data) -> void //TODO folder support
	{
		endOfMainData := u64
	
		fileData.DeleteIf(x => x.fileName == fileName)
		
		for it : fileData
		{
			itEnd := it.offsetToData + it.dataSize
			endOfMainData = max(endOfMainData,itEnd)
		}

		BusyPages := List.{Tuple.{u64,u64}} //TODO optimize to RangeSetClass
		for it : fileData
		{
			tpl := Tuple.{u64,u64}
			tpl.0 = it.offsetToFileHeader
			tpl.1 = it.offsetToFileHeader + it.dataSize + it.fileName.Size() + zipFileHeader->TypeSize
			BusyPages.SortedPush(tpl)
		}
		freePages := List.{Tuple.{u64,u64}}

		if BusyPages.Size() != 0 and BusyPages[0].0 != 0
		{
			freePages.Emplace(0,BusyPages[0].0)
		}

		if BusyPages.Size() >= 2
		{
			for i : (BusyPages.Size() - 1)
			{
				maybeFree := !{BusyPages[i].1,BusyPages[i+1].0}
				if maybeFree.0 != maybeFree.1
					freePages.Push(maybeFree)
			}
		}

		reqSize := zipFileHeader->TypeSize + fileName.Size() + data.Size()
		foundPos := false
		writeRange := Tuple.{u64,u64}
		for it : freePages
		{
			if it.1 - it.0 >= reqSize
			{
				foundPos = true
				writeRange = it
				break
			}
		}

		if not foundPos
		{
			writeRange.0 = endOfMainData
			writeRange.1 = endOfMainData + reqSize
			endOfMainData += reqSize
		}

		//dataList := List.{Range}
		//dataList.Push(Range(0..endOfMainData))

		//TODO check if file exists
		fileData.Emplace()
		newField := ref fileData[fileData.Size() - 1]

		newField.offsetToFileHeader = writeRange.0
		newField.offsetToData = writeRange.0 + fileName.Size() + zipFileHeader->TypeSize
		newField.fileName = fileName.GetString()
		newField.dataSize = data.Size()
		
		newSize := endOfMainData

		for it : fileData
		{
			newSize += zipCentralDirectory->TypeSize
			newSize += it.fileName.Size()
			//comments,extra fields
		}

		newSize += zipEndOfDirectory->TypeSize

		if not fileExists
		{
			fileMap = new MappedFile(fileZipName.Str(),FILE_READ + FILE_WRITE,newSize)
		}else{
			if newSize != fileMap.Size()
			{
				fileMap.ResizeFile(newSize)
			}
		}
		
		ptr := fileMap.Get()->{u8^}

		fileWritePtr := ptr[writeRange.0]&

		fileHeader := fileWritePtr->{zipFileHeader^}
		ZeroMem(fileHeader^)
	
		fileHeader.signature = 0x04034b50
		fileHeader.compressedSize = data.Size()
		fileHeader.realSize = data.Size()
		fileHeader.fileNameLen = fileName.Size()

		fileWritePtr = fileWritePtr[zipFileHeader->TypeSize]&
		
		memcpy(fileWritePtr,fileName.NonNullStr(),fileName.Size())

		fileWritePtr = fileWritePtr[fileName.Size()]&

		if data.Size() != 0
		{
			assert(data.GetPointer() != null)
			memcpy(fileWritePtr,data.GetPointer(),data.Size())
		}

		ptr = ptr[endOfMainData]&

		cdSize := 0

		offsetToCD := endOfMainData

		for it : fileData
		{
			cdEntry := ptr->{zipCentralDirectory^}
			ZeroMem(cdEntry^)
			cdEntry.signature = 0x02014b50
			cdEntry.madeWithVersion = 20
			cdEntry.versionNeedToExtract = 20
			cdEntry.compressedSize = it.dataSize
			cdEntry.realSize = it.dataSize
			cdEntry.fileNameLen = it.fileName.Size()
			cdEntry.offsetToFileHeader = it.offsetToFileHeader

			ptr = ptr[zipCentralDirectory->TypeSize]&

			for i : it.fileName.Size()
				it.fileName.Str()[i]

			memcpy(ptr,it.fileName.Str(),it.fileName.Size())

			ptr = ptr[it.fileName.Size()]&

			newSize += it.fileName.Size()
			//comments,extra fields

			cdSize += zipCentralDirectory->TypeSize + it.fileName.Size()
		}
		end := ptr->{zipEndOfDirectory^}
		ZeroMem(end^)
		end.signature = 0x06054b50
		end.diskNumber = 0
		end.centrDirStartDisk = 0
		end.numberOfCentralDirectoryHere = fileData.Size()
		end.totalNumberOfCentralDirectory = fileData.Size()
		end.sizeOfCentralDirectoryBytes = cdSize
		end.offsetToStartOfCD = offsetToCD
	}
	ZipParse := !(u8^ ptrToFl,u64 fileSize,List.{zipIntEntry} res)-> bool
	{
		eod := ptrToFl[fileSize - zipEndOfDirectory->TypeSize]&->{zipEndOfDirectory^}
	
		if eod.signature != 0x06054b50
		{
			return false
		}
	
		tableCount := eod.numberOfCentralDirectoryHere
		cdTable := ptrToFl[eod.offsetToStartOfCD]&->{zipCentralDirectory^}
		
	
		for i : tableCount
		{	
			ptrToStr := cdTable[1]&->{char^}
			newStr := StringSpan(ptrToStr,cdTable.fileNameLen)
	
			res.Emplace()
			newEn := ref res[res.Size() - 1]
			newEn.fileName = newStr.GetString()
			newEn.offsetToCDEntry = cdTable&->{u64^}^ - ptrToFl&->{u64^}^
			newEn.cdEntrySize = zipCentralDirectory->TypeSize
						+ cdTable.fileNameLen 
						+ cdTable.extraFieldsLen
						+ cdTable.commentLen
			if newStr[-1..0] != "/"
			{
				ptTH := ptrToFl[cdTable.offsetToFileHeader]&->{zipFileHeader^}
				newEn.fhSize = zipFileHeader->TypeSize + ptTH.fileNameLen + ptTH.extraFieldsLen
				dataStart := ptTH->{u8^}[newEn.fhSize]&
				newEn.offsetToData = dataStart&->{u64^}^ - ptrToFl&->{u64^}^
				newEn.offsetToFileHeader = ptTH&->{u64^}^ - ptrToFl&->{u64^}^
				newEn.dataSize = cdTable.compressedSize
			}else{
				newEn.offsetToData = 0
			}
	
			cdTable = cdTable->{u8^}[newEn.cdEntrySize]&->{zipCentralDirectory^}
		}
		return true
	}
}
vZipEntry2 := class
{
	ptrToObj := u8^
	offset := int
	realSize := u32
	zipSize := u32
	objName := StringSpan
	fullName := StringSpan
	comprType := int
	//subFolders := List.{vZipEntry^}
	//compressedPointer := void^

	"this" := !() -> void {}

	Size := !() -> size_t
	{
		return realSize
	}
	Name := !() -> StringSpan
	{
		return objName
	}
	Path := !() -> StringSpan
	{
		return fullName
	}

	GetMap := !() -> FileView^
	{
		if comprType == 8
		{
			assert(false)
		//	compressedPointer := malloc(realSize)
		//	resPtr := ptrToObj.asMapped.point[offset]&

		//	CrappyDeflateInflate(resPtr,zipSize,compressedPointer->{u8^},realSize)
		//	return new ZipFSFileViewZipDeflate(this&,compressedPointer->{u8^},realSize)
		}

		assert(comprType == 0)

		return new ZipFSFileViewZipStore(null,ptrToObj,realSize) //TODO make it non null
	}

	Print := !(int de) -> void
	{
		for i : de printf("-")

		printf("%s %i %i %i\n",objName.GetString().Str(),realSize,zipSize,comprType)
		subFolders[^].Print(de+1)
	}
}
zipIntEntry := class
{
	offsetToData := u64
	dataSize := u64
	offsetToFileHeader := u64
	fhSize := int
	offsetToCDEntry := u64
	cdEntrySize := int
	fileName := String^
	
	this := !() -> void {}
	"=" := default
}
