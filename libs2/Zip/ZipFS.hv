
vRepoObject := class
{
	objName := TString^
	upFolder := vRepoFolder^

	//GetName := !() -> StringSpan { result = objName }
	
	//GetUpFolder := !() -> vRepoFolder^ { return upFolder }

	GetPath := !() -> TString^
	{
		
		itms := List.{vRepoObject^}
		iterUp := this&
		while iterUp != null
		{
			itms.PushFront(iterUp)
			iterUp = iterUp.upFolder
		}
		
		strB := TEchoStream
		for it,i : itms
		{
			strB << it.objName
			if i != itms.Size() - 1
			{
				strB << "/"
			}
		}
		return strB.GetString()
	}
}

vRepoFolder := class extend vRepoObject
{
	examined := bool
	virtualFolder := bool
	subZipFolders := List.{vZipEntry^}

	subFolders := AVLMap.{TString^,vRepoFolder^}

	subFiles := AVLMap.{TString^,vRepoFile^}
	subVirtualFiles := AVLMap.{TString^,vRepoFile^}

	IsVirtual := !() -> bool { return virtualFolder }
}

vRepoFile := class extend vRepoObject
{
	ptrToRepo := vRepo^
	ptrToZip := vZipEntry^
	fileSize := u64

	this := !() -> void
	{
		ptrToProxy = null
	}
	// GetFile := !(char^ fileName) -> vRepoFile^
	// {
	// 	//return ptrToRepo.GetFile(fileName,upFolder)
	// }
	GetMap := !() -> FileView^
	{
		if ptrToZip != null
		{
			return ptrToZip.GetMap()
		}

		return new ZipFSFileView(this&)
	}
	IsVirtual := !() -> bool 
	{
		return ptrToZip != null
	}
	Size := !() -> size_t
	{
		// if ptrToZip != null
		// {
		// 	return ptrToZip.Size()
		// }
		// return fileSize
	}
	IsValid := !() -> bool
	{
	}
}

vRepo := class extend TGCObject
{
	rootFolder := vRepoFolder^
	ignZip := AVLSet.{u64}
	preferVirtual := bool

	zipFolders := AVLSet.{ZipFile^}

	Init := !(StringView pathName)-> void
	{
		rootFolder = new vRepoFolder
		rootFolder.objName = pathName.Normalize()
	}

	AddZipRoot := !(StringView fileName) -> bool
	{
		pth := fileName.Normalize()

		itId := osFileId(pth.Str())
		if itId == 0 return false

		itObj := new ZipFile
		if not itObj.AnalizeFile(fileName)
		{
			return false
		}
		ignZip.Insert(itId)
		zipFolders.Insert(itObj)
		rootFolder.subZipFolders.Push(itObj.zipRoot&)
	}
	// IsExist := !(StringSpan p) -> bool
	// {
	// 	return getObject(p,rootFolder) != null
	// }
	ReadFolder := !(StringView p,bool recur,!(vRepoFile^)& -> void callb) -> void
	{
		fil := getObject(p,rootFolder)
		if fil == null
			return void

		rep := fil->{vRepoFolder^}
		innerReadFolder(rep,recur,callb)
	}
	innerReadFolder := !(vRepoFolder^ rep,bool recur,!(vRepoFile^)& -> void callb) -> void
	{
		ExamineFolder(rep)

		for rep.subFiles callb(it)
		for rep.subVirtualFiles callb(it)
		if recur
		{
			for rep.subFolders
			{
				innerReadFolder(it,recur,callb)
			}
		}
	}
	GetFile := !(StringView fileName)-> vRepoFile^
	{
		return GetFile(fileName,rootFolder)
	}
	ExamineFolder := !(vRepoFolder^ iterFolder) -> void
	{
		assert(iterFolder != null)
		if iterFolder.examined
			return void
		iterFolder.examined = true

		zips := List.{TString^}

		if not iterFolder.virtualFolder
		{
			pth := iterFolder.GetPath()
			osReadFolder(pth.Str(),x ==> {

				if x.Str() == "." or x.Str() == ".."
					return void

				strName := x.Normalize()

				bigPath := TEchoStream
				bigPath << iterFolder.GetPath()
				bigPath << "/"
				bigPath << strName.Str()
				absPath := bigPath.GetString()

				if osIsFolder(absPath.Str())
				{
					newObj := new vRepoFolder
					newObj.objName = strName
					newObj.upFolder = iterFolder
					iterFolder.subFolders[strName] = newObj
				}else{
					itmId := osFileId(absPath.Str())
					flSz := osFileSize(absPath.Str())

					if ignZip.Contain(itmId)
					{
						return void
					}
					if strName.Str()[-4..0] == ".zip"
					{
						zips.Push(strName)
					}else{
						newObj2 := new vRepoFile
						newObj2.upFolder = iterFolder
						newObj2.objName = strName
						newObj2.ptrToRepo = this&
						newObj2.fileSize = flSz
						iterFolder.subFiles[strName] = newObj2
					}
				}
			})
		}

		strPath := iterFolder.GetPath()
		for z : zips
		{

			echo := TEchoStream
			echo << strPath << "/" << z

			absPath := echo.GetString()

			tt := new ZipFile
			tt.AnalizeFile(absPath.Str())
			zipFolders.Insert(tt)			

			rpFld := vRepoFolder^

			if iterFolder.subFolders.Contain(z)
			{
				rpFld = iterFolder.subFolders[z]
			}
			if rpFld == null
			{
				rpFld = new vRepoFolder
				rpFld.objName = z
				rpFld.upFolder = iterFolder
				rpFld.virtualFolder = true
				iterFolder.subFolders[z] = rpFld
			}
			rpFld.subZipFolders.Push(tt.zipRoot&)
		}

		for entrs : iterFolder.subZipFolders
		{
			for subItm, ind : entrs.subFolders
			{
				subItemName := subItm.objName.GetString()// TODO
				if iterFolder.subVirtualFiles.Contain(subItemName)
				{
					continue
				}
				
				found := false
				for it : iterFolder.subFolders
				{
					if it.objName == subItemName
					{
						found = true
						if subItm.realSize == 0
							it.subZipFolders.Push(subItm)
						break
					}
				}
				if found continue

				if subItm.realSize == 0
				{
					rpFld := new vRepoFolder
					rpFld.objName = subItemName
					rpFld.virtualFolder = true
					iterFolder.subFolders[subItemName] = rpFld 
					rpFld.subZipFolders.Push(subItm)
				}else{
					newObj := new vRepoFile 
					newObj.upFolder = iterFolder
					newObj.objName = subItemName
					newObj.ptrToRepo = this&
					iterFolder.subVirtualFiles[subItemName] = newObj
					newObj.ptrToZip = subItm
				}
			}
		}
	}

	GetFile := !(StringView fileName,vRepoFolder^ rrF) -> vRepoFile^
	{
		itms := List.{StringSpan}
		iterFolder := rrF
	
		fileName.DivideStr("\\/",x ==> { itms.Push(x) })
		for cheks,i : itms
		{
			if i == 0 and cheks == "." continue

			ExamineFolder(iterFolder)
				
			found := false
			for it : iterFolder.subFolders
			{
				if cheks == it.objName.Str()
				{
					iterFolder = it
					found = true
					break
				}
			}
			
			if found continue

			if cheks == ".."
			{
				iterFolder = iterFolder.upFolder
				if iterFolder == null
					return null
				continue
			}
			

			st := cheks.GetString()
			if preferVirtual
			{
				if iterFolder.subVirtualFiles.Contain(st)
					return iterFolder.subVirtualFiles[st]
			}
			if iterFolder.subFiles.Contain(st)
				return iterFolder.subFiles[st]
			if iterFolder.subVirtualFiles.Contain(st)
				return iterFolder.subVirtualFiles[st]

			throw new Exception("File not found")
		}
		throw new Exception("File not found")
	}
	getObject := !(StringView fileName,vRepoFolder^ rrF) -> vRepoObject^
	{
		stObj := fileName.Normalize()
		tmpVar := StringSpan(stObj.Str())

		itms := List.{StringSpan}
		tmpVar.DivideStr("/",x ==> { itms.Push(x) })
		iterFolder := rrF

		for cheks,i : itms
		{
			if i == 0 and cheks == "." continue

			ExamineFolder(iterFolder)

			partStr := cheks.GetString()
	
			if iterFolder.subFolders.Contain(partStr)
			{
				iterFolder = iterFolder.subFolders[partStr]
				continue
			}

			if cheks == ".."
			{
				iterFolder = iterFolder.upFolder
				if iterFolder == null
					return null
				continue
			}

			if preferVirtual
			{
				if iterFolder.subVirtualFiles.Contain(partStr)
					return iterFolder.subVirtualFiles[partStr]
			}
			if iterFolder.subFiles.Contain(partStr)
				return iterFolder.subFiles[partStr]
			if iterFolder.subVirtualFiles.Contain(partStr)
				return iterFolder.subVirtualFiles[partStr]

			return null

		}
		return iterFolder
	}
	// Destroy := !() -> void
	// {
	// }
}
