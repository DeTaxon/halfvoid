jsonTypeField := 0
jsonTypeRecord := 1
jsonTypeArray := 2

jsonNode := class
{
	this := !(int setType) -> void {itType = setType}

	haveName := bool
	itType := u8
	itKey := StringSpan
	itValue := StringSpan
	itSub := List.{jsonNode^}
	
	Key := !() -> ref StringSpan { return itKey }
	Value := !() -> ref StringSpan { return itValue }
	Print := !(int x) -> void
	{
		switch itType
		{	
			case jsonTypeField
				for x printf(" ")
				if haveName
				{
					printf("%s : %s\n",itKey,itValue)
				}else{
					printf("%s\n",itValue)
				}
			case jsonTypeRecord
				for x printf(" ")
				if haveName
				{
					printf("%s : {\n",itKey)
				}else{
					printf("{\n")
				}
				itSub[^].Print(x+1)
				for x printf(" ")
				printf("}\n")
			case jsonTypeArray
				for x printf(" ")
				if haveName
				{
					printf("%s : [\n",itKey)
				}else{
					printf("[\n")
				}
				itSub[^].Print(x+1)
				for x printf(" ")
				printf("]\n")
		}
	}
	IsField := !() -> bool { return itType == jsonTypeField}
	IsRecord := !() -> bool { return itType == jsonTypeRecord}
	IsArray := !() -> bool { return itType == jsonTypeArray}

	GetStr := !() -> StringSpan { result = itValue }
	GetInt := !() -> int { if itType != jsonTypeField throw new Exception("Node is not field") return ToInt(itValue.StrTmp())} //TODO: span to int
	GetFloat := !() -> float { if itType != jsonTypeField throw new Exception("Node is not field") return ToFloat(itValue)}

	"[]" := !(char^ walkPath) -> ref jsonNode
	{
		itms := DivideStr(walkPath,' ') //TODO memory 
		iter  := this&
		for it : itms
		{
			found := false
			for subs : iter.itSub
			{
				if subs.haveName and subs.itKey == it 
				{
					iter = subs
					found = true
					break
				}
			}
			if not found 
				throw new Exception("Path not found")
		}
		return iter^
	}
	
	"for" := !() { if itType == jsonTypeField throw new Exception("Node is field") return itSub."for"() }
}


jsonRegMachine := WordDetermMachine^
jsonLoaded := false
jsonLoadMachine := !() -> void
{
	if jsonLoaded return void
	jsonLoaded = true
	// regFile := FSGetFile("hres/json.stm")
	// if regFile == null
	// 	throw new Exception("can not initialize json state machine")
	// ptrMap := regFile.GetMap()
	// jsonRegMachine = new WordDetermMachine
	// jsonRegMachine.LoadFromMap(ptrMap.Get(),ptrMap.Size())
	// regFile.Unmap()

	itBuilder := LexBuilder()

	itBuilder.ApplyReg("\"((\\\\ [^]) | [^\"\\\\])*\"",1)
	itBuilder.ApplyReg("[0-9]+(.[0-9]+)?",2)
	itBuilder.ApplyReg("0x[0-9a-fA-F]+([0-9a-fA-F]+)?",2)
	itBuilder.ApplyReg(" true | false | null",3)
	itBuilder.ApplyReg("\\{ | \\} | \\, | \\: | \\[ | \\]",4)
	itBuilder.ApplyReg("\\ | \\t | \\n",5)

	jsonRegMachine = itBuilder.GenerateMachine()
}

json := class extend jsonNode
{
	startNode := jsonNode^
	tokens := List.{Tuple.{int,StringSpan}}

	ParseString := !(char^ fileData,int size) -> void
	{
		jsonLoadMachine()

		jsonRegMachine.RegExpReadText(fileData,size, (View,c) ==>
		{
			if c == 5
				return void
			tok := StringSpan(View.Str(),View.Size())
			tokens.Emplace(c,tok)
		})
		if tokens.Size() == 0 or tokens[0].0 != 4 or tokens[0].1 != "{"
			throw new Exception("Incorrect json")
		tokens.Pop()
		checkRecord(this&)
		itType = jsonTypeRecord
	}

		
	checkRecord := !(jsonNode^ toCheck) -> void
	{
		while tokens.Size() != 0 and not (tokens[0].0 == 4 and tokens[0].1 == "}")
		{
			if tokens[0].0 == 4 and tokens[0].1 == ","
				tokens.Pop()
			toCheck.itSub.Push(checkNode())
		}
		if tokens.Size() == 0
			throw new Exception("Incorrect")
		tokens.Pop()
	}
	checkArray := !(jsonNode^ toCheck) -> void
	{
		while tokens.Size() != 0 and not (tokens[0].0 == 4 and tokens[0].1 == "]")
		{
			if tokens[0].0 == 4 and tokens[0].1 == ","
				tokens.Pop()
			newNode := checkNode2(new jsonNode)
			toCheck.itSub.Push(newNode)
		}
		if tokens.Size() == 0
			throw new Exception("Incorrect")
		tokens.Pop()
	}
	checkNode := !() -> jsonNode^
	{
		thisNode := new jsonNode

		if tokens.Size() == 0 or tokens[0].0 != 1
			throw new Exception("Incorrect")
		thisNode.itKey = tokens[0].1[1..-1]
		thisNode.haveName = true
		tokens.Pop()

		if tokens.Size() == 0 or tokens[0].0 != 4 or tokens[0].1 != ":" 
			throw new Exception("Incorrect")
		tokens.Pop()
		if tokens.Size() == 0
			throw new Exception("Incorrect")
		return checkNode2(thisNode)
	}
	checkNode2 := !(jsonNode^ thisNode) -> jsonNode^
	{
		switch tokens[0].0
		{
		case in ![1,2,3]
			thisNode.itType = jsonTypeField
			if tokens[0].0 == 1
				thisNode.itValue = tokens[0].1[1..-1]
			else
				thisNode.itValue = tokens[0].1
			
			tokens.Pop()
		case 4
			switch tokens[0].1
			{
			case "["
				thisNode.itType = jsonTypeArray
				tokens.Pop()
				checkArray(thisNode)
			case "{"
				thisNode.itType = jsonTypeRecord
				tokens.Pop()
				checkRecord(thisNode)
			}
		}
		return thisNode
	}
}
