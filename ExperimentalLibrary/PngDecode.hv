DecodePNG := !(File^ f) -> Image^
{
	result = new Image

	w := 0
	h := 0
	bpp := 0
	isIndexed := false

	blb := f.GetBlob()

	fileEnd := blb.GetPointer()->{u8^}[blb.Size()]&

	iter := blb.GetPointer()->{u8^}[8]&

	dataChunks := List.{u8^}
	dataChunkTotalSize := 0

	while iter < fileEnd
	{
		len := FromBigEndian(iter->{u32^}^)
		iter = iter[4]&
		typ := StringSpan(iter->{char^},4)

		//printf("chunk %s %i\n",typ,len)

		switch typ
		{
		case "IHDR"
			hdr := iter[4]&->{PNG_IHDR^}
			w = FromBigEndian(hdr.Width)
			h = FromBigEndian(hdr.Height)

			assert(hdr.BitDepth == 8) //TODO other depths
			//assert(hdr.InterlaceMethod == 0)

			cType := hdr.ColorType

			if (cType and_b 1) != 0
			{
				isIndexed = true
				cType = cType xor_b 1
			}
			
			if cType == 6
			{
				bpp = 4
			}else if cType == 2
			{
				bpp = 3 //TODO Image supports types
			}else {
				assert(false) //TODO other color types
			}
			if isIndexed
				bpp = 1

		case "IDAT"
			dataChunks.Push(iter[-4]&)
			dataChunkTotalSize += len
		}

		iter = iter[len + 8]&
	}
	
	result.Width = w
	result.Height = h

	cmpBlob := MakeBlob(dataChunkTotalSize)

	outPtr := cmpBlob.GetPointer()->{u8^}

	for idat : dataChunks
	{
		len := ToBigEndian(idat->{u32^}^) //TODO from
		memcpy(outPtr,idat[8]&,len)
		outPtr = outPtr[len]&
	}

	deflData := malloc(w*h*bpp + h)->{u8^}
	defer free(deflData)

	deflStrip := w*bpp + 1

	CrappyDeflateInflate(cmpBlob.GetPointer()->{u8^}[2]&,cmpBlob.Size() - 6,deflData,w*h*bpp + h)

	readyData := calloc((w + 16)*(h + 16),bpp)->{u8^}
	defer free(readyData)

	readyStrip := (w + 16)*bpp

	for i : h
	{
		memcpy(readyData[readyStrip*i + 16*bpp]&,deflData[deflStrip*i + 1]&,w*bpp)
	}

	newText := malloc((w + 16)*(h + 16)*bpp)->{u8^}
	defer free(newText)

	newTextStrip := readyStrip

	getPtr := readyData[16*bpp]&
	setPtr := newText[16*bpp]&

	for i : h
	{
		filtType := deflData[i*deflStrip]
		for j : w
		{
			for k : bpp
			{
				sIndx := newTextStrip*i + j*bpp + k
				gIndx := readyStrip*i + bpp*j + k
				switch filtType
				{
					case 0
						setPtr[sIndx] = getPtr[gIndx]
					case 1
						setPtr[sIndx] = getPtr[gIndx] + setPtr[sIndx - bpp]
					case 2
						setPtr[sIndx] = getPtr[sIndx] + setPtr[sIndx - newTextStrip]
					case 3
						//TODO
						avrg := (setPtr[sIndx - bpp]->{u32} + setPtr[sIndx -  newTextStrip]->{u32}) div 2
						setPtr[sIndx] = getPtr[sIndx] + avrg
					case 4
						setPtr[sIndx] = getPtr[gIndx]

						left := setPtr[sIndx - bpp]->{u32}->{int}
						up := setPtr[sIndx - newTextStrip]->{u32}->{int}
						upLeft := setPtr[sIndx - newTextStrip - bpp]->{u32}->{int}

						p := left + up - upLeft
						pa := Abs(p - left)
						pb := Abs(p - up)
						pc := Abs(p - upLeft)
						r := 0
						if pa <= pb and pa <= pc
						{
							r = left
						}else if pb <= pc
						{
							r += up
						}else{
							r += upLeft
						}
						setPtr[sIndx] += r
					
					case void
						assert(false)
						setPtr[newTextStrip*i + j*bpp + k] = getPtr[readyStrip*i + bpp*j + k]
				}
			}
			
		}
	}
	
	
	res := malloc(w*h*bpp)->{u8^}
	
	for i : h
	{
		memcpy(res[w*bpp*i]&,newText[newTextStrip*i + 16*bpp]&,w*bpp)
	}

	result.Data = res
}

PNG_IHDR := class
{
	Width := u32
	Height := u32
	BitDepth := u8
	ColorType := u8
	CompressionMethod := u8
	FilterMethod := u8
	InterlaceMethod := u8
}
