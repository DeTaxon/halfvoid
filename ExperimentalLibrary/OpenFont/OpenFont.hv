
OpenFont := class
{
	charToGlyph := AVLMap.{int,OFGlyph^}
}

OFGlyph := class
{
	onCurve := bool[]
	pos := vec2f[]
	cntrs := u16[]

	rangeX := Range
	rangeY := Range
	advanceWidth := float
}


NewOpenFont := !(Blob^ blb,Image^ img) -> OpenFont^
{
	result = new OpenFont

	loader := OpenFontLoader
	loader.Load(blb,img)

}

OpenFontLoader := class
{
	glyphs := OFGlyph[int]

	glyf := OpenTypeGlyf^
	head := OpenTypeHead^
	maxp := OpenTypeMaxP^
	cmap := void^
	loca := void^
	hmtx := u16^

	fmt4 := OpenTypeFormat4^

	Load := !(Blob^ blb,Image^ img) -> void
	{
		ptr := blb.GetPointer()->{u8^}

		hdr := ptr->{OpenTypeHeader^}

		printf("ver %i\n",FromBigEndian(hdr.numTables))

		itr := hdr[1]&->{OpenTypeTableHeader^}

		for i : FromBigEndian(hdr.numTables)
		{
			spn :=  StringSpan(itr[i].tag[0]&->{char^},4)
			// printf("table %s\n",spn)

			if spn == "glyf"
				glyf = ptr[FromBigEndian(itr[i].offset)]&->{OpenTypeGlyf^}
			if spn == "head"
				head = ptr[FromBigEndian(itr[i].offset)]&->{OpenTypeHead^}
			if spn == "maxp"
				maxp = ptr[FromBigEndian(itr[i].offset)]&->{OpenTypeMaxP^}
			if spn == "loca"
				loca = ptr[FromBigEndian(itr[i].offset)]&
			if spn == "cmap"
				cmap = ptr[FromBigEndian(itr[i].offset)]&
			if spn == "hmtx"
				hmtx = ptr[FromBigEndian(itr[i].offset)]&->{u16^}
		}

		printf("num of glyphs %i\n",FromBigEndian(maxp.numGlyphs))


		cmapCount := FromBigEndian(cmap->{u16^}[1])
		printf("cmap count %i\n",cmapCount)
		cmapTables := cmap->{u16^}[2]&->{OpenTypeCMapTable^}
		for i : cmapCount
		{
			plat := FromBigEndian(cmapTables[i].platformID)
			enc := FromBigEndian(cmapTables[i].encodingID)
			offst := FromBigEndian(cmapTables[i].offset) 
			printf("Table %i %i\n",plat,enc)

			if plat == 0 and enc == 3
			{
				fmt := cmap->{u8^}[offst]&
				printf("format %i\n",FromBigEndian(fmt->{u16^}^))
				d := fmt->{OpenTypeFormat4^}
				fmt4 = d
			}
		}

		per := FromBigEndian(head.unitsPerEm)

		aliasScale := 8

		targetSize := 22
		pixelSize := targetSize*aliasScale

		offset3.x = 0
		offset3.y = 0

		// testChar := 'B'
		// printf("hey %i\n",testChar)
		// drawChar(testChar,img,pixelSize,per,aliasScale,targetSize)
		// return void

		for c : 'a'..'z'
		{
			drawChar(c,img,pixelSize,per,aliasScale,targetSize)
		}
		for c : 'A'..'Z'
		{
			drawChar(c,img,pixelSize,per,aliasScale,targetSize)
		}
		for c : '0'..'9'
		{
			drawChar(c,img,pixelSize,per,aliasScale,targetSize)
		}
	}
	offset3 := vec2f
	maxH := int

	drawChar := !(int c,Image^ img,int pixelSize,int per,int aliasScale,int targetSize) -> void
	{
		id := GetCharId(c)

		printf("char id %i\n",id)

		glp := GetGlyphById(id)

		cntrVec := ref glp.cntrs
		pos := ref glp.pos
		onCurve := ref glp.onCurve

		downHeight := 0
		if glp.rangeY.Start < 0
			downHeight = ((-glp.rangeY.Start)*pixelSize + per - 1) div per
		// printf("hey %f\n",glp.rangeY.Start / per)
		pixelWidth := (glp.rangeX.End*pixelSize + per - 1) div per

		
		tmp := hv_malloc(pixelWidth*(pixelSize + downHeight))->{u8^}
		// defer hv_free(tmp)

		// for i : pixelSize*pixelSize
		// 	tmp[i] = (RandInt(0..255) and_b 1) != 0

		startIndex := 0
		for cntr : cntrVec
		{
			crv := bool[]
			ps := vec2f[]

			for i : startIndex..cntr
			{
				ps.Push(pos[i])
				crv.Push(onCurve[i])
			}
			ps.Push(pos[startIndex])
			crv.Push(onCurve[startIndex])

			startIndex = cntr + 1

			// for i : (ps.Size() - 1)
			// {
			// 	img.DrawLine(ps[i],ps[i+1],Color("blue"))
			// }

			// printf("cntr\n")
			// printf("curves %i\n",crv[^])
			dist := 1
			prevPos := ps[0]
			i := 1

			scl := vec2f(pixelSize) / per
			ofst := vec2f(0.0,downHeight)

			drawBezier := (vec2f x, vec2f y, vec2f z) ==>
			{
				fillVal := x.y < z.y ?: 1 : 2
				leftGo := x.x > z.x

				x = x*scl + ofst
				y = y*scl + ofst
				z = z*scl + ofst

				pres := 260
				for i : 0..pres
				{
					proc := i / pres
					anti := 1.0 - proc

					t1 := x*anti + y*proc
					t2 := y*anti + z*proc

					point := t1*anti + t2*proc

					pId := point.x->{int} + point.y->{int}*pixelWidth

					pointX := point.x->{int}
					pointY := point.y->{int}

					if leftGo
					{
						if not (tmp[pId] == 1 and fillVal == 2)
							tmp[pId] = fillVal
					}else{
						tmp[pId] = fillVal
					}
				}
			}
			drawLine := (vec2f x, vec2f y) ==> 
			{
				fillVal := x.y < y.y ?: 1 : 2

				x *= scl
				x += ofst
				y *= scl
				y += ofst

				vc := y - x

				diffX := Abs(x.x - y.x)->{int}
				diffY := Abs(x.y - y.y)->{int}

				leftGo := x.x > y.x

				pres := 4

				if diffX > diffY
				{
					for i : (diffX*pres + 1)
					{
						mag := i /  (diffX*pres)
						point := x + vc*mag
						pId := point.x->{int} + point.y->{int}*pixelWidth

						if leftGo
						{
							if not (tmp[pId] == 1 and fillVal == 2)
								tmp[pId] = fillVal
						}else{
							tmp[pId] = fillVal
						}
					}
				}else{
					for i : (diffY*pres + 1)
					{
						mag := i /  (diffY*pres)
						point := x + vc*mag
						pId := point.x->{int} + point.y->{int}*pixelWidth

						if leftGo
						{
							if not (tmp[pId] == 1 and fillVal == 2)
								tmp[pId] = fillVal
						}else{
							tmp[pId] = fillVal
						}
					}
				}
			}

			while i < ps.Size()
			{
				if crv[i]
				{
					if dist == 1
					{
						// img.DrawLine(prevPos,ps[i],color)
						drawLine(prevPos,ps[i])
					}else{
						assert(dist == 2)
						// img.DrawBezier(prevPos,ps[i-1],ps[i],color)
						drawBezier(prevPos,ps[i-1],ps[i])
					}
					dist = 1
					prevPos = ps[i]
				}else{
					if crv[i-1]
					{
						dist += 1
						//skip for now
					}else{
						mdl := (ps[i] + ps[i-1])*0.5
						// img.DrawBezier(prevPos,ps[i-1],mdl,color)
						drawBezier(prevPos,ps[i-1],mdl)
						dist = 2
						prevPos = mdl
					}
				}
				i += 1
			}
		}

		for ln : pixelSize
		{
			prevIsSet := false
			j := 0
			while j < (pixelWidth - 1)
			{
				id := ln*pixelWidth + j

				if tmp[id] == 1 or tmp[id] == 4
				{
					j += 1
					while j < pixelWidth and tmp[ln*pixelWidth + j] != 2
					{
						tmp[ln*pixelWidth + j] = 3
						j += 1
					}
				}else{
					j += 1
				}
			}
		}

		// st := img.GetStride()
		// for i : pixelWidth
		// {
		// 	for j : pixelSize
		// 	{
		// 		if tmp[j*pixelWidth + i] != 0
		// 		{
		// 			col := Color
		// 			switch tmp[j*pixelWidth + i]
		// 			{
		// 			case 1 col = Color("green")
		// 			case 2 col = Color("red")
		// 			case 3 col = Color("blue")
		// 			case 4 col = Color("yellow")
		// 			}
		// 			img.SetPixel(vec2f(i+20,j+20),col)
		// 		}
		// 	}
		// }

		blockSize := aliasScale*aliasScale

		for w : targetSize
		{
			for h : (targetSize + (downHeight div aliasScale))
			{
				cntr := 0

				for i2 : aliasScale
				{
					for j2 : aliasScale
					{
						if tmp[i2 + w*aliasScale + (j2 + h*aliasScale)*pixelWidth] != 0
							cntr += 1
					}
				}

				sat := 1.0 - cntr / blockSize
				img.SetPixel(vec2f(w,h) + offset3,Color(sat))
			}
		}

		// printf("hey %f\n",glp.advanceWidth / per)
		// offset3.x += glp.advanceWidth*targetSize / per
		glW := (targetSize*glp.rangeX.End + per - 1) div per
		glH := (targetSize*(glp.rangeY.End - glp.rangeY.Start) + per - 1) div per
		offset3.x += glW

		maxH = max(maxH,glH)

		if offset3.x + targetSize > img.Width
		{
			offset3.x = 0
			offset3.y += maxH
			maxH = 0
		}
	}

	GetGlyphById := !(int id) -> OFGlyph^
	{
		result = new OFGlyph

		g := OpenTypeGlyf^

		// printf("HEY %i\n",head.indexToLocFormat&->{size_t} - head->{size_t})

		if head.indexToLocFormat == 0
		{
			ofsts := loca->{u16^}
			offset := FromBigEndian(ofsts[id])*2
			printf("offset1 %i\n",offset)
			g = glyf->{u8^}[offset]&->{OpenTypeGlyf^}
		}else{
			ofsts := loca->{u32^}
			offset := FromBigEndian(ofsts[id])
			printf("offset2 %i\n",offset)
			g = glyf->{u8^}[offset]&->{OpenTypeGlyf^}
		}

		cntrCount := FromBigEndian(g.numOfContours)
		printf("min %i max %i\n",FromBigEndian(g.xMin),FromBigEndian(g.xMax))
		printf("min %i max %i\n",FromBigEndian(g.yMin),FromBigEndian(g.yMax))

		result.rangeX.Start = FromBigEndian(g.xMin)
		result.rangeX.End = FromBigEndian(g.xMax)
		result.rangeY.Start = FromBigEndian(g.yMin)
		result.rangeY.End = FromBigEndian(g.yMax)

		result.advanceWidth = FromBigEndian(hmtx[id*2])

		printf("advance width %f\n",result.advanceWidth)

		printf("countorCount %i\n",cntrCount)

		if cntrCount < 0
		{
			itr := g[1]&->{u8^}

			while true
			{
				flag := FromBigEndian(itr->{u16^}^)
				indx := FromBigEndian(itr[2]&->{u16^}^)

				itr = itr[4]&
				
				// arg1 := 0
				// arg2 := 0
				sArg1 := 0
				sArg2 := 0

				offst := vec2f

				if (flag and_b 1) != 0
				{
					// arg1 = FromBigEndian(itr[0]&->{u16^}^)
					// arg2 = FromBigEndian(itr[2]&->{u16^}^)
					sArg1 = FromBigEndian(itr[0]&->{s16^}^)
					sArg2 = FromBigEndian(itr[2]&->{s16^}^)
					itr = itr[4]&
				}else{
					// arg1 = itr[0]
					// arg2 = itr[1]
					sArg1 = itr[0]->{s8}
					sArg2 = itr[1]->{s8}
					itr = itr[2]&
				}

				// TODO use scale

				if (flag and_b 0x08) != 0 // we have a scale
				{
					itr = itr[2]&
				}else if (flag and_b 0x40) != 0 // scale x y
				{
					itr = itr[2]&
					itr = itr[2]&
				}else if (flag and_b 0x80) != 0
				{
					for 4
						itr = itr[2]&
				}

				if (flag and_b 0x02) != 0
				{
					offst.x = sArg1
					offst.y = sArg2
				}

				f := GetGlyphById(indx)

				ofst := result.pos.Size()
				result.pos.Push(f.pos[^] + offst)
				result.cntrs.Push(f.cntrs[^] + ofst)
				result.onCurve.Push(f.onCurve[^])

				if (flag and_b 0x20) == 0
					break
			}


			return void
		}

		cntrs := g[1]&->{u16^}
		cntrVec := ref result.cntrs
		cntrVec.Resize(cntrCount)


		for i : cntrCount
		{
			// printf("contour %i\n",FromBigEndian(cntrs[i]))
			cntrVec[i] = FromBigEndian(cntrs[i])
		}
		
		instructionsCount := FromBigEndian(cntrs[cntrCount])
		// printf("intr count %i\n",instructionsCount)

		instr := cntrs[cntrCount + 1]&->{u8^}

		for i : instructionsCount
		{
			// printf("intr %i\n",instr[i])
		}

		numFlags := cntrVec[cntrVec.Size() - 1] + 1

		flags := u8[]
		flags.Reserve(numFlags)

		flgIter := instr[instructionsCount]&->{u8^}

		while flags.Size() < numFlags
		{
			flg := flgIter^

			cnt := 1
			if (flg and_b 0x08) != 0 
			{
				flgIter = flgIter[1]&
				cnt = flgIter^ + 1
			}

			for cnt
				flags.Push(flg)

			flgIter = flgIter[1]&
		}

		onCurve := ref result.onCurve
		onCurve.Resize(numFlags)
		for it,i : flags
			onCurve[i] = (it and_b 0x1) != 0

		// printf("flagsCount %i %i\n",numFlags,flags.Size())
		// printf("flag %x\n",flags[^])

		pos := ref result.pos
		pos.Resize(numFlags)


		itr := flgIter
		OpenFontReadCoord(pos[0].x&,itr,flags,0x02,0x10,cntrVec)
		OpenFontReadCoord(pos[0].y&,itr,flags,0x04,0x20,cntrVec)

		// printf("points %f %f\n",pos[^i].x,pos[i].y)

	}
	GetCharId := !(int chr) -> int
	{
		cc := 0

		segCount := FromBigEndian(fmt4.segCountX2) div 2

		ends := fmt4[1]&->{u16^}
		starts := ends[segCount + 1]&
		deltas := starts[segCount]&->{s16^}
		ranges := deltas[segCount]&->{u16^}
		indx := ranges[segCount]&
		
		for i : segCount
		{
			end := FromBigEndian(ends[i])
			start := FromBigEndian(starts[i])
			range := FromBigEndian(ranges[i])
			delta := FromBigEndian(deltas[i])
			// printf("tbl %i %i %i %i\n",start,end,delta,range)
			if start <= chr and chr <= end
			{
				if range == 0
				{
					cc = delta + chr
					// printf("wot %i\n",cc)
					if cc < 0
						cc += 65536
					// printf("wot %i\n",cc)
				}else{
					cc = FromBigEndian(ranges[i]&[(range div 2) + (chr - start)])
					// printf("wut %i\n",cc)
				}
			}
		}

		return cc
	}
	OpenFontReadCoord := !(float^ arr,u8^& iter, u8[] flags, int sizeBit, int skipBit,u16[] cntrs) -> void
	{
		cPos := int
	
		for flg,i : flags
		{
			is8 := (flg and_b sizeBit) != 0
			isSkip := (flg and_b skipBit) != 0
	
			val := int
			if is8 {
				val = iter^->{u8}
				if not isSkip
					val = -val
				cPos += val
				iter = iter[1]&
			}else{
				if isSkip
				{
				}else{
					val = FromBigEndian(iter->{s16^}^)
					iter = iter[2]&
					cPos += val
				}
			}

			arr[i*2] = cPos
		}
	}

}
