
OpenFont := class
{
	charToGlyph := AVLMap.{int,OFGlyph^}
}

OFGlyph := class
{
	onCurve := bool[]
	pos := vec2f[]
	cntrs := u16[]
}


NewOpenFont := !(Blob^ blb,Image^ img) -> OpenFont^
{
	result = new OpenFont

	loader := OpenFontLoader
	loader.Load(blb,img)

}

OpenFontLoader := class
{
	glyphs := OFGlyph[int]

	glyf := OpenTypeGlyf^
	head := OpenTypeHead^
	maxp := OpenTypeMaxP^
	cmap := void^
	loca := void^

	fmt4 := OpenTypeFormat4^

	Load := !(Blob^ blb,Image^ img) -> void
	{
		ptr := blb.GetPointer()->{u8^}

		hdr := ptr->{OpenTypeHeader^}

		printf("ver %i\n",FromBigEndian(hdr.numTables))

		itr := hdr[1]&->{OpenTypeTableHeader^}

		for i : FromBigEndian(hdr.numTables)
		{
			spn :=  StringSpan(itr[i].tag[0]&->{char^},4)
			// printf("table %s\n",spn)

			if spn == "glyf"
				glyf = ptr[FromBigEndian(itr[i].offset)]&->{OpenTypeGlyf^}
			if spn == "head"
				head = ptr[FromBigEndian(itr[i].offset)]&->{OpenTypeHead^}
			if spn == "maxp"
				maxp = ptr[FromBigEndian(itr[i].offset)]&->{OpenTypeMaxP^}
			if spn == "loca"
				loca = ptr[FromBigEndian(itr[i].offset)]&
			if spn == "cmap"
				cmap = ptr[FromBigEndian(itr[i].offset)]&
		}

		printf("num of glyphs %i\n",FromBigEndian(maxp.numGlyphs))


		cmapCount := FromBigEndian(cmap->{u16^}[1])
		printf("cmap count %i\n",cmapCount)
		cmapTables := cmap->{u16^}[2]&->{OpenTypeCMapTable^}
		for i : cmapCount
		{
			plat := FromBigEndian(cmapTables[i].platformID)
			enc := FromBigEndian(cmapTables[i].encodingID)
			offst := FromBigEndian(cmapTables[i].offset) 
			printf("Table %i %i\n",plat,enc)

			if plat == 0 and enc == 3
			{
				fmt := cmap->{u8^}[offst]&
				printf("format %i\n",FromBigEndian(fmt->{u16^}^))
				d := fmt->{OpenTypeFormat4^}
				fmt4 = d
			}
		}

		per := FromBigEndian(head.unitsPerEm)

		pixelSize := 400

		offset3 := vec2f
		offset3.x = 60
		offset3.y = 60

		testChar := 'R'
		printf("hey %i\n",testChar)

		for c : ![testChar]
		{
			id := GetCharId(c)

			printf("char id %i\n",id)

			glp := GetGlyphById(id)

			cntrVec := ref glp.cntrs
			pos := ref glp.pos
			onCurve := ref glp.onCurve

			
			tmp := hv_malloc(pixelSize*pixelSize)->{u8^}

			// for i : pixelSize*pixelSize
			// 	tmp[i] = (RandInt(0..255) and_b 1) != 0

			startIndex := 0
			for cntr : cntrVec
			{
				crv := bool[]
				ps := vec2f[]

				for i : startIndex..cntr
				{
					ps.Push(pos[i])
					crv.Push(onCurve[i])
				}
				ps.Push(pos[startIndex])
				crv.Push(onCurve[startIndex])

				startIndex = cntr + 1

				// for i : (ps.Size() - 1)
				// {
				// 	img.DrawLine(ps[i],ps[i+1],Color("blue"))
				// }

				// printf("cntr\n")
				// printf("curves %i\n",crv[^])
				dist := 1
				prevPos := ps[0]
				i := 1
				color := Color("red")

				scl := vec2f(pixelSize) / per

				prevPixelX := -1
				prevPixelY := -1
				prevIsLine := bool

				drawBezier := (vec2f x, vec2f y, vec2f z) ==>
				{
					fillVal := x.y < z.y ?: 1 : 2

					x *= scl
					y *= scl
					z *= scl

					if prevIsLine
					{
						tmp[prevPixelX + prevPixelY*pixelSize] = fillVal
					}

					pres := 360
					for i : 0..pres
					{
						proc := i / pres
						anti := 1.0 - proc

						t1 := x*anti + y*proc
						t2 := y*anti + z*proc

						point := t1*anti + t2*proc

						pId := point.x->{int} + point.y->{int}*pixelSize

						pointX := point.x->{int}
						pointY := point.y->{int}

						tmp[pId] = fillVal
					}
					prevIsLine = x.y->{int} == z.y->{int}
					prevPixelX = z.x
					prevPixelY = z.y
				}
				drawLine := (vec2f x, vec2f y) ==> 
				{
					fillVal := x.y < y.y ?: 1 : 2

					x *= scl
					y *= scl

					pres := 360
					for i : 0..pres
					{
						proc := i / pres
						anti := 1.0 - proc

						point := x*anti + y*proc

						pId := point.x->{int} + point.y->{int}*pixelSize

						pointX := point.x->{int}
						pointY := point.y->{int}

						tmp[pId] = fillVal
					}
					prevIsLine = true
					prevPixelX = y.x
					prevPixelY = y.y
					
				}

				while i < ps.Size()
				{
					if crv[i]
					{
						if dist == 1
						{
							// img.DrawLine(prevPos,ps[i],color)
							drawLine(prevPos,ps[i])
						}else{
							assert(dist == 2)
							// img.DrawBezier(prevPos,ps[i-1],ps[i],color)
							drawBezier(prevPos,ps[i-1],ps[i])
						}
						dist = 1
						prevPos = ps[i]
					}else{
						if crv[i-1]
						{
							dist += 1
							//skip for now
						}else{
							mdl := (ps[i] + ps[i-1])*0.5
							// img.DrawBezier(prevPos,ps[i-1],mdl,color)
							drawBezier(prevPos,ps[i-1],mdl)
							dist = 2
							prevPos = mdl
						}
					}
					i += 1
				}
			}

			for ln : pixelSize
			{
				prevIsSet := false
				j := 0
				while j < (pixelSize - 1)
				{
					id := ln*pixelSize + j

					if tmp[id] == 1
					{
						j += 1
						while j < pixelSize and tmp[ln*pixelSize + j] != 2
						{
							tmp[ln*pixelSize + j] = 3
							j += 1
						}
					}else{
						j += 1
					}
				}
			}

			st := img.GetStride()
			for i : pixelSize
			{
				for j : pixelSize
				{
					if tmp[j*pixelSize + i] != 0
					{
						col := Color
						switch tmp[j*pixelSize + i]
						{
						case 1 col = Color("green")
						case 2 col = Color("red")
						case 3 col = Color("blue")
						}
						img.SetPixel(vec2f(i+20,j+20),col)
					}
				}
			}

			offset3.x += 120
		}
	}

	GetGlyphById := !(int id) -> OFGlyph^
	{
		result = new OFGlyph

		g := OpenTypeGlyf^

		// printf("HEY %i\n",head.indexToLocFormat&->{size_t} - head->{size_t})

		if head.indexToLocFormat == 0
		{
			ofsts := loca->{u16^}
			offset := FromBigEndian(ofsts[id])*2
			printf("offset1 %i\n",offset)
			g = glyf->{u8^}[offset]&->{OpenTypeGlyf^}
		}else{
			ofsts := loca->{u32^}
			offset := FromBigEndian(ofsts[id])
			printf("offset2 %i\n",offset)
			g = glyf->{u8^}[offset]&->{OpenTypeGlyf^}
		}

		cntrCount := FromBigEndian(g.numOfContours)
		printf("min %i max %i\n",FromBigEndian(g.xMin),FromBigEndian(g.xMax))
		printf("min %i max %i\n",FromBigEndian(g.yMin),FromBigEndian(g.yMax))


		printf("countorCount %i\n",cntrCount)

		if cntrCount < 0
		{
			itr := g[1]&->{u8^}

			while true
			{
				flag := FromBigEndian(itr->{u16^}^)
				indx := FromBigEndian(itr[2]&->{u16^}^)

				itr = itr[4]&
				
				// arg1 := 0
				// arg2 := 0
				sArg1 := 0
				sArg2 := 0

				offst := vec2f

				if (flag and_b 1) != 0
				{
					// arg1 = FromBigEndian(itr[0]&->{u16^}^)
					// arg2 = FromBigEndian(itr[2]&->{u16^}^)
					sArg1 = FromBigEndian(itr[0]&->{s16^}^)
					sArg2 = FromBigEndian(itr[2]&->{s16^}^)
					itr = itr[4]&
				}else{
					// arg1 = itr[0]
					// arg2 = itr[1]
					sArg1 = itr[0]->{s8}
					sArg2 = itr[1]->{s8}
					itr = itr[2]&
				}

				// TODO use scale

				if (flag and_b 0x08) != 0 // we have a scale
				{
					itr = itr[2]&
				}else if (flag and_b 0x40) != 0 // scale x y
				{
					itr = itr[2]&
					itr = itr[2]&
				}else if (flag and_b 0x80) != 0
				{
					for 4
						itr = itr[2]&
				}

				if (flag and_b 0x02) != 0
				{
					offst.x = sArg1
					offst.y = sArg2
				}

				f := GetGlyphById(indx)

				ofst := result.pos.Size()
				result.pos.Push(f.pos[^] + offst)
				result.cntrs.Push(f.cntrs[^] + ofst)
				result.onCurve.Push(f.onCurve[^])

				if (flag and_b 0x20) == 0
					break
			}


			return void
		}

		cntrs := g[1]&->{u16^}
		cntrVec := ref result.cntrs
		cntrVec.Resize(cntrCount)


		for i : FromBigEndian(glyf.numOfContours)
		{
			printf("contour %i\n",FromBigEndian(cntrs[i]))
			cntrVec[i] = FromBigEndian(cntrs[i])
		}
		
		instructionsCount := FromBigEndian(cntrs[cntrCount])
		printf("intr count %i\n",instructionsCount)

		instr := cntrs[cntrCount + 1]&->{u8^}

		for i : instructionsCount
		{
			// printf("intr %i\n",instr[i])
		}

		numFlags := cntrVec[cntrVec.Size() - 1] + 1

		flags := u8[]
		flags.Reserve(numFlags)

		flgIter := instr[instructionsCount]&->{u8^}

		while flags.Size() < numFlags
		{
			flg := flgIter^

			cnt := 1
			if (flg and_b 0x08) != 0 
			{
				flgIter = flgIter[1]&
				cnt = flgIter^ + 1
			}

			for cnt
				flags.Push(flg)

			flgIter = flgIter[1]&
		}

		onCurve := ref result.onCurve
		onCurve.Resize(numFlags)
		for it,i : flags
			onCurve[i] = (it and_b 0x1) != 0

		printf("flagsCount %i %i\n",numFlags,flags.Size())
		// printf("flag %x\n",flags[^])

		pos := ref result.pos
		pos.Resize(numFlags)


		itr := flgIter
		OpenFontReadCoord(pos[0].x&,itr,flags,0x02,0x10,cntrVec)
		OpenFontReadCoord(pos[0].y&,itr,flags,0x04,0x20,cntrVec)

		// printf("points %f %f\n",pos[^i].x,pos[i].y)

	}
	GetCharId := !(int chr) -> int
	{
		cc := 0

		segCount := FromBigEndian(fmt4.segCountX2) div 2

		ends := fmt4[1]&->{u16^}
		starts := ends[segCount + 1]&
		deltas := starts[segCount]&->{s16^}
		ranges := deltas[segCount]&->{u16^}
		indx := ranges[segCount]&
		
		for i : segCount
		{
			end := FromBigEndian(ends[i])
			start := FromBigEndian(starts[i])
			range := FromBigEndian(ranges[i])
			delta := FromBigEndian(deltas[i])
			// printf("tbl %i %i %i %i\n",start,end,delta,range)
			if start <= chr and chr <= end
			{
				if range == 0
				{
					cc = delta + chr
					// printf("wot %i\n",cc)
					if cc < 0
						cc += 65536
					// printf("wot %i\n",cc)
				}else{
					cc = FromBigEndian(ranges[i]&[(range div 2) + (chr - start)])
					// printf("wut %i\n",cc)
				}
			}
		}

		return cc
	}
	OpenFontReadCoord := !(float^ arr,u8^& iter, u8[] flags, int sizeBit, int skipBit,u16[] cntrs) -> void
	{
		cPos := int
	
		for flg,i : flags
		{
			is8 := (flg and_b sizeBit) != 0
			isSkip := (flg and_b skipBit) != 0
	
			val := int
			if is8 {
				val = iter^->{u8}
				if not isSkip
					val = -val
				cPos += val
				iter = iter[1]&
			}else{
				if isSkip
				{
				}else{
					val = FromBigEndian(iter->{s16^}^)
					iter = iter[2]&
					cPos += val
				}
			}

			arr[i*2] = cPos
		}
	}

}
