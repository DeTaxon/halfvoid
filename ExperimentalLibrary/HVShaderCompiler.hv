
#CreateCallCommand(
	Name = "SpirvTest",
	Call = !() -> Blob^
	{
		ctx := SpirvCompiler

		mainFunc := HV.FindFunction("TestShader")
		objs := HV.GetFunctionAndHisFriends(mainFunc)


		for glb : objs.Globals
		{
			tp := glb.GetObjType()
			ctx.GetTypeId(tp?->{Type^},"Uniform",true)
			ctx.GetGlobObjId(glb)
		}

		for fnc : objs.Functions
		{
			ssa := HV.GetSSAFunc(fnc)

			ctx.GetFunctionTypeId(ssa,true)
			ctx.GetFunctionId(ssa)

			varPtr := ssa.Objects.GetPointer()
			for i : ssa.Objects.Size()
			{
				obj := ref varPtr[i]
				ctx.GetTypeId(obj.GetObjType()?)
				if obj is MCConstInteger
				{
					ctx.GetTypeId(int)
					ctx.getIntConstId(obj&->{MCConstInteger^}.GetValue())
				}
			}
			tst := PassSpirvPrettify(ssa)

			ctx.passedFuncs[ssa] = tst

			HV.PrintMCFunction(tst)

			if fnc == mainFunc
				ctx.MainFuncId = ctx.GetFunctionId(ssa)
		}

		for fnc : objs.Functions
		{
			ctx.GetFunctionIdOffset(HV.GetSSAFunc(fnc))
		}

		bodyData := new TEchoStream()

		ctx.c.SetStream(bodyData)
		for it : ctx.passedFuncs
			ctx.WriteFunction(it)

		ts := new TEchoStream()
		ctx.c.SetStream(ts)

		ctx.WriteHeader()

		ctx.GetTypeId(void)

		ctx.WriteTypes()
		ctx.WriteConsts()
		ctx.WriteGlobals()


		headerSize := ts.Size()
		ret := MakeBlob(ts.Size() + bodyData.Size())
		ts.Read(ret.GetPointer(),ts.Size())
		bodyData.Read(ret.GetPointer()->{u8^}[headerSize]&,bodyData.Size())
		return ret
	}
)

SpirvCompiler := class
{
	c := EndianStreamWrapper

	MainFuncId := int
	
	idIter := int
	getNewId := !() -> int
	{
		idIter += 1
		return idIter 
	}


	typeIds := int[Type^]
	typeUniformIds := int[Type^]

	fncTypeIds := HVB_Function^[int]
	fncIds := int[HVB_Function^]

	fncIdOffset := int[HVB_Function^]

	globIds := int[HV_Object^]

	intConsts := int[int]
	floatConsts := int[float]

	passedFuncs := AVLMap.{HVB_Function^,HVB_Function^}

	GetGlobObjId := !(HV_Object^ obj) -> int
	{
		return globIds[obj]?

		newId := getNewId()
		globIds[obj] = newId
		return newId
	}

	getIntConstId := !(int value) -> int
	{
		return intConsts[value]?

		result = getNewId()
		intConsts[value] = result
	}
	getFloatConstId := !(float value) -> int
	{
		return floatConsts[value]?

		result = getNewId()
		floatConsts[value] = result
	}

	GetFunctionId := !(HVB_Function^ fnc) -> int
	{
		return fncIds[fnc]?

		result = getNewId()
		fncIds[fnc] = result
	}

	GetFunctionTypeId := !(HVB_Function^ fnc,bool touchAll = false) -> int
	{
		r := fnc.GetFunctionType()

		if touchAll
		{
			GetTypeId(r.InputTypes[^],"Function",touchAll)
			GetTypeId(r.ReturnType,"Function",touchAll)
		}

		key := r.GetHVType()

		printf("wut %p\n",key)

		result = GetTypeId(key)
		fncTypeIds[result] = fnc
	}
	GetFunctionIdOffset := !(HVB_Function^ fnc) -> int
	{
		return fncIdOffset[fnc]?

		count := fnc.Objects.Size()

		idIter++
		result = idIter
		idIter += count - 1

		fncIdOffset[fnc] = result
	}

	GetTypeId := !(TypeId x,SpirvStorageGroup group = "Function") -> int
	{
		return this.GetTypeId(HV.GetTypeObj(x),group)
	}
	GetTypeId := !(Type^ x,SpirvStorageGroup group = "Function", bool touchAll = false) -> int
	{
		switch group
		{
		case "Uniform"
			return typeUniformIds[x]?
		case void
			return typeIds[x]?
		}

		typeGroup := HV.GetTypeGroup(x)

		if touchAll
		{
			base := HV.GetTypeBase(x)
			if base != null
				GetTypeId(base,"Function",touchAll)
			if typeGroup == "Class"
			{
				cls := HV.GetTypeClass(x)

				for i : cls.GetFieldsCount()
				{
					GetTypeId(cls.GetFieldType(i),"Function",touchAll)
				}
			}
		}
		newId := getNewId()
		switch group
		{
		case "Uniform"
			typeUniformIds[x] = newId
		case void
			typeIds[x] = newId
		}
		return newId

	}

	WriteTypes := !() -> void
	{
		rev := Type^[int]
		for it,ind : typeIds
			rev[it] = ind
		for tp,indx : rev
		{
			id := HV.GetTypeId(tp)
			typeGroup := HV.GetTypeGroup(tp)

			if id == void
			{
				c.Write32(0x00020000 + 19) // OpTypeVoid
				c.Write32(indx)
			} else if id == float or id == double {
				c.Write32(0x30000 + 22)
				c.Write32(indx)
				c.Write32(id == float ?: 32 : 64) // OpTypeFloat OpTypeDouble
			} else if tp.IsInt() {
				c.Write32(0x40000 + 21) // OpTypeInt
				c.Write32(indx)
				c.Write32(HV.GetTypeSize(tp)*8)
				c.Write32(1) // signed
			} else if typeGroup == "Function" {
				fnc := fncTypeIds[indx]
				
				r := fnc.GetFunctionType()

				cnt := 3 + r.InputTypes.Size()

				c.Write32((cnt shl 16) + 33) // OpTypeFunction
				c.Write32(indx)
				c.Write32(GetTypeId(r.ReturnType))
				for it : r.InputTypes
					c.Write32(GetTypeId(it))

			}else if typeGroup == "Pointer" {
				base := HV.GetTypeBase(tp)
				if indx == 12
					printf("yep %s\n",HV.GetTypeDebugName(base).Str())
				c.Write32(0x00040000 + 32) // OpTypePointer
				c.Write32(indx)
				c.Write32(7) // function
				c.Write32(GetTypeId(base))
			}else if typeGroup == "Vector" {
				c.Write32(0x40000 + 23)
				c.Write32(indx)
				c.Write32(GetTypeId(HV.GetTypeBase(tp)))
				c.Write32(HV.GetTypeArraySize(tp))
			}else if typeGroup == "Array" {
				base := HV.GetTypeBase(tp)
				arSize := HV.GetTypeArraySize(tp)

				if arSize == 0
				{
					c.Write32(0x30000 + 29)
					c.Write32(indx)
					c.Write32(GetTypeId(base))
				}else{
					
				}

			}else if typeGroup == "Class" {
				cls := HV.GetTypeClass(tp)

				fCount := cls.GetFieldsCount()
				
				c.Write32(((fCount + 2) shl 16) + 30) // OpTypeStruct
				c.Write32(indx)
				for i : fCount
				{
					c.Write32(GetTypeId(cls.GetFieldType(i)))
				}
				
			}else {

			}
			
		}
		for indx,tp : typeUniformIds
		{
			id := HV.GetTypeId(tp)
			typeGroup := HV.GetTypeGroup(tp)

			if typeGroup == "Pointer"
			{
				base := HV.GetTypeBase(tp)
				c.Write32(0x00040000 + 32) // OpTypePointer
				c.Write32(indx)
				c.Write32(2) // uniform
				c.Write32(GetTypeId(base))
			}
		}
	}
	WriteConsts := !() -> void
	{
		intId := this.GetTypeId(int)
		for ind,val : intConsts
		{
			c.Write32(0x40000 + 43) //OpConstant
			c.Write32(intId)
			c.Write32(ind)
			c.Write32(val)
		}

		floatId := this.GetTypeId(float)
		for ind,val : floatConsts
		{
			c.Write32(0x40000 + 43) //OpConstant
			c.Write32(floatId)
			c.Write32(ind)

			k := int
			k&->{float^}^ = val
			c.Write32(k)
		}
	}

	WriteGlobals := !() -> void
	{
		for id,obj : globIds
		{
			c.Write32(0x40000 + 59) // OpVariable
			c.Write32(GetTypeId(obj.GetObjType(),"Uniform"))
			c.Write32(id)
			c.Write32(2) // Uniform
			//c.Write32(initializer)
		}
	}

	WriteHeader := !() -> void
	{
		c.Write32(0x07230203) // magic number
		// c.Write32(0x03022307) // magic number
		c.Write32(0x00010300) //version 1.3
		c.Write32(0) // meh
		c.Write32(9999) // Bound,max id value
		c.Write32(0) // reserved

		c.Write32(0x00020000 + 17) // OpCapabilities
		c.Write32(1) // shader

		// optional extensions
		
		idIter++
		someIter := idIter
		aa := "GLSL"
		bb := ".std"
		cc := ".450"
		c.Write32(0x00060000 + 11)
		c.Write32(someIter)
		c.Write32(aa[0]&->{u32^}^)
		c.Write32(bb[0]&->{u32^}^)
		c.Write32(cc[0]&->{u32^}^)
		c.Write32(0)

		c.Write32(0x00030000 + 14) // OpMemoryModel
		c.Write32(0) // logical memory
		c.Write32(1) // GLSL450 memory model

		c.Write32(0x00050000 + 15) // OpEntryPoint
		c.Write32(5) // Vertex,TessCon,TessEv,Geo,Frag,Compute
		c.Write32(MainFuncId) // id of function

		nm := "main"
		c.Write32(nm[0]&->{u32^}^)
		c.Write32(0)

		// execution mode
		c.Write32(0x00060000 + 16)
		c.Write32(MainFuncId)
		c.Write32(17) // LocalSize
		c.Write32(1)
		c.Write32(1)
		c.Write32(1)
	}
	WriteFunction := !(HVB_Function^ fnc) -> void
	{
		// this.GetTypeId(HV.GetTypeObj(float),"Uniform")
		floatPtr := HV.GetTypeObj(float).GetPointer()
		GetTypeId(floatPtr,"Uniform")

		idFIter := GetFunctionIdOffset(fnc) + 1

		c.Write32(0x00050000 + 54) //OpFunction
		c.Write32(GetTypeId(void)) // result type
		// c.Write32(GetFunctionId(fnc)) // result object
		c.Write32(MainFuncId)
		c.Write32(0) // ???
		c.Write32(GetFunctionTypeId(fnc)) // function type
	
		c.Write32(0x0020000 + 248) // OpLabel
		c.Write32(idFIter++)

		cPtr := fnc.Lines.GetPointer()
		oPtr := fnc.Objects.GetPointer()

		ids := int[int]

		toLocalId := (int x) ==> int
		{
			ob := ref fnc.Objects[x]

			if ob is MCConstFloat
			{
				return getFloatConstId(ob.GetValue())
			}
			return ids[x]?

			idIter++
			result = idIter
			ids[x] = result
		}

		for obj,ind : fnc.Objects
		{
			if obj& is MCVariable
			{
				tpId := GetTypeId(obj.GetObjType().GetPointer())

				resId := toLocalId(ind)

				c.Write32(0x00040000 + 59)
				c.Write32(tpId)
				c.Write32(resId)
				c.Write32(7) //function
			}
		}

		i := 0
		linesCount := fnc.Lines.Size()
		while i < linesCount
		{
			line := cPtr[i]

			{// AccessChain
				
				chainIndexes := HybridQueue.{int,20}

				k := i
				startIndex := 0
				resIndex := 0

				while k < linesCount
				{
					ln := cPtr[k]
					if ln.opcode == "cast" and cPtr[k+1].opcode == "get_array_elem_ptr" {

						//TODO specific casts
						// obj[0] to obj^
						// vec4f to float^
						chainIndexes.Push(this.getIntConstId(0))
						resIndex = cPtr[k+1].var1
						k += 2
					}else if ln.opcode == "get_array_elem_ptr" {
						if oPtr[ln.var3] is MCConstInteger
						{
							chainIndexes.Push(this.getIntConstId(oPtr[ln.var3]&->{MCConstInteger^}.GetValue()))
						}else{
							chainIndexes.Push(ln.var3 + idFIter)
						}
						if k == i
						{
							if oPtr[ln.var2] is MCGlobalVariable
							{
								startIndex = this.GetGlobObjId(oPtr[ln.var2]&->{MCGlobalVariable^}.GetGlobalVariable())
							}else{
								startIndex = ln.var2
							}
						}
						resIndex = ln.var1
					}else if ln.opcode == "get_field_ptr" {
						if oPtr[ln.var3] is MCConstInteger
						{
							chainIndexes.Push(this.getIntConstId(oPtr[ln.var3]&->{MCConstInteger^}.GetValue()))
						}else{
							chainIndexes.Push(ln.var3 + idFIter)
						}
						if k == i
							startIndex = ln.var2
						resIndex = ln.var1
					}else{
						break
					}
					k += 1
				}

				if k != i
				{
					resObj := toLocalId(resIndex)

					resTypeId := GetTypeId(oPtr[resIndex].GetObjType(),"Uniform") //TODO determine group

					indCount := (chainIndexes.Size() + 4) shl 16
					c.Write32(indCount + 65)
					c.Write32(resTypeId)
					c.Write32(resObj)
					c.Write32(startIndex)

					for it,i : chainIndexes
					{
						c.Write32(it)
					}

					i = k - 1
					continue
				}

			}

			switch line.opcode
			{
			case "load"
				c.Write32(0x0040000 + 61) // OpLoad
				c.Write32(GetTypeId(oPtr[line.var1].GetObjType()))
				c.Write32(toLocalId(line.var1))
				c.Write32(toLocalId(line.var2))
			case "store"
				c.Write32(0x0030000 + 62) // OpStore
				c.Write32(toLocalId(line.var1))
				c.Write32(toLocalId(line.var2))
			case "add"
				c.Write32(0x0050000 + 129) // OpFAdd
				c.Write32(GetTypeId(oPtr[line.var1].GetObjType()))
				c.Write32(toLocalId(line.var1))
				c.Write32(toLocalId(line.var2))
				c.Write32(toLocalId(line.var3))
			}

			
			i += 1
		}

		//Test
		// c.Write32(0x0030000 + 62) //OpStore
		// c.Write32(resObj)
		// c.Write32(getFloatConstId(0.0))

		c.Write32(0x0010000 + 253) // OpReturn
		c.Write32(0x0010000 + 56) //OpFunctionEnd
	}
}

SpirvStorageGroup := enum
{
	"Function",
	"Uniform"
}


PartType := class
{
	pos := vec2f
	vel := vec2f
}

Unifrm := class
{
	particles := PartType[0]
}

uni := Unifrm^

TestShader := !() -> void
{
	i := 3
	uni.particles[0].pos.x += 0.1
}
