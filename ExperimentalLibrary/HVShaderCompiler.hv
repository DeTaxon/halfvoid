
#CreateCallCommand(
	Name = "SpirvTest",
	Call = !() -> Blob^
	{

		ctx := SpirvCompiler
		objs := HV.GetFunctionAndHisFriends(HV.FindFunction("TestShader"))

		fTypeId := 0
		for fnc : objs.Functions
		{
			ssa := HV.GetSSAFunc(fnc)

			fTypeId = ctx.GetFunctionTypeId(ssa)
			// ssa.Print()
		}
		ts := new TEchoStream()

		ctx.c.SetStream(ts)

		c := EndianStreamWrapper(ts)
		// c.SetBigEndian()
		c.SetLittleEndian()

		ctx.WriteHeader()

		ctx.GetTypeId(void)

		ctx.WriteTypes()

		for it : objs.Functions
			ctx.WriteFunction(HV.GetSSAFunc(it))

		ret := MakeBlob(ts.Size())
		ts.Read(ret.GetPointer(),ts.Size())
		return ret
	}
)

SpirvCompiler := class
{
	c := EndianStreamWrapper

	idIter := int

	typeIds := int[HV_Object^]

	fncTypeIds := HVB_Function^[int]

	GetFunctionTypeId := !(HVB_Function^ fnc) -> int
	{
		r := fnc.GetFunctionType()

		key := r.GetHVType()

		result = GetTypeId(key)
		fncTypeIds[result] = fnc

	}

	GetTypeId := !(TypeId x) -> int
	{
		return this.GetTypeId(HV.GetTypeObj(x))
	}
	GetTypeId := !(HV_Object^ x) -> int
	{
		if typeIds.Contain(x)
			return typeIds[x]
		idIter++
		newId := idIter
		typeIds[x] = newId
		return newId
	}

	WriteTypes := !() -> void
	{
		for indx,tp : typeIds
		{
			id := HV.GetTypeId(tp)
			typeGroup := HV.GetTypeGroup(tp)

			if id == void
			{
				c.Write32(0x00020000 + 19) // OpTypeVoid
				c.Write32(indx)
			} else if typeGroup == "Function" {
				fnc := fncTypeIds[indx]
				
				r := fnc.GetFunctionType()

				cnt := 3 + r.InputTypes.Size()

				c.Write32((cnt shl 16) + 33) // OpTypeFunction
				c.Write32(indx)
				c.Write32(GetTypeId(r.ReturnType))
				for it : r.InputTypes
					c.Write32(GetTypeId(it))

				
			}else {

			}
			
		}
	}

	WriteHeader := !() -> void
	{
		c.Write32(0x07230203) // magic number
		// c.Write32(0x03022307) // magic number
		c.Write32(0x00010300) //version 1.3
		c.Write32(0) // meh
		c.Write32(9999) // Bound,max id value
		c.Write32(0) // reserved

		c.Write32(0x00020000 + 17) // OpCapabilities
		c.Write32(1) // shader

		c.Write32(0x00030000 + 14) // OpMemoryModel
		c.Write32(0) // logical memory
		c.Write32(1) // GLSL450 memory model

		c.Write32(0x00050000 + 15) // OpEntryPoint
		c.Write32(5) // Vertex,TessCon,TessEv,Geo,Frag,Compute
		c.Write32(404) // id of function

		nm := "main"
		c.Write32(nm[0]&->{u32^}^)
		c.Write32(0)

		// execution mode
		c.Write32(0x00060000 + 16)
		c.Write32(404)
		c.Write32(17) // LocalSize
		c.Write32(1)
		c.Write32(1)
		c.Write32(1)
	}
	WriteFunction := !(HVB_Function^ fnc) -> void
	{
		c.Write32(0x00050000 + 54) //OpFunction
		c.Write32(GetTypeId(void)) // result type
		c.Write32(404) // result object
		c.Write32(0) // ???
		c.Write32(GetFunctionTypeId(fnc)) // function type
	
		c.Write32(0x0020000 + 248) // OpLabel
		c.Write32(1001)
	
		c.Write32(0x0010000 + 253) // OpReturn
		c.Write32(0x0010000 + 56) //OpFunctionEnd
	}
}


PartType := class
{
	pos := vec2f
	vel := vec2f
}

particles := PartType^

TestShader := !() -> void
{
	particles[0].pos.x += 0.1
}
