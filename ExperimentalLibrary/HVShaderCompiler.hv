
#CreateCallCommand(
	Name = "SpirvTest",
	Call = !() -> Blob^
	{
		ts := new TEchoStream()

		ctx := SpirvCompiler
		ctx.c.SetStream(ts)

		c := EndianStreamWrapper(ts)
		// c.SetBigEndian()
		c.SetLittleEndian()

		ctx.WriteHeader()

		ctx.GetTypeId(void)

		ctx.WriteTypes()


		c.Write32(0x00030000 + 33) // OpTypeFunction
		c.Write32(406)
		c.Write32(ctx.GetTypeId(void))

		objs := HV.GetFunctionAndHisFriends(HV.FindFunction("TestShader"))

		ctx.WriteFunction(null)

		ret := MakeBlob(ts.Size())
		ts.Read(ret.GetPointer(),ts.Size())
		return ret
	}
)

SpirvCompiler := class
{
	c := EndianStreamWrapper

	idIter := int

	typeIds := int[HV_Object^]

	GetTypeId := !(TypeId x) -> int
	{
		return this.GetTypeId(HV.GetTypeObj(x))
	}
	GetTypeId := !(HV_Object^ x) -> int
	{
		if typeIds.Contain(x)
			return typeIds[x]
		idIter++
		newId := idIter
		typeIds[x] = newId
		return newId
	}

	WriteTypes := !() -> void
	{
		for indx,tp : typeIds
		{
			id := HV.GetTypeId(tp)

			if id == void
			{
				c.Write32(0x00020000 + 19) // OpTypeVoid
				c.Write32(indx)
			}
			
		}
	}

	WriteHeader := !() -> void
	{
		c.Write32(0x07230203) // magic number
		// c.Write32(0x03022307) // magic number
		c.Write32(0x00010300) //version 1.3
		c.Write32(0) // meh
		c.Write32(9999) // Bound,max id value
		c.Write32(0) // reserved

		c.Write32(0x00020000 + 17) // OpCapabilities
		c.Write32(1) // shader

		c.Write32(0x00030000 + 14) // OpMemoryModel
		c.Write32(0) // logical memory
		c.Write32(1) // GLSL450 memory model

		c.Write32(0x00050000 + 15) // OpEntryPoint
		c.Write32(5) // Vertex,TessCon,TessEv,Geo,Frag,Compute
		c.Write32(404) // id of function

		nm := "main"
		c.Write32(nm[0]&->{u32^}^)
		c.Write32(0)

		// execution mode
		c.Write32(0x00060000 + 16)
		c.Write32(404)
		c.Write32(17) // LocalSize
		c.Write32(1)
		c.Write32(1)
		c.Write32(1)
	}
	WriteFunction := !(HV_Object^ fnc) -> void
	{
		c.Write32(0x00050000 + 54) //OpFunction
		c.Write32(GetTypeId(HV.GetType("void"))) // result type
		c.Write32(404) // result object
		c.Write32(0) // ???
		c.Write32(406) // function type
	
		c.Write32(0x0020000 + 248) // OpLabel
		c.Write32(1001)
	
		c.Write32(0x0010000 + 253) // OpReturn
		c.Write32(0x0010000 + 56) //OpFunctionEnd
	}
}


PartType := class
{
	pos := vec2f
	vel := vec2f
}

particles := PartType^

TestShader := !() -> void
{
	particles[0].pos.x += 0.1
}
