
#CreateCallCommand(
	Name = "SpirvTest",
	Call = !() -> Blob^
	{
		ctx := SpirvCompiler

		mainFunc := HV.FindFunction("TestShader")
		objs := HV.GetFunctionAndHisFriends(mainFunc)


		for glb : objs.Globals
		{
			tp := glb.GetObjType()
			ctx.GetTypeId(tp?,"Uniform",true)
			ctx.GetGlobObjId(glb)
		}

		for fnc : objs.Functions
		{
			ssa := HV.GetSSAFunc(fnc)

			ctx.GetFunctionTypeId(ssa,true)
			ctx.GetFunctionId(ssa)

			printf("test ssa %p\n",ssa.Objects)
			varPtr := ssa.Objects.GetPointer()
			for i : ssa.Objects.Size()
			{
				obj := ref varPtr[i]
				ctx.GetTypeId(obj.GetObjType()?)
				if obj is MCConstInteger
				{
					ctx.GetTypeId(int)
					ctx.getIntConstId(obj&->{MCConstInteger^}.GetValue())
				}
			}
			tst := PassSpirvPrettify(ssa)

			HV.PrintMCFunction(ssa)
			HV.PrintMCFunction(tst)

			if fnc == mainFunc
				ctx.MainFuncId = ctx.GetFunctionId(ssa)
		}

		for fnc : objs.Functions
		{
			ctx.GetFunctionIdOffset(HV.GetSSAFunc(fnc))

			
		}

		ts := new TEchoStream()

		ctx.c.SetStream(ts)

		c := EndianStreamWrapper(ts)
		// c.SetBigEndian()
		c.SetLittleEndian()

		ctx.WriteHeader()

		ctx.GetTypeId(void)

		ctx.WriteTypes()
		ctx.WriteConsts()
		ctx.WriteGlobals()

		for it : objs.Functions
			ctx.WriteFunction(HV.GetSSAFunc(it))

		ret := MakeBlob(ts.Size())
		ts.Read(ret.GetPointer(),ts.Size())
		return ret
	}
)

SpirvCompiler := class
{
	c := EndianStreamWrapper

	MainFuncId := int
	
	idIter := int
	getNewId := !() -> int
	{
		idIter += 1
		return idIter 
	}


	typeIds := int[HV_Object^]
	typeUniformIds := int[HV_Object^]

	fncTypeIds := HVB_Function^[int]
	fncIds := int[HVB_Function^]

	fncIdOffset := int[HVB_Function^]

	globIds := int[HV_Object^]

	intConsts := int[int]

	GetGlobObjId := !(HV_Object^ obj) -> int
	{
		return globIds[obj]?

		newId := getNewId()
		globIds[obj] = newId
		return newId
	}

	getIntConstId := !(int value) -> int
	{
		return intConsts[value]?

		result = getNewId()
		intConsts[value] = result
	}

	GetFunctionId := !(HVB_Function^ fnc) -> int
	{
		return fncIds[fnc]?

		result = getNewId()
		fncIds[fnc] = result
	}

	GetFunctionTypeId := !(HVB_Function^ fnc,bool touchAll = false) -> int
	{
		r := fnc.GetFunctionType()

		if touchAll
		{
			GetTypeId(r.InputTypes[^],"Function",touchAll)
			GetTypeId(r.ReturnType,"Function",touchAll)
		}

		key := r.GetHVType()

		result = GetTypeId(key)
		fncTypeIds[result] = fnc
	}
	GetFunctionIdOffset := !(HVB_Function^ fnc) -> int
	{
		return fncIdOffset[fnc]?

		count := fnc.Objects.Size()

		idIter++
		result = idIter
		idIter += count - 1

		fncIdOffset[fnc] = result
	}

	GetTypeId := !(TypeId x,SpirvStorageGroup group = "Function") -> int
	{
		return this.GetTypeId(HV.GetTypeObj(x),group)
	}
	GetTypeId := !(HV_Object^ x,SpirvStorageGroup group = "Function", bool touchAll = false) -> int
	{
		switch group
		{
		case "Uniform"
			return typeUniformIds[x]?
		case void
			return typeIds[x]?
		}

		typeGroup := HV.GetTypeGroup(x)

		if touchAll
		{
			base := HV.GetTypeBase(x)
			if base != null
				GetTypeId(base,"Function",touchAll)
			if typeGroup == "Class"
			{
				cls := HV.GetTypeClass(x)

				for i : cls.GetFieldsCount()
				{
					GetTypeId(cls.GetFieldType(i),"Function",touchAll)
				}
			}
		}
		newId := getNewId()
		switch group
		{
		case "Uniform"
			typeUniformIds[x] = newId
		case void
			typeIds[x] = newId
		}
		return newId

	}

	WriteTypes := !() -> void
	{
		rev := HV_Object^[int]
		for it,ind : typeIds
			rev[it] = ind
		for tp,indx : rev
		{
			id := HV.GetTypeId(tp)
			typeGroup := HV.GetTypeGroup(tp)

			if id == void
			{
				c.Write32(0x00020000 + 19) // OpTypeVoid
				c.Write32(indx)
			} else if id == float or id == double {
				c.Write32(0x30000 + 22)
				c.Write32(indx)
				c.Write32(id == float ?: 32 : 64) // OpTypeFloat OpTypeDouble
			} else if id == int {
				c.Write32(0x40000 + 21) // OpTypeInt
				c.Write32(indx)
				c.Write32(HV.GetTypeSize(tp)*8)
				c.Write32(1) // signed
			} else if typeGroup == "Function" {
				fnc := fncTypeIds[indx]
				
				r := fnc.GetFunctionType()

				cnt := 3 + r.InputTypes.Size()

				c.Write32((cnt shl 16) + 33) // OpTypeFunction
				c.Write32(indx)
				c.Write32(GetTypeId(r.ReturnType))
				for it : r.InputTypes
					c.Write32(GetTypeId(it))

			}else if typeGroup == "Pointer" {
			}else if typeGroup == "Vector" {
				c.Write32(0x40000 + 23)
				c.Write32(indx)
				c.Write32(GetTypeId(HV.GetTypeBase(tp)))
				c.Write32(HV.GetTypeArraySize(tp))
			}else if typeGroup == "Array" {
				base := HV.GetTypeBase(tp)
				arSize := HV.GetTypeArraySize(tp)

				if arSize == 0
				{
					c.Write32(0x30000 + 29)
					c.Write32(indx)
					c.Write32(GetTypeId(base))
				}else{
					
				}

			}else if typeGroup == "Class" {
				cls := HV.GetTypeClass(tp)

				fCount := cls.GetFieldsCount()
				
				c.Write32(((fCount + 2) shl 16) + 30) // OpTypeStruct
				c.Write32(indx)
				for i : fCount
				{
					c.Write32(GetTypeId(cls.GetFieldType(i)))
				}
				
			}else {

			}
			
		}
		for indx,tp : typeUniformIds
		{
			id := HV.GetTypeId(tp)
			typeGroup := HV.GetTypeGroup(tp)

			if typeGroup == "Pointer"
			{
				base := HV.GetTypeBase(tp)
				c.Write32(0x00040000 + 32) // OpTypePointer
				c.Write32(indx)
				c.Write32(2) // uniform
				c.Write32(GetTypeId(base))
			}
		}
	}
	WriteConsts := !() -> void
	{
		intId := this.GetTypeId(int)
		for ind,val : intConsts
		{
			c.Write32(0x40000 + 43) //OpConstant
			c.Write32(intId)
			c.Write32(ind)
			c.Write32(val)
		}
	}

	WriteGlobals := !() -> void
	{
		for id,obj : globIds
		{
			c.Write32(0x40000 + 59) // OpVariable
			c.Write32(GetTypeId(obj.GetObjType(),"Uniform"))
			c.Write32(id)
			c.Write32(2) // Uniform
			//c.Write32(initializer)
		}
	}

	WriteHeader := !() -> void
	{
		c.Write32(0x07230203) // magic number
		// c.Write32(0x03022307) // magic number
		c.Write32(0x00010300) //version 1.3
		c.Write32(0) // meh
		c.Write32(9999) // Bound,max id value
		c.Write32(0) // reserved

		c.Write32(0x00020000 + 17) // OpCapabilities
		c.Write32(1) // shader

		c.Write32(0x00030000 + 14) // OpMemoryModel
		c.Write32(0) // logical memory
		c.Write32(1) // GLSL450 memory model

		c.Write32(0x00050000 + 15) // OpEntryPoint
		c.Write32(5) // Vertex,TessCon,TessEv,Geo,Frag,Compute
		c.Write32(MainFuncId) // id of function

		nm := "main"
		c.Write32(nm[0]&->{u32^}^)
		c.Write32(0)

		// execution mode
		c.Write32(0x00060000 + 16)
		c.Write32(MainFuncId)
		c.Write32(17) // LocalSize
		c.Write32(1)
		c.Write32(1)
		c.Write32(1)
	}
	WriteFunction := !(HVB_Function^ fnc) -> void
	{
		idFIter := GetFunctionIdOffset(fnc) + 1

		c.Write32(0x00050000 + 54) //OpFunction
		c.Write32(GetTypeId(void)) // result type
		c.Write32(GetFunctionId(fnc)) // result object
		c.Write32(0) // ???
		c.Write32(GetFunctionTypeId(fnc)) // function type
	
		c.Write32(0x0020000 + 248) // OpLabel
		c.Write32(idFIter++)

		cPtr := fnc.Lines.GetPointer()
		oPtr := fnc.Objects.GetPointer()
		for i : fnc.Lines.Size()
		{
			line := cPtr[i]
			
			if line.opcode == "mov"
			{
				o1 := ref oPtr[line.var1]
				o2 := ref oPtr[line.var2]

				if o1& is MCConstValue and o2 is MCGlobalVariable
				{
					v2 := GetGlobObjId(o2&->{MCGlobalVariable^}.GetGlobalVariable())

					c.Write32(0x40000 + 65)
					c.Write32(GetTypeId(o1.GetObjType(),"Uniform"))
					c.Write32(line.var1 + idFIter)
					c.Write32(v2)
				}
			}else if line.opcode == "get_array_elem_ptr" and i == 4
			{
				o1 := ref oPtr[line.var1]
				o2 := ref oPtr[line.var2]
				o3 := ref oPtr[line.var3]

					c.Write32(0x50000 + 67)
					c.Write32(GetTypeId(o1.GetObjType(),"Uniform"))
					c.Write32(line.var1 + idFIter)
					c.Write32(line.var2 + idFIter)
					c.Write32(getIntConstId(o3&->{MCConstInteger^}.GetValue()))
			}
			
		}

		c.Write32(0x0010000 + 253) // OpReturn
		c.Write32(0x0010000 + 56) //OpFunctionEnd
	}
}

SpirvStorageGroup := enum
{
	"Function",
	"Uniform"
}


PartType := class
{
	pos := vec2f
	vel := vec2f
}

Unifrm := class
{
	particles := PartType[0]
}

uni := Unifrm^

TestShader := !() -> void
{
	uni.particles[0].pos.x += 0.1
}
