
#mark("jit_pass") Func1 := !() -> void
{
	printf("hello\n")
}
#mark("jit_pass") @once @twice Func245 := !() -> void
{
	printf("world\n")
}

"@twice func" := !(args...).{@T} -> void 
{
	T(args...)
	T(args...)
}

getType := !(int callSize) .{@T} -> void 
{
	printf("%2i group %s\n",callSize,T->Group)
	switch T->Group
	{
		case "prime"
			printf("%2i prime\n",callSize)
		case "array"
		case "func"
		if T->Group == "func"
		{
			printf("%2i func\n",callSize)
			for par : T->Params
			{
				printf("%2i param\n",callSize)
				getType(callSize+1).{par}
			}
		}
		case "lambda"
		case "pointer"
	}

	#prolog
	{
		getType([t | T] , [b | B]) :- t = getType(b)
		getType(T,R) :- T = int, R = GTypeInt
		getType(T,R) :- T = float, R = GTypeFloat
		getType(T,R) :- T->Type = "prime", R = GetType(T->RawName)
		getType(T,R) :- T->Type = "array", getType(T->Base,B),  R = B.GetArray(T->Len)
		getType(T,R) :- T->Type = "func",  getType(T,B),getType(T->ResultType,RT),  R = GetFuncType(B,RT)
		getType(T,R) :- T->Type = "lambda",  getType(T,B),getType(T->ResultType,RT),  R = GetFuncType(B,RT)
	}
	getType(T,result)

	////#prolog
	////{
	////	TestArgs(Inp,Outp,Result) := 
	////}
	//result = GetFuncType(![GTypeInt],GTypeVoid)
}

"@twice call" := !(@LType lambd) -> LType->ResultType
{
	lambd()
	lambd()
}

f1 := !() -> void
{
	@once @twice printf("test \n")
}
main := !(int argc, char^^ argv) -> int
{
	TFullInit()
	//f1()
	//f1()
	Func245()
	Func245()
	Func245()
}

