
main := !(char^[] args) -> int
{
	RunFunc()
}


RunFunc := !() -> void
{
	// tst()
	// makeSpirv()
	x := 0
	tst(x)
	printf("hey %i\n",x)
}

tst := !(int& x) -> void
{
	x = 12
}

makeSpirv := !() -> void
{
	ts := new TFile("tst.comp","wr")
	c := #SpirvTest()
	ts.Write(c.GetPointer(),c.Size())
	ts.Close()
}

AllcFree := class
{
	left := AllcFree^
	right := AllcFree^
	up := AllcFree^ 
	balance := s8

	size := int
}
Allc := class extends IAllocator
{
	startPage := PageMemory

	AllocMem := virtual !(int size, bool dirty = false) -> void^
	{
		if startPage.memPointer == null
		{
			startPage.Create(8*1024*1024)
		}
	}
	FreeMem := virtual !(void^ mem) -> void
	{
	}

	GetPointerInfo := !(void^ ptr) -> void
	{
		// actual pointer
		// typeid
		//
	}
}

tst := !() -> int {
	nums := 10_000
	// nums = 10

	bigNums := nums*3
	values := malloc(bigNums*4)->{int^}

	resultPtr := malloc(nums + 1)->{u8^}
	memset(resultPtr,0,nums + 1)
	//resultPtrPtr[nums] = 0

	i := 0
	while i < bigNums
	{
		values[i] = 2
		i += 1
	}
	i = 0
	while i < nums
	{
		// printf("step %10i %10i\n",i, i * 10000 div nums)
		j := 0
		while j < bigNums
		{
			values[j] *= 10
			j += 1
		}
		j = bigNums - 1
		while j >= 1
		{
			thisMul := j
			thisDiv := 2*j + 1


			carry := (values[j] div thisDiv)*thisMul
			modul := values[j] mod thisDiv
			values[j] = modul
			j -= 1
			values[j] += carry
		}
		num := values[0] div 10
		values[0] = values[0] mod 10

		c := 0
		while num != 0
		{
			resultPtr[i + c] += num
			if resultPtr[i + c] >= 10
			{
				resultPtr[i + c] = resultPtr[i + c] mod 10
				num = 1
			}else{
				num = 0
			}
			c -= 1
		}
		i += 1
	}

	i = 0
	while i < nums
	{
		resultPtr[i] += '0'
		i += 1
	}
	printf("resultPtr %s\n",resultPtr)
}

//TODO recursive #Mark("JIT") for classes
//TODO there is some trickary with GTypeStr in PassRemoveReferences
//TODO x86, make passing vec4f abi compatable, windows, linux
//TODO named input + template, !(@T^ x = null)
//TODO emit error if named input provided but not used
//TODO class functions inherit virtual property, and default values
//TODO lazy class and fake fields
//TODO lazy class in hotload
//TODO it is REALY painfull, if .x called in child class we must call in base class and rebuild this class
//TODO allow !(ref int x) , in functions and function types, lambdas


//ThisIsError := !() -> void
//{
//	c,y := ManyRes()
//}
//ManyRes := !() -> int, GCObject^ //TODO GCObject is incorrect type, emit error
//{
//	return 5, new TGCObject
//}



JavaCompile := !(HVB_FunctionEditor^ funcToCompile) -> void
{
	//printf("yep %i %i\n",funcToCompile.GetVariablesCount(), funcToCompile.GetCodeLinesCount())

	//for i : funcToCompile.GetCodeLinesCount()
	//{
	//	line := funcToCompile.GetLine(i)
	//	printf("line %s %i %i %i %i\n",line.opcode.ToCStr(),line.var1,line.var2,line.var3,line.var4)
	//}

	ResFile := new ZipFile
	ResFile.AnalizeFile("test.jar")

	jClass := JavaClass("test")
	jClass.CreateMethod("main")
	
	echo := TEchoStream
	jClass.Write(echo)
	blb := echo.GetBlob()

	ResFile.WriteFile("test.class",blb)
	ResFile.Flush()

	fl := RawFileStream("test.class","wb")
	fl.Write(blb.GetPointer(),blb.Size())

	printf("done\n")
}
JavaMain := !() -> void
{

}

//
//SwapnWork(() ==>{
//	thisTask = SpawnTask(() ==> {
//		interpretetion fails here
//		something to do with thisTask being captured
//	})
//})
//
//
//
//
//

//for i : ![1,2,3] TODO, this array is not affected by reload
//{
//	
//}





//Zip file
//crc32
//deflate
//zip -v check
//if file already exists
//throw exceptions when file cannot be created, no space on disk, incorrect file format

//TODO
//@cache function, @once function/call
//decorator func pass constants?
//default initializer for growing class, and const value as global const
//field becomes static if it is not inside class
//zero size class optimizations
//x := field 10  non types not working
//Module Vulkan uses Normal Class and usese new API
