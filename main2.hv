
//TODO i need some way to profile fiber usage and way to find abandoned hatches
//TODO capturing vec2f crash program, maybe value are not aligned to 16 byte


#CreateCallCommand(
	Name = "Test",
	CacheOn = "Inputs"
	Call = !(File^ fil) -> Blob^
	{
		ret :=  fil.GetBlob()
		return ret
	}
	Exchange = !(Blob^ bl) -> char^
	{
		return bl.GetPointer()
	}
)

#Module(
	x := int

	loaded := bool
	LoadXML := !() -> void
	{
		if loaded
			return void
	}

	funcClass := HV_Class^
	funcClassType := void^
	FuncClass := !() -> void^
	{
		return funcClassType?

		funcClass = HV_CreateClass()

		//printf("class create %p\n",funcClass)

		funcClassType = funcClass.GetType()
		printf("heh %p\n",funcClassType)
		return funcClassType
	}

	GetItem := virtual !(StringView name) -> void^
	{
		if name == "GL_POINT_BIT"
		{
			return HV_Create_int32(109)
		}
		if name == "glFuncsClass"
		{
			return FuncClass()
		}
		LoadXML()
	}
)

main := !(char^[] args) -> int
{
	RunTest()
	return 0
}


mouseMove := !(void^ w, double itX, double itY) -> void
{
	printf("hey %p %f %f\n",w,itX,itY)
}




RunTest := !() -> void
{
	c := glFuncsClass
	//c.x = 12
	//glfwInit()
	//win := glfwCreateWindow(640, 480, "My Title", null, null)
	//glfwSetCursorPosCallback(win,mouseMove)
	//while not glfwWindowShouldClose(win)
	//{
	//	
	//	
    //    glfwPollEvents()
	//}
}


CalculatePiBlob := !(int nums) -> Blob^
{
	bigNums := nums*3
	values := malloc(bigNums*4)->{int^}

	result = new BlobOnVector(nums + 1)
	resultPtr := result.GetPointer()->{u8^}
	memset(resultPtr,0,result.Size())
	//resultPtr[nums] = 0

	i := 0
	while i < bigNums
	{
		values[i] = 2
		i += 1
	}
	i = 0
	while i < nums
	{
		j := 0
		while j < bigNums
		{
			values[j] *= 10
			j += 1
		}
		j = bigNums - 1
		while j >= 1
		{
			thisMul := j
			thisDiv := 2*j + 1

			carry := (values[j] div thisDiv)*thisMul
			modul := values[j] mod thisDiv
			values[j] = modul
			j -= 1
			values[j] += carry
		}
		num := values[0] div 10
		values[0] = values[0] mod 10

		c := 0
		while num != 0
		{
			resultPtr[i + c] += num
			if resultPtr[i + c] >= 10
			{
				resultPtr[i + c] = resultPtr[i + c] mod 10
				num = 1
			}else{
				num = 0
			}
			c -= 1
		}
		i += 1
	}
	for i : nums
	{
		resultPtr[i] += '0'
	}
}


//Zip file
//crc32
//deflate
//zip -v check
//if file already exists
//throw exceptions when file cannot be created, no space on disk, incorrect file format


//TODO todo in libs2/Random.hv is important
//i want a way to call function at the start of the program if function that uses it is called
//GetRandom  := !() -> int
//{
//	#ModuleInit(initRandom())
//	....
//}


//TODO
//decorator function
//@cache function, @once function/call
//decorator func pass constants?
//default initializer for growing class, and const value as global const
//field becomes static if it is not inside class
//zero size class optimizations
//x := field 10  non types not working
//class->AllFields to work with new Fields
//Allow code to be interpreted
//interpreter support File,XML
//Class can be created by script
//Module Vulkan uses Normal Class and usese new API
