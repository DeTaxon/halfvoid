
baseGCContainer := class extend TGCObject
{
	dataBase := RBMap.{StringSpan,TCachedGCObject^}
	Contain := !(StringSpan name) -> bool
	{
		return dataBase.Contain(name)
	}
	Remove := !(StringSpan name) -> void
	{
		spn := dataBase.Key(name)
		dataBase.Remove(spn)
		delete spn.Get()
	}
}
TGCContainer := class .{@V} extend baseGCContainer
{
	Create := !(StringSpan name) -> V^
	{
		result := new V
		result.Name = name.Str()
		result.basePointer = this&
		dataBase[result.Name] = result
		return result
	}
	Get := !(StringSpan name) -> V^
	{
		if dataBase.Contain(name)
			return dataBase[name]
		result := new V
		result.Name = name.Str()
		result.basePointer = this&
		dataBase[result.Name] = result
		return result
	}
}

TCachedGCObject := class extend TGCObject
{
	Name := StringSpan
	basePointer := baseGCContainer^
	GCLastRef := virtual !() -> void
	{
		if basePointer != null
			basePointer.Remove(Name)
	}
}

Screamer := class extend TCachedGCObject
{
	Destroy := virtual !() -> void
	{
		printf("AAAAAAA %p\n",this&)
	}
}

func2 := !() -> void
{
	throw new Exception("yep")
}

main := !(int argc, char^^ argv) -> int
{
	try{
		func2()
	}catch(IException^ e)
	{
		printf("exception %s\n",e.Msg())
		c := e.Trace()
		if c != null
		{
			printf("trace %s\n",c[^])
		}
	}
	//printf("test %p\n",stat)
	//cnt := new TGCContainer.{Screamer}
	//val := cnt.Create(StringSpan("wow"))
	return 0
}
