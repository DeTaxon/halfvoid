TGCIObject := class
{
	IncRef := virtual !() -> void { }
	DecRef := virtual !() -> void { }
	Destroy := virtual !() -> void {}
}

TGCObject := class extend TGCIObject
{
	RefValue := int

	IncRef := virtual !() -> void { RefValue += 1}
	DecRef := virtual !() -> void {
		RefValue -= 1
		if RefValue == 0
		{
			Destroy()
			delete this&
		}
	}
	Destroy := virtual !() -> void {}
}

internalHVNew := !() .{@T} -> T^
{
	result&->{void^^}^ = calloc(1,T->TypeSize) //weird way to bypass DecRef
	if T->TypeGroup == "Class"
		internalHVInitClass(result^)
	if T is in TGCIObject
		result.IncRef()
}
internalHVNewConstructed := !(@T^ obj, args...) -> T^
{
	result = obj
	result.this(args...)
}

"=" := !(TGCIObject^& itm1, TGCIObject^ itm2) -> void
{
	itm2?.IncRef()
	if itm1 != null
	{
		itm1.DecRef()
	}
	itm1&->{void^^}^ = itm2->{void^}
}

internalHVDelete := !(@T^ x) -> void
{
	free(x)
}
internalHVGCSetNull := !(TGCIObject^ & itm1) -> void
{
	itm1 = null->{TGCIObject^}
}

internalHVGCSetNullArray := !(TGCIObject^^ arrs, int start, int end) -> void
{
	i := end
	while i >= start
	{
		arrs[i] = null
		i -= 1
	}
}

internalHVGetDepth := !() -> int
{
}
internalHVSetDepth := !(int depth) -> void
{
}

TILambda := class extend TGCObject
{
	Capture := virtual !() -> TILambda^
	{
		//assert(false)
		return null
	}
	IsFinished := virtual !() -> bool
	{
		return false
	}

	getCaptureVar := virtual !() -> void^ { return null }
	getYieldState := virtual !() -> int& {  } //TODO assert
	getYieldVars := virtual !() -> void^ { return null }
}

TLambda := class .{@FuncPtr} extend TILambda
{
	callFunc := FuncPtr
	//"()" := !(args...)
	//{
	//	return this.callFunc(this&,argc...)
	//}
}
TLambdaImp := class .{@FuncPtr,@CapTypePtr,@YieldTuple} extend TLambda.{FuncPtr}
{
	capPtr := CapTypePtr
	yieldState := int
	lambdaVars := YieldTuple

	IsFinished := virtual !() -> bool { return yieldState < 0 }
	getCaptureVar := virtual !() -> void^ {  result = capPtr }
	getYieldState := virtual !() -> int& { return yieldState }
	getYieldVars := virtual !() -> void^ { return lambdaVars& }
}

internalHVLambdaCall := !(@T lmb,args...) -> void // return type replaced by compiler on result type of @FuncType
{
	return lmb.callFunc(lmb&,args...)
}
internalHVLambdaGetCaptures := !(void^ lmbd) .{@T} -> T^
{
	return lmbd->{TILambda^}.getCaptureVar()->{T^}
}
internalHVLambdaGetYieldState := !(void^ lmbd) -> int&
{
	return lmbd->{TILambda^}.getYieldState()
}

internalHVLambdaGetYieldTuple := !(void^ lmbd) .{@LambdaVarsTuple} -> LambdaVarsTuple^
{
	return lmbd->{TILambda^}.getYieldVars()->{LambdaVarsTuple^}
}

internalHVCreateLambda := !(@FuncPtr fnc,@CaptureTuplePtr CaptureVars).{@YieldVars} -> TLambdaImp.{FuncPtr,CaptureTuplePtr,YieldVars}
{
	result.callFunc = fnc
	result.capPtr = CaptureVars
	//res := new TLambdaWithCaptures.{FuncPtr,CaptureTuplePtr,YieldVars}
	//res.callFunc = fnc
	//res.capPtr = CaptureVars
	//result = res
}
internalHVStackAllocatedGC := class .{@T} extend T
{
	DecRef := virtual !() -> void {
		RefValue -= 1
		if RefValue == 0
		{
			Destroy()
		}
	}
}

SomeBigObject := class extend TGCObject
{
	x := int
	y := int

	Destroy := virtual !() -> void
	{
		printf("YES\n")
	}
}

resBig := !() -> SomeBigObject
{
	printf("hey\n")
	result.x = 10
	result.y = 12
}

main := !(int argc, char^^ argv) -> int
{
	rb := resBig()
	printf("test %i %i\n",rb.x,rb.y)
	//z := () ==> {
	//	printf("a\n")
	//	yield 12
	//	printf("b\n")
	//	yield 10
	//	printf("c\n")
	//	yield 7
	//	printf("d\n")
	//}

	return 0
}

internalHVSetType := !(@T^ x) .{@ToType} -> ToType^
{
	x->{void^}->{ToType^}->VTable = ToType->VTable
	return x->{void^}->{ToType^} //todo recheck on dymamic check
}
