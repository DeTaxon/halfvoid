
#mark(jit_pass) Func1 := !() -> void
{
	printf("hello\n")
}
#mark(jit_pass) Func2 := !() -> void
{
}

getType := !(int callSize) .{@T} -> void 
{
	printf("%2i group %s\n",callSize,T->Group)
	switch T->Group
	{
		case "prime"
			printf("%2i prime\n",callSize)
		case "array"
		case "func"
		if T->Group == "func"
		{
			printf("%2i func\n",callSize)
			for par : T->Params
			{
				printf("%2i param\n",callSize)
				getType(callSize+1).{par}
			}
		}
		case "lambda"
		case "pointer"
	}

	#prolog
	{
		getType([t | T] , [b | B]) :- t = getType(b)
		getType(T,R) :- T = int, R = GTypeInt
		getType(T,R) :- T = float, R = GTypeFloat
		getType(T,R) :- T->Type = "prime", R = GetType(T->RawName)
		getType(T,R) :- T->Type = "array", getType(T->Base,B),  R = B.GetArray(T->Len)
		getType(T,R) :- T->Type = "func",  getType(T,B),getType(T->ResultType,RT),  R = GetFuncType(B,RT)
		getType(T,R) :- T->Type = "lambda",  getType(T,B),getType(T->ResultType,RT),  R = GetFuncType(B,RT)
	}
	getType(T,result)

	////#prolog
	////{
	////	TestArgs(Inp,Outp,Result) := 
	////}
	//result = GetFuncType(![GTypeInt],GTypeVoid)
}

main := !(int argc, char^^ argv) -> int
{
	TFullInit()

	defer printf("hello\n")

	//for func : Thread->Funcs
	//{
	//	printf("tst %s %p %p\b",func->name,func,func->raw)
	//}
}

