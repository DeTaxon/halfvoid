
//TODO i need some way to profile fibers usage and way to find abandoned hatches
//TODO @once does not work with function input variables
//TODO todo in libs2/Random.hv is important
//TODO arr := !["","1"] ; arr[0] returns null

//TODO bug res := ptr1->{size_t} - ptr2->{size_t} fails as unary minus takes priority

main := !(char^[] args) -> int
{
	libGlfwInit()

	glfwInit()
	win := glfwCreateWindow(500,500,"HI",null,null)
	//fl := FSGetFile("glfw3.dll")
	//lb := GetLibrary(fl)
	//fnc := lb.Get("glfwInit")->{!()^->void}
	//fncWin := lb.Get("glfwCreateWindow")->{!(int,int,char^,void^,void^)^->void^}
	//printf("hey %p %p\n",lb,fnc)
	//fnc()
	//fncWin(500,500,"LOL",null,null)
	return 0

	//itFile >> XMLDecoder >> FillView(x ==> { x.PrintTree() }
	//TFlow(itFile,ImageDecoder,ImageToBuffer,BufferCoppy(ResultBuffer))
	//itFile >> ImageDecoder >> ImageToBuffer >> BufferCopy(ResultBuffer)

	//flw := TFlow(InfStream.{int}(),Uniq,File("w"))
	//flw.Push(13)

	return 0
}

//Zip file
//crc32
//deflate
//zip -v check
//if file already exists
//throw exceptions when file cannot be created, no space on disk, incorrect file format

//TypeInfo := type_trait 
//{
//	TypeSize(),
//	"<=>",
//	delete
//}
//
//List := class .{generic TypeInfo T} extend T[]
//{
//	node := class
//	{
//		next := node^
//		prev := node^
//		data := T
//	}
//
//	createNode := !() -> node^
//	{
//		//return malloc(node->TypeSize + T.TypeSize)
//		return new node 
//	}
//
//	"for" := generator () -> T
//	{
//		itr := start
//		while itr != null
//		{
//			yield itr.data
//			itr = itr.next
//		}
//	}
//}

//#Module
//{
//	xml := XMLFile(#File("vk.xml"))
//	cls := #CreateClass("VKFuncs")
//
//	#Callback(cls,"FieldMissed") (name)
//	{
//		
//	}
//}

//inline road
//static variables stays in one function
//input variadic variables C //do i need it?
//deducting type by returns
//captured values, and defer does not work
//debug data for functions in different files
SomeClass44 := class
{
	xx := int
	testCall := inline !(int cmplxName,args...) .{@HH} -> int
	{
		printf("hello world %i %i %i\n",cmplxName,args...)
		cmplxName = 1313
		printf("hello world %i %i %i\n",cmplxName,args...)
		printf("wut %i %i %i\n",HH,xx,test2())
		return 47
	}
	test2 := !() -> int
	{
		return 1734 + xx
	}
	someBug := !(int j = 13) -> void
	{
	}
}

inlineBugs := !() -> void
{
	x := 74
	c := y.testCall(x,15,-100).{477}
	printf("after %i %i\n",x,c)
}

//TODO
//decorator function
//@cache function, @once function/call
//decorator func pass constants?
//default initializer for growing class, and const value as global const
//field becomes static if it is not inside class
//zero size class optimizations
//x := field 10  non types not working
//class->AllFields to work with new Fields
//Allow code to be interpreted
//interpreter support File,XML
//Class can be created by script
//Module Vulkan uses Normal Class and usese new API


DllTest := !() -> void
{
	tst := FSGetFile("libwebp-7.dll")
	mp := tst.GetMap()

	win32LoadLibrary(mp.Get(),tst.Size())
}

RegExpTest := !() -> void
{
	itBuilder := LexBuilder

	itBuilder.ApplyReg("\"((\\\\ [^]) | [^\"\\\\])*\"",1)
	itBuilder.ApplyReg("[0-9]+(.[0-9]+)?",2)
	itBuilder.ApplyReg("0x[0-9a-fA-F]+([0-9a-fA-F]+)?",2)
	itBuilder.ApplyReg(" true | false | null",3)
	itBuilder.ApplyReg("\\{ | \\} | \\, | \\: | \\[ | \\]",4)
	itBuilder.ApplyReg("\\  | \\t | \\n",5)

	res := itBuilder.GenerateMachine()

	// res.PrintIt()

	tst := FSGetFile("test.json")
	mp := tst.GetMap()

	res.RegExpReadText(mp.Get(),mp.Size(), (st,a) ==> {
		if a != 5
		{
			printf("hm <%s>\n",st.GetString().Str())
		}
	})
}

//AClass := class
//{
//	ggg := virtual int TODO Creates bug
//	g3 := int
//}

