TGCIObject := class
{
	IncRef := virtual !() -> void { }
	DecRef := virtual !() -> void { }
	Destroy := virtual !() -> void {}
}

TGCObject := class extend TGCIObject
{
	RefValue := int

	IncRef := virtual !() -> void { RefValue += 1}
	DecRef := virtual !() -> void {
		RefValue -= 1
		if RefValue == 0
		{
			Destroy()
			delete this&
		}
	}
	Destroy := virtual !() -> void {}
}

internalHVNew := !() .{@T} -> T^
{
	result&->{void^^}^ = calloc(1,T->TypeSize) //weird way to bypass DecRef
	if T->TypeGroup == "Class"
		internalHVInitClass(result^)
	if T is in TGCIObject
		result.IncRef()
}
internalHVNewConstructed := !(@T^ obj, args...) -> T^
{
	result = obj
	result.this(args...)
}

"=" := !(TGCIObject^& itm1, TGCIObject^ itm2) -> void
{
	itm2?.IncRef()
	if itm1 != null
	{
		itm1.DecRef()
	}
	itm1&->{void^^}^ = itm2->{void^}
}

internalHVDelete := !(@T^ x) -> void
{
	free(x)
}
internalHVGCSetNull := !(TGCIObject^ & itm1) -> void
{
	itm1 = null->{TGCIObject^}
}

internalHVGetDepth := !() -> int
{
}
internalHVSetDepth := !(int depth) -> void
{
}

TILambda := class extend TGCObject
{
	//Capture := virtual !() -> TILambda^
	//{
	//	//assert(false)
	//	//return null
	//}
	IsFinished := virtual !() -> bool
	{
	}
}

//TLambda := class .{@Func} extend TILambda
//{
//	//callFunc := Func->Type^
//	//"()" := !(args...) -> void
//	//{
//	//	return this.callFunc(this&,argc...)
//	//}
//}

//TLambdaImplementation := class .{@Captures} extend TLambda
//{
//	values := Captures
//
//	//Capture := virtual !() -> TLambda^
//	//{
//	//	result = new TLambdaImplementation
//	//	result.values[^] = values[^]
//	//}
//}

//internalHVLambdaCall := !(TLambda.{@Func}^ fncCall) -> void //void replaced with what  Func->Resutl is
//{
//	return fncLambda.callFunc()
//}

z := !() -> int^
{
	return null
}
main := !(int argc, char^^ argv) -> int
{
	x := true
	z()
	//printf("hey %i\n",x == true)
	//{

	//	//l := () ==> {
	//	//	printf("hi\n")
	//	//}
	//	//l()
	//	//l()
	//}
	return 0
}
