
//TODO i need some way to profile fiber usage and way to find abandoned hatches
//TODO capturing vec2f crash program, maybe value are not aligned to 16 byte
//TODO make FS aware of CacheFile



//#CreateClass(
//	Name = "TestClass",
//	Init = !(ctx)
//	{
//		ctx.AddField("x",int)
//	}
//	GetFieldFailedCB = !(ctx,fieldName)
//	{
//		ctx.AddField(fieldName,int)
//	}
//)
//#CreateClass(
//	Name = "TestClass",
//	Init = !(ctx)
//	{
//		ctx.AddField("x",int)
//	}
//	GetFieldFailedCB = !(ctx,fieldName)
//	{
//		ctx.AddField(fieldName,int)
//	}
//)

#CreateCallCommand(
	Name = "ComputePi",
	Call = !() -> Blob^
	{
		result = CalculatePiBlob()
	}
	ExchangeOut = !(Blob^ blb) -> char^
	{
		return blb.GetPointer()
	}
)

main := !(char^[] args) -> int
{
	//_mkdir("ðŸ˜Š")
	
	tst := CacheFile("Test.zip")
	fls := tst.GetFileModule("Bad")
	fls.GetCacheValue(FSGetFile("grind.txt"),() ==> Blob^ {
		printf("doung calculus\n")
		result = new BlobOnVector(200)
	})
	return 0
	//piValue := CalculatePiString()
	//printf("%s\n",piValue)
	//c := #ComputePi()
	//printf("hob %s\n",c)
	//#Run(CalculatePiString())
	return 0
	//RunTest()
	//return 0

	////TestClsInput(![2,53,10])
	////ManyVars(13)
	////ManyVars(13,7)
	////ManyVars(13,z = 30)

	//tbl := HVTable2.{int,int}
	//tbl.Add(1,2)
	//tbl.Add(2,3)
	//tbl.Add(4,5)

	////tbl.key.GetRecur(1, (x) ==> { printf("hm %i\n",x) })
	//tbl.Key.Get(1, (x) ==> { printf("hm just %i\n",x) })
	////tbl.key.GetRecur(5, (x) ==> { printf("hm %i\n",x) })
	//tbl.Value.Get(2 , (x) ==> { printf("back %i\n",x)})
	////tbl.value.GetRecur(3, (x) ==> { printf("back %i\n",x) })
}


RunTest := !() -> void
{
	//CalculatePiString()
	
	//c.Push(13)
	//c.Push(7)

	//d := c.ToVector()

	//test := LexBuilder
	//test.ApplyReg("[0-9]+",1)
	//mac := test.GenerateMachine()

	//mac.RegExpReadText(StringSpan("absc 234 asfa;sdkj 9871234 lkaj35r;"),(x,y) ==> {
	//	printf("test %s\n",x.GetString().Str())
	//})
	
}

ManyVars := !(int x, int y = 30, double z = 0.5) -> void
{
	printf("wow %i %i %f\n",x,y,z)
}

ClsInput := class
{
	Objects := int[]
	ExtraData := double
}

TestClsInput := !(ClsInput inputs) -> void
{
	for it : inputs.Objects
	{
		printf("test %i\n",it)
	}
}
"->{}" := !(int[] vals) -> TestClsInput
{
	result.Objects = vals
}

CalculatePiBlob := !() -> Blob^
{
	nums := 12000
	bigNums := nums*3
	values := malloc(bigNums*4)->{int^}

	result = new BlobOnVector(nums + 1)
	resultPtr := result.GetPointer()->{u8^}
	memset(resultPtr,0,result.Size())
	//resultPtr[nums] = 0

	i := 0
	while i < bigNums
	{
		values[i] = 2
		i += 1
	}
	i = 0
	while i < nums
	{
		j := 0
		while j < bigNums
		{
			values[j] *= 10
			j += 1
		}
		j = bigNums - 1
		while j >= 1
		{
			thisMul := j
			thisDiv := 2*j + 1

			carry := (values[j] div thisDiv)*thisMul
			modul := values[j] mod thisDiv
			values[j] = modul
			j -= 1
			values[j] += carry
		}
		num := values[0] div 10
		values[0] = values[0] mod 10

		c := 0
		while num != 0
		{
			resultPtr[i + c] += num
			if resultPtr[i + c] >= 10
			{
				resultPtr[i + c] = resultPtr[i + c] mod 10
				num = 1
			}else{
				num = 0
			}
			c -= 1
		}
		i += 1
	}
	for i : nums
	{
		resultPtr[i] += '0'
	}
}
//Reserve inheritance failed, it's overcomplicated
//ExpectClass := class
//{
//	x := int //TODO reserve it
//	SomeFunc := virtual !() -> void
//	{
//		printf("no\n")
//	}
//}
//
//SomeInterface := class 
//	#Reserve ExpectClass
//{
//	//TODO reserve does not reserve fields
//}
//
//ImplInterface := class 
//	extend SomeInterface,ExpectClass
//{
//	//TODO must be a version of a copy
//}

//#Test
//{
// statis_assert(#IsConst(cos(90deg) ))
//}
//


//Zip file
//crc32
//deflate
//zip -v check
//if file already exists
//throw exceptions when file cannot be created, no space on disk, incorrect file format

//TypeInfo := type_trait 
//{
//	TypeSize(),
//	"<=>",
//	delete
//}
//
//List := class .{generic TypeInfo T} extend T[]
//{
//	node := class
//	{
//		next := node^
//		prev := node^
//		data := T
//	}
//
//	createNode := !() -> node^
//	{
//		//return malloc(node->TypeSize + T.TypeSize)
//		return new node 
//	}
//
//	"for" := generator () -> T
//	{
//		itr := start
//		while itr != null
//		{
//			yield itr.data
//			itr = itr.next
//		}
//	}
//}

//TODO todo in libs2/Random.hv is important
//i want a way to call function at the start of the program if function that uses it is called
//GetRandom  := !() -> int
//{
//	#ModuleInit(initRandom())
//	....
//}

//#Module
//{
//	xml := XMLFile(#File("vk.xml"))
//	cls := #CreateClass("VKFuncs")
//
//	#Callback(cls,"FieldMissed") (name)
//	{
//		
//	}
//}



//TODO
//decorator function
//@cache function, @once function/call
//decorator func pass constants?
//default initializer for growing class, and const value as global const
//field becomes static if it is not inside class
//zero size class optimizations
//x := field 10  non types not working
//class->AllFields to work with new Fields
//Allow code to be interpreted
//interpreter support File,XML
//Class can be created by script
//Module Vulkan uses Normal Class and usese new API


DllTest := !() -> void
{
	tst := FSGetFile("libwebp-7.dll")
	mp := tst.GetMap()

	win32LoadLibrary(mp.Get(),tst.Size())
}

RegExpTest := !() -> void
{
	itBuilder := LexBuilder

	itBuilder.ApplyReg("\"((\\\\ [^]) | [^\"\\\\])*\"",1)
	itBuilder.ApplyReg("[0-9]+(.[0-9]+)?",2)
	itBuilder.ApplyReg("0x[0-9a-fA-F]+([0-9a-fA-F]+)?",2)
	itBuilder.ApplyReg(" true | false | null",3)
	itBuilder.ApplyReg("\\{ | \\} | \\, | \\: | \\[ | \\]",4)
	itBuilder.ApplyReg("\\  | \\t | \\n",5)

	res := itBuilder.GenerateMachine()

	// res.PrintIt()

	tst := FSGetFile("test.json")
	mp := tst.GetMap()

	res.RegExpReadText(mp.Get(),mp.Size(), (st,a) ==> {
		if a != 5
		{
			printf("hm <%s>\n",st.GetString().Str())
		}
	})
}

//AClass := class
//{
//	ggg := virtual int TODO Creates bug
//	g3 := int
//}

