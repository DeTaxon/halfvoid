
internalHVGetTaskLocalTuple := !() -> void^
{
	return g
}


internalHVEntryPoint := !(int argc,char^^ argv) -> int
{
	//spn := TArraySpan.{char^}//(argv,argc)
	//spn.pointer = argv
	//spn.itSize = argc
	return main(argc,argv)
}

TArrayView := class .{@T} extend TGCObject
{
	Size := virtual !() -> int {}
	"[]" := virtual !(int i) -> T& { }
	//"for" := virtual !() -> !()& -> T& {
	//	c := this&
	//	x := () ==> T& {
	//		i := 0
	//		s := c.Size()
	//		while i < s
	//		{
	//			yield c^[i]
	//		}
	//	}
	//	return x.Capture()
	//}
	//Destroy := virtual !() -> void {}

	//Reverse := fake
	//{
	//	"[]" := virtual !(int i ) ->T& {}
	//}
}

TArraySpan := class .{@T} extend TArrayView.{T}
{
	pointer := T^
	itSize := int

	this := !(T^ p, int s) -> void
	{
		pointer = p
		itSize = s
	}
	Size := virtual !() -> int { return itSize }
	"[]" := virtual !(int i) -> T& { return pointer[i] }
}

"[]" := !(TArrayView.{@T}^ x,int i) -> T&
{
	assert(x != null)
	return x^[i]
}

//main := !(char[] args) -> void
//{
//	
//}

main := !(int argc,char^^ argv) -> int
{
	//for it : args^
	//{
	//	printf("arg %s\n",it)
	//}
	oo := 0
	x := new TGCObject
	y := new TGCObject
	z := () ==> {
		printf("test %p %p\n",x,x&)
		yield void
		printf("test %p %p\n",y,y&)
		yield void
		c := 0
		printf("c = %i\n",c)
		yield void
		c += 1
		printf("c = %i\n",c)
		yield void
		c += 2
		printf("c = %i\n",c)
		yield void
		c += 3
		printf("c = %i\n",c)
		yield void

		//TODO clean case not working
		//k := () ==> {
		//	//printf("east %p %p\n",y,y&)
		//	printf("ost %i\n",c)
		//}
		//k()

		k := () ==> {
			d := 100
			//printf("east %p %p\n",y,y&)
			printf("ost %i\n",oo)
		}
		k()
	}
	z()
	z()
	z()
	z()
	z()
	z()
	return 0
}



arFunc := void^
arSize := int
internalEnterGCFunction := !(TGCIObject^ arr,int maxSize) -> void
{
	arFunc = arr
	arSize = maxSize
}
internalLeaveGCFunction := !() -> void
{
}

tst := void^
thisExcp := void^ //TODO IException not supported
internalEnterTryCatch := !(void^ ptr,bool cleanGC,int gcInUse) -> void
{
	tst = ptr
}
internalLeaveTryCatch := !() -> void
{
}
internalThrowException := !(IException^ e) -> void
{
	printf("called throw %p\n",e)
	thisExcp = e
	e.IncRef()
	internalHVGCSetNullArray(arFunc->{TGCIObject^^},0,arSize - 1)
	llvmLongJump(tst)
}
internalGetException := !() -> IException^
{
	result = thisExcp->{IException^}
}

IException := class extend TGCObject
{

}

Exception := class extend IException
{
	
}
