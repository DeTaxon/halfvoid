

main := !(char^[] args) -> int
{
	mp := HashMap.{Str,int}

	check := () ==> {
		for it,ind : mp
		{
			printf("key %s value %i\n",ind,it)
		}
	}

	mp["Hello"] = 3
	mp["World"] = 5
	mp["Test"] = 1
	
	check()
	mp["World"] = 100

	check()

	mp.Remove("Hello")

	check()
}
RunTest := !() -> void
{
}


HashMap := class .{@TKey,@TValue}
{
	bucket := ListNode.{Tuple.{TKey,TValue}}^[8192]
	ItSize := int

	thisBucket := !(TKey key) -> ref ListNode.{Tuple.{TKey,TValue}}^
	{
		hsh := Hash(key)
		hsh = 0
		return bucket[hsh mod 8192]
	}
	Contain := !(TKey key) -> bool
	{
		bk := ref thisBucket(key)

		iter := bk.next
		while iter != null
		{
			if iter.data.0 == key
				return true
			iter = iter.next
		}
		return false
	}
	Size := !() -> int
	{
		return ItSize
	}

	"[]" := !(TKey key) -> ref TValue
	{
		bk := ref thisBucket(key)

		iter := bk

		while iter != null and iter.data.0 != key
			iter = iter.next

		if iter != null
			return iter.data.1

		iter = new ListNode.{Tuple.{TKey,TValue}}
		iter.data.0 = key

		if bk == null {
			bk = iter
		}else{
			iter.next = bk
			bk.prev = iter
			bk = iter
		}

		ItSize += 1
		return iter.data.1
	}
	Remove := !(TKey key) -> void
	{
		bk := ref thisBucket(key)
		
		iter := bk

		while iter != null and iter.data.0 != key
			iter = iter.next

		if iter == null
			return void

		if iter == bk
		{
			bk = iter.next
			bk?.prev = null
		}else{
			iter.prev.next = iter.next
			iter.next?.prev = iter.prev
		}

		
		ItSize -= 1
		delete iter
	}
	"for" := !() -> !(TKey^&)&->ref TValue
	{
		cb := (TKey^& key) ==> ref TValue 
		{
			for it : 8192
			{
				iter := bucket[it]

				while iter != null
				{
					key = iter.data.0&
					yield iter.data.1

					iter = iter.next
				}
			}
		}
		return cb.Capture()
	}
}


Hash := !(Str stringValue) -> int
{
	if stringValue->AsString == null
		return 0
	value := 1

	c := stringValue.charPtr
	i := 0

	while c[i] != 0
	{
		value = (value shl 3) + (value xor_b c[i]) + (value shr 16)
		i += 1
	}
	return value
}

#Module(
	GetItem := virtual !(Str st) -> void^
	{
		if st == "TestClass"
		{
			cls := @once HV.CreateClass()
			cls.AddField("x",HV.GetType("int"))
			cls.AddMethodStr("TestFunc","
				!() -> void{
					printf(\"Hi, maybe %i\\n\",x)
				}
			")
			return cls.GetType()
		}
	}
)


mouseMove := !(void^ w, double itX, double itY) -> void
{
	//printf("hey %p %f %f\n",w,itX,itY)
}


RunOpenGLTest := !() -> void
{
	gl := glFuncsClass

	glfwInit()

	win := glfwCreateWindow(640, 480, "My Title", null, null)
	glfwSetCursorPosCallback(win,mouseMove)
	glfwMakeContextCurrent(win)

	lib := GetLibrary(!["libGL.so","OpenGL32.dll"])
	glGetProcAddress := lib.Get("glXGetProcAddress")->{!(char^)^->void^}

	if glGetProcAddress == null
	{
		glGetProcAddress = lib.Get("wglGetProcAddress")->{!(char^)^->void^}
	}


	nameBuffer := char[128]
	for it,ind : gl->AllFields
	{
		sprintf(nameBuffer[0]&,"gl%s",ind)
		it&->{void^^}^ = glGetProcAddress(nameBuffer[0]&)
		//printf("proc %s %p\n",ind,it)
	}

	gl.ClearColor(1.0,0.5,0.0,0.0)

	while not glfwWindowShouldClose(win)
	{
		gl.Clear(GL_COLOR_BUFFER_BIT)
		gl.Begin(GL_TRIANGLES)
		gl.Color3f(1.0,0.0,0.0)
		gl.Vertex3f(-1.0,-1.0,0.0)
		gl.Color3f(0.0,1.0,0.0)
		gl.Vertex3f(1.0,-1.0,0.0)
		gl.Color3f(0.0,0.0,1.0)
		gl.Vertex3f(0.0,1.0,0.0)
		gl.End()
        glfwPollEvents()
		glfwSwapBuffers(win)
	}
}


//CalculatePiBlob := !(int nums) -> Blob^
//{
//	bigNums := nums*3
//	values := malloc(bigNums*4)->{int^}
//
//	result = new BlobOnVector(nums + 1)
//	resultPtr := result.GetPointer()->{u8^}
//	memset(resultPtr,0,result.Size())
//	//resultPtr[nums] = 0
//
//	i := 0
//	while i < bigNums
//	{
//		values[i] = 2
//		i += 1
//	}
//	i = 0
//	while i < nums
//	{
//		j := 0
//		while j < bigNums
//		{
//			values[j] *= 10
//			j += 1
//		}
//		j = bigNums - 1
//		while j >= 1
//		{
//			thisMul := j
//			thisDiv := 2*j + 1
//
//			carry := (values[j] div thisDiv)*thisMul
//			modul := values[j] mod thisDiv
//			values[j] = modul
//			j -= 1
//			values[j] += carry
//		}
//		num := values[0] div 10
//		values[0] = values[0] mod 10
//
//		c := 0
//		while num != 0
//		{
//			resultPtr[i + c] += num
//			if resultPtr[i + c] >= 10
//			{
//				resultPtr[i + c] = resultPtr[i + c] mod 10
//				num = 1
//			}else{
//				num = 0
//			}
//			c -= 1
//		}
//		i += 1
//	}
//	for i : nums
//	{
//		resultPtr[i] += '0'
//	}
//}


//Zip file
//crc32
//deflate
//zip -v check
//if file already exists
//throw exceptions when file cannot be created, no space on disk, incorrect file format

//TODO
//@cache function, @once function/call
//decorator func pass constants?
//default initializer for growing class, and const value as global const
//field becomes static if it is not inside class
//zero size class optimizations
//x := field 10  non types not working
//Module Vulkan uses Normal Class and usese new API
