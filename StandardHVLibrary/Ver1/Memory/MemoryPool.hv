AllocOnlyMP := class .{@PageSize,@CleanResult} extend IMemoryPool
{
	itPage := u8^
	itLoaded := int
	createdPages := List.{void^}

	GetPage := !() -> u8^
	{	
		MallocPoolBlock()
		newPage := null->{u8^}
		newPage = malloc(PageSize)
		if CleanResult
		{
			memset(newPage,0,PageSize)
		}
		createdPages << newPage
		return newPage
	}
	GetMem := virtual !(size_t size, int align,int prefix) -> void^
	{
		if size > PageSize
		{
			preRe := malloc(size)
			if CleanResult memset(preRe,0,size)
			MallocPoolBlock()
			createdPages << preRe
			return preRe
		}
		if itPage == null{
			itPage = GetPage()
		}
		newSize := itLoaded
		if align > 1 {
			newSize +=  0xFF % align
			newSize -= newSize % align
		}
		itLoaded = newSize + size

		if itLoaded >= PageSize
		{
			itPage = GetPage()
			itLoaded = size
			return itPage
		}
		return itPage[newSize]&
	}
	FreeMem := virtual !(void^ memPtr) -> void
	{
	}
	Destroy := !() -> void
	{
		free(createdPages[^])
		createdPages.Destroy()
	}
}


StupidMemoryPool := class .{@PageSize} extend IMemoryPool
{
	itPage := u8^
	itLoaded := int

	itBusyPages := List.{u8^}
	itFreedPages := List.{u8^}

	this := !() -> void
	{
		itPage = null
		itLoaded = 0
		itBusyPages."this"()
		itFreedPages."this"()
	}
	Destroy := !() -> void
	{
		free(itBusyPages[^])
		itBusyPages.Destroy()
		free(itFreedPages[^])
		itFreedPages.Destroy()
		if itPage != null
		{
			free(itPage)
			itPage = null
		}
	}
	GetPage := !() -> u8^
	{	
		newPage := null->{u8^}
		if itFreedPages.IsEmpty()
		{
			newPage = malloc(PageSize)
		}else{
			MallocPoolBlock()
			newPage = itFreedPages.Pop()
		}
		memset(newPage,0,PageSize)
		return newPage
	}
	GetMem := virtual !(size_t size, int align, int prefix) -> void^
	{
		if itPage == null{
			itPage = GetPage()
		}
		newSize := itLoaded
		if align > 1 {
			newSize +=  0xFF % align
			newSize -= newSize % align
		}
		itLoaded = newSize + size

		if itLoaded >= PageSize
		{
			MallocPoolBlock()
			itBusyPages.Push(itPage)
			itPage = GetPage()
			itLoaded = size
			return itPage
		}
		return itPage[newSize]&
	}
	FreeMem := virtual !(void^ itm) -> void
	{
	}
	FlushMem := !() -> void
	{
		if itPage != null {
			memset(itPage,0,itLoaded)
		}
		itLoaded = 0
		MallocPoolBlock()
		itFreedPages <<< itBusyPages
	}
}

