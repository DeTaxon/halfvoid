HybridQueue := class .{@T,@ExtraSize}
{
	qArr := T[ExtraSize]
	itSize := int
	subList := List.{T}
	
	this := !() -> void
	{
	}
	makeNewItem := !() -> ref T //TODO make it template
	{
		if itSize < ExtraSize
		{
			itSize += 1
			return qArr[itSize - 1]
		}
		itSize += 1
		return subList.Create()
	}
	PushFront := !(T itm) -> void
	{
		if itSize >= ExtraSize
			subList.PushFront(qArr[ExtraSize - 1])
		for i : itSize
		{
			qArr[itSize - i] = qArr[itSize - i - 1]
		}
		qArr[0] = itm
		itSize += 1
	}
	Push := !(T itm) .{} -> void
	{
		makeNewItem() = itm
	}
	Emplace := !(args...) .{} -> void
	{
		makeNewItem()."this"(args...)
	}
	"[]" := !(int ps) -> ref T
	{
		if ps < 0
			return this[itSize + ps]
		assert(ps < itSize)
		if ps < ExtraSize
		{
			return qArr[ps]
		}
		return subList[ps - ExtraSize]
	}
	Clear := !() . {} -> void
	{
		itSize = 0
		subList.Clear()
	}
	Destroy := !() .{} -> void
	{
		itSize = 0
		subList.Destroy() //TODO GC
	}
	Size := !() -> int
	{
		return itSize
	}
	// "~For" := !() -> !()&->T&
	// {
	// 	return () ==>
	// 	{
	// 		fixSize := min(itSize,ExtraSize)
	// 		if fixSize != 0
	// 		{
	// 			for i : fixSize 
	// 				yield qArr[i]
	// 		}
	// 		if subList.Size() != 0
	// 		{
	// 			yield subList[^]
	// 		}
	// 	}
	// }

	"~For" := !() -> HybridQueueIterator.{T}
	{
		result.arraySize = ExtraSize
		result.maxSize = Size()

		result.arrayPtr = qArr[0]&
		result.iter = subList.Start
	}
}

HybridQueueIterator := class .{@T}
{
	arraySize := int
	maxSize := int
	index := int

	arrayPtr := T^
	iter := ListNode.{T}^

	"^" := !() -> ref T { 
		if index >= arraySize
		{
			return iter.Data
		}else{
			return arrayPtr[index] 
		}
	}
	Inc := !() -> void { 
		if index >= arraySize
			iter = iter.Next
		index += 1
	 }
	IsEnd := !() -> bool { return index >= maxSize }
}
