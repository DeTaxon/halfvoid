HybridQueue := class .{@T,@ExtraSize}
{
	qArr := T[ExtraSize]
	itSize := int
	subList := List.{T}
	
	this := !() -> void
	{
	}
	"~For" := !() -> !()&->T&
	{
		return () ==>
		{
			fixSize := min(itSize,ExtraSize)
			if fixSize != 0
			{
				for i : fixSize 
					yield qArr[i]
			}
			if subList.Size() != 0
			{
				yield subList[^]
			}
		}
	}
	makeNewItem := !() -> ref T //TODO make it template
	{
		if itSize < ExtraSize
		{
			itSize += 1
			return qArr[itSize - 1]
		}
		itSize += 1
		return subList.Create()
	}
	PushFront := !(T itm) -> void
	{
		if itSize >= ExtraSize
			subList.PushFront(qArr[ExtraSize - 1])
		for i : itSize
		{
			qArr[itSize - i] = qArr[itSize - i - 1]
		}
		qArr[0] = itm
		itSize += 1
	}
	Push := !(T itm) .{} -> void
	{
		makeNewItem() = itm
	}
	Emplace := !(args...) .{} -> void
	{
		makeNewItem()."this"(args...)
	}
	"[]" := !(int ps) -> ref T
	{
		if ps < 0
			return this[itSize + ps]
		assert(ps < itSize)
		if ps < ExtraSize
		{
			return qArr[ps]
		}
		return subList[ps - ExtraSize]
	}
	Clear := !() . {} -> void
	{
		itSize = 0
		subList.Clear()
	}
	Destroy := !() .{} -> void
	{
		itSize = 0
		subList.Destroy() //TODO GC
	}
	Size := !() -> int
	{
		return itSize
	}
}
