HybridQueueIterator := class .{@T}
{
	qArr := T^
	itSize := int
	itIntInd := int
	itPtrItr := ListNode.{T}^
	ExtraSize := int
	this := !(T^ iQArr,ListNode.{T}^ iStart, int iItSize,int iExtraSize) -> void
	{
		qArr = iQArr
		itIntInd = 0
		itPtrItr = iStart
		itSize = iItSize
		ExtraSize = iExtraSize
	}
	"^" := !() -> ref T
	{
		if itIntInd < ExtraSize
		{
			return qArr[itIntInd] 
		}
		return itPtrItr.Data
	}
	IsEnd := !() -> bool { return itIntInd >= itSize}
	Inc := !() -> void
	{
		if itIntInd >= ExtraSize
		{
			itPtrItr = itPtrItr.Next
		}
		itIntInd += 1
	}
}

HybridQueue := class .{@T,@ExtraSize}
{
	qArr := T[ExtraSize]
	itSize := int
	subList := List.{T}
	
	this := !() -> void
	{
	}
	"~For" := !() -> HybridQueueIterator.{T}
	{
		return HybridQueueIterator.{T}(qArr[0]&,subList.Start,itSize,ExtraSize)
	}
	makeNewItem := !() -> ref T //TODO make it template
	{
		if itSize < ExtraSize
		{
			itSize += 1
			return qArr[itSize - 1]
		}
		itSize += 1
		return subList.Create()
	}
	Push := !(T itm) .{} -> void
	{
		makeNewItem() = itm
	}
	Emplace := !(args...) .{} -> void
	{
		makeNewItem()."this"(args...)
	}
	"[]" := !(int ps) -> ref T
	{
		if ps < ExtraSize
		{
			return qArr[ps]
		}
		return subList[ps - ExtraSize]
	}
	Clear := !() . {} -> void
	{
		itSize = 0
		subList.Clear()
	}
	Destroy := !() .{} -> void
	{
		itSize = 0
		subList.Destroy() //TODO GC
	}
	Size := !() -> int
	{
		return itSize
	}
}
