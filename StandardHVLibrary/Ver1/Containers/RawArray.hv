RawArrayIter := class.{@T}
{
	itPtr := T^
	itSize := int
	itPos := int
	this := !(T^ ptr,int siz) -> void
	{
		itPtr = ptr
		itSize = siz
		itPos = 0
	}
	Inc := !() -> void	{ itPos += 1 }
	"^" := !() -> ref T { return itPtr[itPos] }
	"IsEnd" := !() -> bool { return itPos >= itSize }
}

RawArray := class .{@T}
{
	itPtr := T^
	itSize := int
	itCapacity := int
	this := !() -> void
	{
	}
	Data := !() -> T^ 
	{
		return itPtr
	}
	Reserve := !(int toResrv) -> void
	{
		if itPtr == null or itCapacity < toResrv
		{
			oldPtr := itPtr
			itPtr = new T[toResrv]
			itCapacity = toResrv
			for i : itSize
			{
				itPtr[i] = oldPtr[i]
			}
			if oldPtr != null
				delete oldPtr
		}
	}
	Create := !() -> ref T
	{
		if itPtr == null or itCapacity == itSize
		{
			Reserve(itPtr == null ?: 12 : itCapacity*2) //magic
		}
		return itPtr[itSize++]
	}
	FastRemove := !(int nr) -> void
	{
		assert(nr < itSize)
		assert(nr >= 0)
		if nr != itSize - 1
		{
			memcpy(itPtr[nr]&,itPtr[itSize - 1]&,T->TypeSize)
		}
		itSize -= 1
	}
	Resize := !(int newSize) -> void
	{
		if newSize > itSize
		{
			Reserve(newSize)
		}else{
			//TODO GC remove
		}
		itSize = newSize
	}
	Clean := !() -> void
	{
		itSize = 0
	}
	Size := !() -> int
	{
		return itSize
	}
	Destroy := !() -> void
	{
		if itPtr != null
		{
			delete itPtr
			itPtr = null
			itSize = 0
			itCapacity = 0
		}
	}
	RemoveIf := !(!(T x)& -> bool lambd) -> void
	{
		deleted := 0
		for i : itSize
		{
			if lambd(itPtr[i])
			{
				deleted += 1
			}else{
				if deleted != 0
					itPtr[i - deleted] = itPtr[i]
			}
		}
	}
	"~For" := !() -> RawArrayIter.{T}
	{
		return RawArrayIter.{T}(itPtr,itSize)
	}
}


