AVLSet.{@DATA} := type ContainerCommonSet.{AVLTree,DATA}
RBSet.{@DATA} := type ContainerCommonSet.{RBTree,DATA}
ContainerCommonSet := class .{@TreeType,@DATA}
{
	itTree := TreeType.{DATA}
	itSize := int

	this := !() -> void
	{
		itTree."this"()
		itSize = 0
	}

	"<<" := !(DATA data) .{} self_return 
	{
		Insert(data)
		return this
	}
	Insert := !(DATA dat) .{} -> void
	{
		resl := CommonTreeNode.{DATA}^
		if(itTree.FindOrCreate(dat,resl&))
		{
			resl.data = dat
			itSize += 1
		}
		
	}
	Remove := !(DATA dat) .{} -> void
	{
		resl := itTree.FindNode(dat)
		if resl != null{
			itTree.RemoveNode(resl)
			itSize -= 1
		}
	}
	Contain := !(DATA dat) -> bool
	{
		resl := itTree.FindNode(dat)
		return resl != null
	}
	Contain := !(!(DATA)&->int cmpFunc) -> bool
	{
		return itTree.FindNode(cmpFunc) != null
	}
	"==" := !(ContainerCommonSet.{@AnType,DATA} toCmp) -> bool
	{
		if Size() != toCmp.Size()
			return false
		for it : this
			if not toCmp.Contain(it)
				return false
		return true
	}
	"~For" := !() -> !()&->DATA&
	{
		return _createIterator(false)
	}
	Reverse := fake
	{
		"~For" := !() -> !()& -> DATA&
		{
			return _createIterator(true)
		}
	}
	_createIterator := !(bool reverse) -> !()&->DATA&
	{
		return () ==>[reverse]
		{
			if itSize != 0
			{
				bag := @temp new List.{Tuple.{CommonTreeNode.{DATA}^,bool}}
				bag.EmplaceFront(itTree.Start,true)
				
				while bag.Size() != 0
				{
					node := ref bag.Front()
					if node.1
					{
						subNode := node.0
						bag.Pop()
						if reverse
						{
							bag.EmplaceFront(subNode.Left?,true)
							bag.EmplaceFront(subNode,false)
							bag.EmplaceFront(subNode.Right?,true)
						}else{
							bag.EmplaceFront(subNode.Right?,true)
							bag.EmplaceFront(subNode,false)
							bag.EmplaceFront(subNode.Left?,true)
						}
					}else{
						subNode := node.0
						yield subNode.data
						bag.Pop()
					}
					
				}
			}
		}
	}
	Size := !() -> int { return itSize }
	"in" := !(DATA val) -> bool
	{
		return Contain(val)
	}
}
