"@omp for" := !(fBody) -> void
{
	workId := 0
	TAwaitManyWorks(0,(tId) ==> {
		curId := InterlockAdd(workId,1)
		i := 0
		fBody((x) ==> {
			c := i
			if curId < c
				curId = InterlockAdd(workId,1)
			i += 1
			if curId != c
				return void
			x()
		})
	})
}
"@omp_lines block" := !(func,num) -> void
{
	TAwaitManyWorks(num,(tId) ==> { func(tId) })
}
"@omp call" := !(@LType l) -> LType->ResultType
{
	res := LType->ResultType
	TAwaitWork(() ==> {
		res = l()
	})
	return res
}
"@omp block" := !(lambd) -> void
{
	TAwaitWork(lambd)
}

"@once func" := !(args...) .{@func} -> func->Type->ResultType
{
	called := static false
	res := static func->Type->ResultType
	if called
		return res
	called = true
	res = func(args...)
	return res
}

"@once block" := !(!()&->void lambd,bool called = static false) -> void
{
	if called
		return void
	lambd()
	called = true
}
"@once call" := !(@LType lambd,bool first = static true) -> LType->ResultType
{
	res := static LType->ResultType
	if first {
		res = lambd()
		first = false
	}
	return res
}

"@try_all block" := !(func,num) -> void
{	
	for i : num
	{
		try
		{
			func(i)
		}catch(IException^ e) {}
	}
}
"@try_one block" := !(func,num) -> void
{	
	for i : num
	{
		try
		{
			func(i)
			return void
		}catch(IException^ e) {}
	}
}

"@temp call" := !(@LType lambd) -> LType->ResultType
{
	TempPoolBlock()
	res := lambd()
	if res->Type->Group == "Pointer"
		_tempCallSetAllocator(res^)
	return res
}
_tempCallSetAllocator := !(@T o) -> void
{
	if T->Group == "Class"
	{
		for it,Name : o->Fields
		{
			if Name == "allocator"
			{
				it = gTemporaryPool&
			}else{
				if it->Type->Group == "Class"
				{
					_tempCallSetAllocator(it)
				}
			}
		}
	}
}