
//


pollfd := class 
{
	fd := int
	events := u16
	revents := u16

	"=" := default
}

IN_CHANGE := 2
IN_CLOSE_WRITE := 8
IN_CREATE := 256 
IN_DELETE := 512

inotify_event := class
{
	wd := int
	mask := u32
	cookie := u32
	len := u32
	name := u8[1]
}

AppendClass TaskData
{
	uContext := u8[1024]
	stackPtr := void^
}
AppendClass TaskBox
{
	eventFd := int
	posixPollArr := RawArray.{pollfd}

	pollData := RawArray.{Tuple.{int}}

	startContext := u8[1024]

	ioRing := void^
	ringEventInWork := bool

	osInit := !() -> void
	{
		pollData."this"()
		pollData.Reserve(10)

		posixPollArr."this"()
		posixPollArr.Reserve(10)

		eventFd = eventfd(0,0)
		setPollFd := ref posixPollArr.Create()
		setPollFd.fd = eventFd
		setPollFd.events = 0x01
		pollData.Create().0 = 1

		uring_init()
		ioRing = ur_create() //TODO destroy
		ur_init(128,ioRing,0)
	}
	initedMonitor := bool
	monitorBuffer := u8[]
	monitorFd := int
	monitorWds := AVLMap.{int,Tuple.{MonitorCallback,char^,int}}
	initMonitor := !() -> void
	{
		initedMonitor = true
		pollData.Create().0 = 2

		monitorBuffer = new u8[4096]
		monitorFd = inotify_init()
		setData := ref posixPollArr.Create()
		setData.fd = monitorFd
		setData.events = 0x01
		newPoll := ref pollData.Create()
		newPoll.0 = 2
	}
	checkMonitor := !() -> void
	{
		readRes := read(monitorFd,monitorBuffer->{void^},4096)
		if readRes > 0
		{
			asStruct := monitorBuffer->{inotify_event^}
			if monitorWds.Contain(asStruct.wd)
			{
				nowMon := ref monitorWds[asStruct.wd]
				itLambd := nowMon.0
				newName := (""sbt + nowMon.1 + "/" + asStruct.name[0]&)->{char^}
				if (asStruct.mask and_b nowMon.2 ) != 0
				{
					newMode := 0
					if (asStruct.mask and_b IN_CHANGE) != 0 newMode += M_CHANGED
					if (asStruct.mask and_b IN_CREATE) != 0 newMode += M_CREATED
					if (asStruct.mask and_b IN_DELETE) != 0 newMode += M_DELETED
					itLambd(newName,newMode)
				}
			}
		}
	}
	addMonitor := !(char^ pathName,MonitorCallback callb,int modes,bool isRec) -> void
	{
		if not initedMonitor 
			initMonitor()

		pathAdd := @temp new List.{char^}

		watchMode := 0
		if modes and_b M_CHANGED watchMode += IN_CHANGE
		if modes and_b M_CREATED watchMode += IN_CREATE
		if modes and_b M_DELETED watchMode += IN_DELETE

		pathAdd^ << pathName

		while pathAdd.Size() != 0
		{	
			nowPath := pathAdd.Pop()

			wd := inotify_add_watch(monitorFd,nowPath,watchMode)
			if wd >= 0
			{
				setWds := ref monitorWds[wd]
				setWds.0 = callb
				setWds.1 = StrCopy(nowPath)
				setWds.2 = watchMode
				if isRec
				{
					for subFolder : Path(nowPath)
					{
						if not subFolder.IsFolder() 
							continue
						strBld := ""sbt + nowPath + "/" + subFolder.Name()
						str := @temp strBld.Str()
						pathAdd^ << str
					}
				}
			}
		}
	}
	waitOnMonitor := !() -> bool
	{
		return monitorWds.Size() != 0
	}
	notifyMain := !() -> void
	{
		toWrite := u64
		toWrite = 1
		write(eventFd,toWrite&,8)
	}
	osCreateTask := !(TaskData^ startTask) -> void
	{
		getcontext(startTask.uContext[0]&)
		startTask.stackPtr = malloc(stackSize)
		startTask.uContext[24]&->{u64^}^ = 0
		startTask.uContext[8]&->{void^^}^ = null
		startTask.uContext[16]&->{void^^}^ = startTask.stackPtr
		startTask.uContext[32]&->{u64^}^ = stackSize
		makecontext(startTask.uContext&,ucontextStartTask,0)
	}

	waitIOCounter := int
	waitOnIO := !(!(void^)&->void lambd) -> void
	{
		sqe := ur_get_sqe(ioRing)
		lambd(sqe)
		ur_sqe_set_data(sqe,CurrentTask)
		waitIOCounter += 1
		switchToMain()
		waitIOCounter -= 1
	}
	taskWaitSleep := !(double sleepTime) -> void
	{
		if not ringEventInWork
		{
			sqe := ur_get_sqe(ioRing)
			ur_sqe_poll_add(sqe,eventFd,0x01) //TODO POLLIN unconst
			ur_sqe_set_data(sqe,eventFd&)
			ur_submit(ioRing)
			ringEventInWork = true
		}

		cqe := void^
		res := ur_wait_cqe_timeout(ioRing,cqe&->{void^^},sleepTime)

		if res == -62 // timer expired
			return void

		data := ur_cqe_get_data(cqe)

		if data == eventFd&
		{
			toRd := u64
			read(eventFd,toRd&,8)
			ringEventInWork = false
		}else
		{
			tasksToExe.Push(data)
		}
		ur_cqe_seen(ioRing,data)

		return void
	}
	osSwitchToMain := !() -> void
	{
		swapcontext(CurrentTask.uContext&,startContext)
	}
	osDoTask := !(TaskData^ toRun) -> void
	{
		swapcontext(startContext&,toRun.uContext&)
	}
	osDestroy := !() -> void
	{
		ur_exit(ioRing)
		ur_destroy(ioRing)

		posixPollArr.Destroy()
		delete itStacks[^]
		itStacks.Destroy()
	}
}
