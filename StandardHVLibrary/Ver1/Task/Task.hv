
TITaskPausePoint := class
{
	itTask := TaskData^	
	next_point := TITaskPausePoint^
	Pause := !(TITaskPausePoint^^ nextPoint) -> void
	{
		if nextPoint^ != null
		{
			next_point = nextPoint^
		}
		nextPoint^ = this&
		itTask = CurrentTask
		CurrentTaskBox.switchToMain()
		if next_point != null
			next_point.Resume()
	}
	Resume := !() -> void
	{
		if CurrentTaskBox.pausePoint != null
		{
			itr := next_point
			while itr.next_point != null
				itr = itr.next_point
			itr.next_point.next_point = CurrentTaskBox.pausePoint
		}
		CurrentTaskBox.pausePoint = this&
	}
}

THatch := class
{
	flag := bool
	next_wakeup := TITaskPausePoint^

	Emit := !() -> void
	{
		flag = true
		if next_wakeup != null
		{
			next_wakeup.Resume()
		}
	}
	Await := !() -> void
	{
		if flag
			return void
		pt := TITaskPausePoint
		pt.Pause(next_wakeup&)
	}
}

CurrentTask := thread_local TaskData^
CurrentTaskBox := thread_local TaskBox^
TaskData := class
{
	tskToRun := !()& -> void
	keepStack := bool
	taskLocalPtr := void^
}

TaskKeepStackData := !() -> void
{
	assert(CurrentTaskBox != null)
	CurrentTaskBox.TaskKeepStackData()
}


TaskBox := class extend TGCObject
{
	firstRunTasks := List.{TaskData^}
	itStacks := List.{void^}
	keptStacks := List.{void^} 

	stackSize := int

	itMutex := Mutex

	tasksToExe := List.{TaskData^}

	destroyTasks := List.{TaskData^}

	pausePoint := TITaskPausePoint^

	working := bool

	this := !(int sSize) -> void
	{
		stackSize = sSize
		itMutex."this"()
		itWorkMutex."this"()
		itWorkConVar."this"()
		itWorkCount = 0

		osInit()
		working = true
	}
	
	TaskKeepStackData := !() -> void
	{
		CurrentTask?.keepStack = true
	}

	pausedIdIter := int
	pausedProcesses := RBMap.{int,TaskData^}
	PauseTask := !(int^ resId) -> void
	{
		pausedIdIter += 1
		while pausedIdIter in pausedProcesses
			pausedIdIter += 1
		resId^ = pausedIdIter
		pausedProcesses[pausedIdIter] = CurrentTask
		switchToMain()
	}
	ResumeTask := !(int procToken) -> void
	{
		if procToken in pausedProcesses
		{
			tasksToExe << pausedProcesses[procToken]
			pausedProcesses.Remove(procToken)
		}
	}
	Spawn := !(!()&->void tskToRun) -> void
	{
		nwTask := new TaskData
		nwTask.tskToRun = tskToRun.Capture()
		firstRunTasks << nwTask
	}

	
	switchToMain := !() -> void
	{
		_TaskPtrReset()
		osSwitchToMain()
	}
	doTask := !(TaskData^ toRun) -> void
	{
		CurrentTask = toRun
		_TaskPtrSet(toRun.taskLocalPtr)
		osDoTask(toRun)
	}
	onDestroyTask := !(TaskData^ toDestr) -> void
	{
		itMutex.Lock()
		destroyTasks << toDestr
		itMutex.Unlock()
		//TODO
		//delete toDestr
	}
	Quit := !() -> void
	{
		working = false
		notifyMain()
	}
	Run := !() -> void
	{
		
		CurrentTaskBox = this&
		working = true
		while working
		{
			makeWait := false
			waitTime := double
			toDoTask := TaskData^()

			itMutex.Lock()

			monitorPushWork()

			if destroyTasks.Size() != 0
			{
				for it : destroyTasks
				{
					if it.keepStack
					{
						if $posix keptStacks.Push(it.stackPtr)
						if $win32 keptStacks.Push(it.fiber)
						delete it.taskLocalPtr
						delete it
						continue
					}
					it.tskToRun.Destroy()
					if $posix
					{
						itStacks.Push(it.stackPtr)
					}
					if $win32
					{
						DeleteFiber(it.fiber)
					}
					delete it.taskLocalPtr
					delete it
				}
				destroyTasks.Clear()
			}

			toDoTask = checkCreateTask()

			if toDoTask == null and pausePoint != null
			{
				toDoTask = pausePoint.itTask
				pausePoint = null
			}

			if toDoTask == null
			{
				toDoTask = checkTimers(makeWait&,waitTime&)
				if toDoTask == null
				{
					toDoTask = checkExeWorks()
					if toDoTask == null
					{
						toDoTask = checkYields();
					}
				}
			}

			if toDoTask != null
			{
				itMutex.Unlock()
				doTask(toDoTask)
				continue
			}

			if not makeWait and (itWorkCount != 0 or waitOnMonitor() or waitIOCounter != 0)
			{
				makeWait = true
				waitTime = 1
			}

			if makeWait
			{
				//itConVar.WaitFor(itMutex&,waitTime)
				itMutex.Unlock()
				taskWaitSleep(waitTime)
				continue
			}
			itMutex.Unlock()
			break
		}
		CurrentTask = null
		CurrentTaskBox = null

		itWorkMutex.Lock()
		working = false
		itWorkConVar.NotifyAll()
		itWorkMutex.Unlock()
	}
	checkCreateTask := !() -> TaskData^
	{
		if firstRunTasks.Size() == 0
			return null

		startTask := firstRunTasks.Pop()

		osCreateTask(startTask)
		startTask.taskLocalPtr = calloc(_getTaskStructSize(),1)
		_taskInitMem(startTask.taskLocalPtr)
		return startTask
	}
	Destroy := virtual !() -> void
	{
		working = false
		osDestroy()
		firstRunTasks.Destroy()
		threadPoolStop()
		tasksToExe.Destroy()
		destroyTimer()
		delete destroyTasks[^]
		destroyTasks.Destroy()
	}
}
CreateTaskBox := !(int stackSize) -> TaskBox^
{
	return new TaskBox(stackSize)
}

ucontextStartTask := !(void^ fiberData) -> void
{
	CurrentTask.tskToRun()
	CurrentTaskBox.onDestroyTask(CurrentTask)
	gTemporaryPool.Destroy()
	CurrentTaskBox.switchToMain()
}
