TaskBoxWorkInterface := class extend TGCObject
{
	DoJob := virtual !(Mutex^ m,TaskBox^ tb) -> void { m.Unlock() }
	IsLast := virtual !() -> bool { return true }
}

TaskBoxSingleWork := class extend TaskBoxWorkInterface
{
	lambda := !()&->void
	taskData := TaskData^

	this := !(!()&->void l, TaskData^ d) -> void
	{
		lambda = l
		taskData = d
	}
	DoJob := virtual !(Mutex^ m,TaskBox^ tb) -> void {
		m.Unlock()
		lambda()
		tb._workUnlockTask(taskData)
	}
	IsLast := virtual !() -> bool { return true }
}
TaskBoxManyWork := class extend TaskBoxWorkInterface
{
	lambda := !(int)&->void
	taskData := TaskData^
	currentNum := int
	maxNum := int
	doneNum := int

	this := !(!(int)&->void l, TaskData^ d,int mn) -> void
	{
		lambda = l
		taskData = d
		maxNum = mn
	}
	DoJob := virtual !(Mutex^ m,TaskBox^ tb) -> void {
		val := currentNum
		currentNum += 1
		m.Unlock()
		lambda(val)

		InterlockAdd(doneNum,1)
		if doneNum == maxNum
		{
			tb._workUnlockTask(taskData)
		}
	}
	IsLast := virtual !() -> bool { return currentNum + 1 >= maxNum }
}

AppendClass TaskBox
{
	itWorkMutex := Mutex
	itWorkConVar := ConVar
	itWorkToDo := List.{TaskBoxWorkInterface^}
	itWorkCount := int
	poolThread := List.{Thread^}
	
	ExpectWorkers := !(int expects) -> void
	{
		diffWorks := expects - poolThread.Size()
		if diffWorks <= 0
			return void
			
		for i : diffWorks
		{
			newThread := new Thread(() ==> {
				while working
				{
					itWorkMutex.Lock()

					if itWorkToDo.Size() != 0
					{
						work := itWorkToDo.Front()
						isLast := work.IsLast()
						
						if isLast
						{
							itWorkToDo.Pop()
						}

						work.DoJob(itWorkMutex&,this&)
						FlushTempMemory()
					}else{
						if not working
						{
							itWorkMutex.Unlock()
							return void
						}
						itWorkConVar.Wait(itWorkMutex&)
						itWorkMutex.Unlock()
					}
				}
			})
			itMutex.Lock()
			poolThread << newThread
			itMutex.Unlock()
		}
	}
	AwaitWork := !(!()&->void lambd) -> void
	{
		_addWork(new TaskBoxSingleWork(lambd,CurrentTask))
		switchToMain()
	}
	AwaitManyWorks := !(int num,!(int)&->void lambd) -> void
	{
		if num == 0
			num = poolThread.Size()
		_addWork(new TaskBoxManyWork(lambd,CurrentTask,num))
		switchToMain()
	}
	_addWork := !(TaskBoxWorkInterface^ newWork) -> void
	{
		ExpectWorkers(1)
		itWorkMutex.Lock()
		itWorkCount += 1
		itWorkToDo.Push(newWork)
		itWorkConVar.NotifyAll()
		itWorkMutex.Unlock()
	}
	_workUnlockTask := !(TaskData^ tsk) -> void
	{
		itMutex.Lock()
		tasksToExe << tsk
		notifyMain()
		itMutex.Unlock()
	}
	threadPoolStop := !() -> void
	{
		itWorkConVar.NotifyAll()
		poolThread[^].Join()
		delete poolThread[^]
		poolThread.Destroy()
	}

	checkExeWorks := !() -> TaskData^
	{
		if tasksToExe.Size() == 0
			return null

		return tasksToExe.Pop()
	}
}
