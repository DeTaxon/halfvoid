

VulkanShaderLoader := class
	#LazyClass()
{
	inputTypes := AVLMap.{Str,TShaderInput^}

	hotloadNames := vShader^[Str]
	// hotloadedShaders := TShaderInput^[Blob^]
	changedFiles := Str[]

	SetInput := !(Str name,TShaderInput^ model) -> void
	{
		inputTypes[name] = model
	}
	LoadShader := !(Str shaderInfo, bool ignoreHotload = false) -> vShader^
	{
		fil := FSGetFile(shaderInfo)
		flMap := fil.GetMap()
		js := new Json

		js.ParseString(flMap.Get()->{char^},flMap.Size())

		shaderType := TShaderInput^

		vertName := StringSpan
		fragName := StringSpan
		for nd, nodeName : js^
		{
			switch nodeName
			{
				case "type"
					if not inputTypes.Contain(nd.Value())
						return null
					shaderType = inputTypes[nd.Value()]
				case "vertex"
					vertName = nd.Value()
				case "fragment"
					fragName = nd.Value()
				case void
					assert(false) //TODO emit exception
			}
		}

		vertBlob := fil.GetFile(vertName).GetBlob()
		fragBlob := fil.GetFile(fragName).GetBlob()

		result = shaderType.CreateShader(vertBlob,fragBlob)

		// if #DebugMode() // TODO weakly check SetFolderHotload
		if not ignoreHotload
		{
			hotloadNames[fil.GetFile(vertName).GetPath()] = result
			hotloadNames[fil.GetFile(fragName).GetPath()] = result
		}
	}
	LoadComputeShader := !(VulkanDefaultInstance^ inst,TShaderInput^ pass,Str vertName, bool ignoreHotload = false) -> vShader^
	{
		vertBlob := FSGetFile(vertName).GetBlob()

		shdr2 := LoadShaderModule3(inst,vertBlob)

		cSS := VkPipelineShaderStageCreateInfo()
		cSS.stage = VK_SHADER_STAGE_COMPUTE_BIT
		cSS.module = shdr2.itModule
		cSS.pName&->{void^^}^ = "main"

		createInfo := VkComputePipelineCreateInfo()
		createInfo.layout = pass.itLayout
		memcpy(createInfo.stage&,cSS&,VkPipelineShaderStageCreateInfo->TypeSize)

		result = new vShader
		result.itLayout = pass.itLayout
		result.itPass = pass
		inst.Funcs.vkCreateComputePipelines(inst.LogicalDevice,null,1,createInfo&,null,result.itPipe&)

		// if #DebugMode() // TODO weakly check SetFolderHotload
		if not ignoreHotload
			hotloadNames[vertName] = result
	}

	SetFolderHotload := !(Str folderPath) -> void
	{
		TSpawnTask(() ==> [folderPath] {
			AsyncMonitorFolderNonStop(folderPath,true, (x,t) ==> {
				printf("test %s\n",x.GetPath())
				changedFiles.Push(x.GetPath().CStr())
			})
		})

	}

	UpdateShaders := !(VulkanDefaultInstance^ inst) -> void
	{
		if changedFiles.Size() != 0
		{
			inst.Funcs.vkQueueWaitIdle(inst.DrawQueue)

			for file : changedFiles
			{
				if not hotloadNames.Contain(file)
					continue

				sh := ref hotloadNames[file]
				newShdr := vShader^

				if file.End == ".vert" or file.End == ".frag"
				{
					newName := StrConcat(file[0..-4],"json")

					newShdr = LoadShader(newName,true)
					// printf("changed cc %s\n",newName)
				}

				if file.End == ".comp"
				{
					newShdr = LoadComputeShader(inst,sh.itPass,file,true)

					// TODO delete old shader
				}

				if newShdr != null
				{
					sh.itPass = newShdr.itPass
					sh.itPipe = newShdr.itPipe
					sh.itLayout = newShdr.itLayout
				}
			}

			inst.Funcs.vkQueueWaitIdle(inst.DrawQueue)

			changedFiles.Destroy()
		}
	}
}
