Vector := class .{@T} extend TArrayView.{T}
{
	itPointer := T^
	itSize := int
	itCapacity := int
	isBorrowed := bool

	this := !(int count) -> void
	{
		Resize(count)
	}
	"[]" := virtual !(int i) -> ref T
	{
		return itPointer[i]
	}
	Size := virtual !() -> int
	{
		return itSize
	}
	Push := !(T x) -> void
	{
		if itCapacity == 0
		{
			Reserve(16) // random number
		} else if itSize == itCapacity
		{
			Reserve(itSize*3)
		}
		this[itSize++] = x
	}
	Emplace := !(args...) -> void
	{
		if itCapacity == 0
		{
			Reserve(16) // random number
		} else if itSize == itCapacity
		{
			Reserve(itSize*3)
		}
		this[itSize++]."this"(args...)
	}
	Resize := !(int count, bool dirty = false) -> void
	{
		if count <= itSize
		{
			itSize = count
			return void
		}

		Reserve(count,dirty)

		itSize = count
	}
	Reserve := !(int count, bool dirty = false) -> void
	{
		if count <= itCapacity
			return void

		alc := GetAllocator()

		newPointer := alc.AllocMem(count*T->TypeSize,false)->{T^}

		if T->TypeGroup == "Class"
		{
			for i : count
			{
				internalHVInitClass(newPointer[i])
			}
		}

		for i : itSize
		{
			newPointer[i] = itPointer[i]
		}

		if not isBorrowed
			delete itPointer
		isBorrowed = false
		itPointer = newPointer

		itCapacity = count

	}


	GetPointer := virtual !() -> T^
	{
		return itPointer
	}

	Destroy := virtual !() -> void
	{
		if itPointer != null
		{
			if not isBorrowed
				GetAllocator().FreeMem(itPointer)
			isBorrowed = false
			itPointer = null
		}
		itSize = 0
	}

	"for" := !() -> HVFixedArrayIterator.{T}
	{
		result.pointer = GetPointer()
		result.size = Size()
	}
}

HVFixedArrayIterator := class .{@T}
{
	pointer := T^
	size := int
	ind := int
	"()" := !() -> ref T
	{
		result = pointer[ind]&
		ind += 1
	}
	HaveValue := !() -> bool
	{
		result = ind < size
	}
}

"->{}" := !(Vector.{@T} ve) .{T^} -> T^
{
	return ve.Get()
}


"->{}" := !(@T[@size] x) .{Vector.{T}} -> Vector.{T}
{
	result.itPointer = x
	result.itSize = size
	result.itCapacity = size
	result.isBorrowed = true
}
"->{}" := !(@Typ[@Size] itArr) .{@Typ[]} -> Vector.{Typ}
{
	result.itPointer = itArr
	result.itSize = Size
	result.itCapacity = Size
	result.isBorrowed = true
}

MakeVectorOnStack := !(T[Size] buf = #Var) . {@T,@Size} -> Vector.{T}
{
	result.itPointer = buf[0]&
	result.itSize = 0
	result.itCapacity = Size
	result.isBorrowed = true
}
MakeVectorSpanOnPtr := !(@T^ buf, int size) -> Vector.{T}
{
	if buf == null
		size = 0
	result.itPointer = buf
	result.itSize = size
	result.itCapacity = size
	result.isBorrowed = true
}
