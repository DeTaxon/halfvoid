


vZipEntry := class
{
	ptrToObj := ZipFile^
	offset := int
	realSize := u32
	zipSize := u32
	objName := StringSpan
	fullName := StringSpan
	comprType := int
	subFolders := List.{vZipEntry^}
	//compressedPointer := void^

	"this" := !() -> void {}

	Size := !() -> size_t
	{
		return realSize
	}
	Name := !() -> StringSpan
	{
		return objName
	}
	Path := !() -> StringSpan
	{
		return fullName
	}

	GetMap := !() -> FileView^
	{
		if comprType == 8
		{
			compressedPointer := malloc(realSize)
			resPtr := ptrToObj.asMapped.point[offset]&

			CrappyDeflateInflate(resPtr,zipSize,compressedPointer->{u8^},realSize)
			return new ZipFSFileViewZipDeflate(this&,compressedPointer->{u8^},realSize)
		}

		assert(comprType == 0)

		resPtr := ptrToObj.asMapped.point[offset]&
		return new ZipFSFileViewZipStore(this&,resPtr,realSize)
	}

	Print := !(int de) -> void
	{
		for i : de printf("-")

		printf("%s %i %i %i\n",objName.GetString().Str(),realSize,zipSize,comprType)
		subFolders[^].Print(de+1)
	}
}
ZipFile := class extend TGCObject
{
	examined := bool
	asMapped := MappedFile
	fileName := String^

	zipRoot := vZipEntry

	this := !() -> void
	{
		zipRoot.objName = StringSpan("/")
		zipRoot.ptrToObj = this&
	}
	GetFile := !(char^ fileNameI) -> vZipEntry^
	{
		itr := zipRoot&
		StringSpan(fileNameI).DivideStr("\\/",x ==> {

			if itr == null
				return void

			for subs : itr.subFolders
			{
				if subs.objName == x
				{
					itr = subs
					return void
				}
			}
			itr = null
		})

		return itr
	}
		

	AnalizeFile := !(StringView fileToLoad) -> bool
	{
		fileName = fileToLoad.GetString()

		asMapped.Open(fileName.Str())
		ptrToFl := asMapped.point
		eod := ptrToFl[asMapped.Size() - zipEndOfDirectory->TypeSize]&->{zipEndOfDirectory^}

		if eod.signature != 0x06054b50
		{
			return false
		}

		tableCount := eod.numberOfCentralDirectoryHere
		cdTable := ptrToFl[eod.offsetToStartOfCD]&->{zipCentralDirectory^}
	

		for i : tableCount
		{	
			ptrToStr := cdTable[1]&->{char^}
			newStr := StringSpan(ptrToStr,cdTable.fileNameLen)

			if newStr[-1..0] == "/"
			{
				cdTable = cdTable->{u8^}[zipCentralDirectory->TypeSize 
				+ cdTable.fileNameLen 
				+ cdTable.extraFieldsLen
				+ cdTable.commentLen
				]&->{zipCentralDirectory^}
				continue
			}

			fldrs := List.{StringSpan}
			newStr.DivideStr("/", x ==> { fldrs.Push(x)})
			itmIter := zipRoot&

			for itm,j : fldrs
			{	
				found := false
				for it : itmIter.subFolders
				{
					if itm == it.objName
					{
						itmIter = it
						found = true
						break
					}
				}
				if not found 
				{
					itmIter.subFolders.Push(new vZipEntry)
					nI := itmIter.subFolders[-1]
					nI.ptrToObj = this&
					nI.objName = itm
					nI.fullName = newStr

					if  j == fldrs.Size() - 1
					{
						nI.realSize = cdTable.realSize
						nI.zipSize = cdTable.compressedSize
						nI.comprType = cdTable.compressionMethod

						ptTH := ptrToFl[cdTable.offsetToFileHeader]&->{zipFileHeader^}

						nI.offset = cdTable.offsetToFileHeader + zipFileHeader->TypeSize + ptTH.fileNameLen + ptTH.extraFieldsLen
					}else{
						itmIter = nI
					}
				}
			}

			cdTable = cdTable->{u8^}[zipCentralDirectory->TypeSize 
			+ cdTable.fileNameLen 
			+ cdTable.extraFieldsLen
			+ cdTable.commentLen
			]&->{zipCentralDirectory^}
		}
		return true
	}

}
// ZipConCat := !(char^ inpFileI,char^ zipFileI, char^ outFileI) -> void
// {
// 	inpFile := MappedFile(inpFileI)
// 	defer inpFile.Close()

// 	zipFile := MappedFile(zipFileI)
// 	defer zipFile.Close()

// 	inpSize := inpFile.Size()
// 	zipSize := zipFile.Size()
// 	totalSize := inpSize + zipSize
// 	outFile := TFile(outFileI,"wb")//MappedFile(outFileI,FILE_CREATE,totalSize)
// 	defer outFile.Close()
// 	outFile.Write(inpFile.point,inpSize)

// 	eod := zipFile.point[zipFile.Size() - zipEndOfDirectory->TypeSize]&->{zipEndOfDirectory^}

// 	ignores := @temp new List.{void^}
// 	ignores.Push(eod.offsetToStartOfCD&)

// 	filesCount := eod.numberOfCentralDirectoryHere
// 	cdTable := zipFile.point[eod.offsetToStartOfCD]&->{zipCentralDirectory^}
// 	for i : filesCount
// 	{
// 		ignores.Push(cdTable.offsetToFileHeader&)
// 		cdTable = cdTable->{u8^}[zipCentralDirectory->TypeSize 
// 			+ cdTable.fileNameLen 
// 			+ cdTable.extraFieldsLen
// 			+ cdTable.commentLen
// 			]&->{zipCentralDirectory^}
// 	}
// 	endOfPoint := zipFile.point[zipSize]&
// 	startPoint := zipFile.point->{u8^}
// 	for ignores.Size() + 1
// 	{
// 		metIgnore := false
// 		maxValue := endOfPoint
// 		for it : ignores^
// 		{
// 			if it < startPoint
// 				continue
// 			if it < maxValue
// 			{
// 				maxValue = it
// 				metIgnore = true
// 			}
// 		}
// 		toWrite := maxValue - startPoint
// 		outFile.Write(startPoint,toWrite)
// 		startPoint = startPoint[toWrite]&
// 		if metIgnore{
// 			offstValue := startPoint->{u32^}^
// 			offstValue += inpSize
// 			startPoint = startPoint[4]&
// 			outFile.Write(offstValue&,4)
// 		}
// 	}
// }

// ZipAppend := !(char^ inpFile,List.{char^} toAdd) -> void
// {
// 	TempPoolBlock()

// 	ownFile := MappedFile(inpFile)

// 	aFF := List.{MappedFile}()
// 	aFa := List.{List.{zipIntEntry}}()
// 	for it : toAdd
// 	{
// 		aFF.Emplace(it)
// 		aFa.Emplace()
// 		if not ZipParse(aFF.Back().Get(),aFF.Back().Size(),aFa.Back())
// 			throw new Exception(0,"failed loading zip file")
// 	}
// 	meAsZP := List.{zipIntEntry}()
// 	itZip := ZipParse(ownFile.Get(),ownFile.Size(),meAsZP)

// 	oldZipCDData := List.{char[]}()
	
// 	newSize := ownFile.Size()
// 	oldSize := newSize


// 	if not itZip 
// 	{
// 		newSize += zipEndOfDirectory->TypeSize
// 	}else{
// 		for meAsZP
// 		{
// 			preAdd := new char[it.cdEntrySize]
// 			memcpy(preAdd->{void^},ownFile.Get()->{u8^}[it.offsetToCDEntry]&,it.cdEntrySize)
// 			oldZipCDData.Push(preAdd)
// 			it.fileName = StringSpan(it.fileName.Str())
// 		}
// 	}
	
// 	preAdd := AVLSet.{StringSpan}()
// 	preAdd.Insert(meAsZP[^].fileName)

// 	for it : aFa
// 	{
// 		for entr : it
// 		{
// 			if preAdd.Contain(entr.fileName)
// 				continue
// 			preAdd.Insert(entr.fileName)
// 			newSize += entr.fhSize
// 			newSize += entr.cdEntrySize
// 			newSize += entr.dataSize
// 		}
// 	}
// 	if newSize == oldSize
// 		return void
	
// 	ownFile.Close()
// 	ownFile.Open(inpFile,FILE_WRITE,newSize)
	
// 	writeIter := u8^

// 	if itZip {
// 		writeIter = ownFile.Get()->{u8^}[meAsZP.Front().offsetToCDEntry]&
// 	}else{
// 		writeIter = ownFile.Get()->{u8^}[oldSize]&
// 	}
// 	fileStart := ownFile.Get()
// 	preAdd2 := AVLSet.{StringSpan}()
// 	for meAsZP preAdd2.Insert(it.fileName)
// 	for fils : aFa, itMap : aFF
// 	{
// 		for fils
// 		{
// 			if it.offsetToData == 0
// 				continue
// 			if preAdd2.Contain(it.fileName)
// 				continue
// 			preAdd2.Insert(it.fileName)
// 			newOffset := writeIter&->{u64^}^ - fileStart&->{u64^}^
// 			memcpy(writeIter,itMap.Get()[it.offsetToFileHeader]&,it.dataSize + it.fhSize)
// 			writeIter = writeIter[it.dataSize + it.fhSize]&
// 			it.offsetToFileHeader = newOffset
// 		}
// 	}
// 	preAdd3 := AVLSet.{StringSpan}()
// 	for meAsZP preAdd3.Insert(it.fileName)

// 	startOfCD := writeIter

// 	entrs := 0
// 	entrsSize := 0
// 	for it : meAsZP, oldD : oldZipCDData
// 	{
// 		memcpy(writeIter,oldD->{void^},it.cdEntrySize)
// 		if it.offsetToData != 0
// 			writeIter->{zipCentralDirectory^}.offsetToFileHeader = it.offsetToFileHeader
// 		writeIter = writeIter[it.cdEntrySize]&
// 		entrs += 1
// 		entrsSize += it.cdEntrySize
// 	}

// 	for fils : aFa, itMap : aFF
// 	{
// 		for fils
// 		{
// 			if preAdd3.Contain(it.fileName)
// 				continue
// 			preAdd3.Insert(it.fileName)
// 			memcpy(writeIter,itMap.Get()[it.offsetToCDEntry]&,it.cdEntrySize)
// 			if it.offsetToData != 0
// 				writeIter->{zipCentralDirectory^}.offsetToFileHeader = it.offsetToFileHeader
// 			writeIter = writeIter[it.cdEntrySize]&
// 			entrs += 1
// 			entrsSize += it.cdEntrySize
// 		}
// 	}
// 	lastData := writeIter->{zipEndOfDirectory^}
// 	memset(lastData,0,zipEndOfDirectory->TypeSize)
// 	lastData.offsetToStartOfCD = startOfCD&->{u64^}^ - fileStart&->{u64^}^ 
// 	lastData.sizeOfCentralDirectoryBytes = entrsSize
// 	lastData.numberOfCentralDirectoryHere = entrs
// 	lastData.totalNumberOfCentralDirectory = entrs
// 	lastData.signature = 0x06054b50
// 	printf("entrys %i\n",entrs)
// }
