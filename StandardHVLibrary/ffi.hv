
CallFunctionPtr := !(void^ fncPtr,int argc, char^ inpInfo, u64^ args, bool retFloat) -> u64
{
	if #OS() == "Linux"
	{
		assert(argc  < 128)

		ints := u64[6]
		floats := u64[8]
		stack := u64[128] //TODO make dirty

		stackSize := u64

		{
			usedInts := 0
			usedFloats := 0
			usedStack := 0
			
			for i : argc
			{
				isFloat := inpInfo[i] == 'f'

				if isFloat and usedFloats < 8
				{
					floats[usedFloats++] = args[i]
				}else if usedInts < 6 {
					ints[usedInts++] = args[i]
				}else{
					stack[usedStack++] = args[i]
				}
			}

			if usedStack mod 2 != 0 //align to 16 bytes
				usedStack += 1

			stackSize = usedStack
		}


		asm(
		"movq %2,%%r11;"
		"movq (%%r11),%%xmm0; addq $8,%%r11;"
		"movq (%%r11),%%xmm1; addq $8,%%r11;"
		"movq (%%r11),%%xmm2; addq $8,%%r11;"
		"movq (%%r11),%%xmm3; addq $8,%%r11;"
		"movq (%%r11),%%xmm4; addq $8,%%r11;"
		"movq (%%r11),%%xmm5; addq $8,%%r11;"
		"movq (%%r11),%%xmm6; addq $8,%%r11;"
		"movq (%%r11),%%xmm7;"

		"movq (%3),%%r11;"
		"movq %4,%%r12;"
		"load_stack_begin%=:"
		"cmp $0,%%r11;"
		"je load_stack_end%=;"
		"pushq (%%r12);"
		"subq $8,%%r12"
		"subq $1,%%r11"
		"jmp load_stack_begin%=;"
		"load_stack_end%=:"

		"movq %1,%%r11;"
		"movq (%%r11),%%rdi; addq $8,%%r11;"
		"movq (%%r11),%%rsi; addq $8,%%r11;"
		"movq (%%r11),%%rdx; addq $8,%%r11;"
		"movq (%%r11),%%rcx; addq $8,%%r11;"
		"movq (%%r11),%%r8; addq $8,%%r11;"
		"movq (%%r11),%%r9;"

		"movq %0,%%r11;"
		"call *%%r11;"
		"movq %%rax,(%1)"
		"movq %%xmm0,(%2)"

		"mov (%3),%%r11;"
		"imul $8,%%r11"
		"addq %%r11,%%rsp"



		:
		: "r"(fncPtr),"r"(ints&),"r"(floats&), "r"(stackSize&), "r"(stack[stackSize - 1]&)
		: "%r11","%r12","%rax","%rdi","%rsi","%rcx","%rdx","%r8","%r9"
		)

		if retFloat
		{
			return floats[0]
		}else{
			return ints[0]
		}

	}else{
		assert(false) // unsoported os
	}
}
