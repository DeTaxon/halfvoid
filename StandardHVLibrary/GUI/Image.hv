ImageColorTypeEnum := enum
{
	"RGB",
	"RGBA"
}

Image := class
{
	Data := u8^
	ColorType := ImageColorTypeEnum
	Width := int
	Height := int

	this := !() -> void
	{
	}

	CreateBlank := !(int w, int h) -> void
	{
		Data = malloc(w*h*4)->{u8^} //TODO layouts RGBA RGB RG R R8 R16 RGB_half_float idk
		Width = w
		Height = h
	}
	GetPointer := !() -> u8^
	{
		return Data
	}
	GetPixelSize := !() -> int
	{
		switch ColorType
		{
		case "RGB"
			return 3
		case "RGBA"
			return 4
		}
	}
	ForEachPixelU8 := !(!(int,int,u8^)&->void cb) -> void
	{
		for i : Height
		{
			for j : Width
			{
				cb(j,i,Data->{u32^}[j + i*Width]&->{u8^})
			}
		}
	}

	ToColorType := !(ImageColorTypeEnum toType) -> Image^
	{
		if toType == ColorType
			return this&

		if toType == "RGBA"
		{
			result = new Image
			result.Width = Width
			result.Height = Height
			result.ColorType = toType

			res := malloc(Width*Height*4)->{u8^}
			memset(res,255,Width*Height*4)

			bpp := GetPixelSize()
			stride := bpp*Width

			for i : Height
			{
				for j : Width
				{
					memcpy(res[j*4 + i*4*Width]&, Data[j*bpp + i*stride]&,3)
				}
			}
			result.Data = res

			return result

		}

		assert(false)
	}

	DrawLine := !(vec2f point1,vec2f point2,Color color) -> void
	{
		if point1.x < 0 or point2.x < 0
			return void
		if point1.y < 0 or point2.y < 0
			return void
		if point1.x >= Width or point2.x >= Width
			return void
		if point1.y >= Height or point2.y >= Height
			return void

		vec := point2 - point1
		x := 500
		for i : 0..x
		{
			proc := i / x

			pos := point1 + vec*proc

			indx := (pos.x->{int} + pos.y->{int}*Width)
			Data[indx*4]&->{Color^}^ = color
		}
	}

	Destroy := virtual !() -> void
	{
		if Data == null
			return void
		free(Data)
		Data = null
	}
}

NewImage_RGBA := !(int w, int h) -> Image^
{
	result = new Image

	result.Data = malloc(w*h*4)->{u8^}
	result.Width = w
	result.Height = h
	result.ColorType = "RGBA"
}
