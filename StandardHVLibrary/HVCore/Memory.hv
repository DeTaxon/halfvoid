internalHVNew := !() .{@T} -> T^
{
	objSize := max(T->TypeSize,1)
	alc := GetAllocator()
	result&->{void^^}^ = alc.AllocMem(max(T->TypeSize,1)) //way to bypass custom setters
	if T->TypeGroup == "Class"
		internalHVInitClass(result^)

	//if #Var("Tracy") and GlobalTracyInUse
	//{
	//	___tracy_emit_memory_alloc_callstack?(result,objSize,62,0)
	//}
}
internalHVNewConstructed := !(@T^ obj, args...) -> T^ //TODO delete after halfvoid updated
{
	result = obj
	result.this(args...)
}

internalHVDelete := !(void^ x) -> void
{
	GetAllocator().FreeMem(x)
}

CurrentAllocator := task_local IAllocator^


MainGC := GCAllocator^
GCPage := PageMemory

InitMainGC := !() -> void
{
	GCPage.Create(GCAllocator->TypeSize,"rw")
	MainGC = GCPage.GetPointer()->{GCAllocator^}
	internalHVInitClass(MainGC^)
	MainGC.StartGCThread()
}
StopMainGC := !() -> void
{
	MainGC.quit = true
	MainGC.gcThread.Join()

}


GetDefaultAllocator := !() -> IAllocator^
	#Mark("JITPass")
{
	if #Var("GC")
	{
		return MainGC
	}else{
		defAlloc := static DefaultAllocator
		return defAlloc&
	}
}

GetAllocator := !() -> IAllocator^
	#Mark("JITPass")
{
	if CurrentAllocator != null
		return CurrentAllocator
	return GetDefaultAllocator()
}

SwapAllocator := !(IAllocator^ alc) -> IAllocator^
	#Mark("JITPass")
{
	result = CurrentAllocator
	CurrentAllocator = alc
}

SetAllocator := !(IAllocator^ alc) -> void
	#Mark("JITPass")
{
	CurrentAllocator = alc
}

