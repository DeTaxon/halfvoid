
AllocatedDataInfo := class
{
	dataSize := u32

	"=" := default
	"<=>" := !(AllocatedDataInfo other) -> int
	{
		return this& <=> other&
	}
}
AllocatedPage := class
{
	page := PageMemory
	usedMem := AVLTree.{AllocatedDataInfo}
	freeMem := AVLTree.{AllocatedDataInfo}

	allocLock := int // atomic lock
}


AllocatedStaticSize := class
{
	page := PageMemory
	allocLock := int

	memLeft := int
	bitIndex := int
	
	bitCount := int
	metaOffset := int
	dataOffset := int
}
AllocatedStaticInfo := class
{
	generation := u8
}
AllocatedStaticPtrInfo := class
{
	IsFound := bool

	BucketIndex := int
	PageIndex := int
	ObjectIndex := int

	Generation := int
}

Allc128 := class .{@ObjSize}
{
	pages128 := AllocatedStaticSize[32]

	AllocMem := !() -> void^
	{
		while true
		{
			for page : pages128
			{
				isSet := InterlockSet(page.allocLock,1)
				
				if isSet == 0
				{
					defer page.allocLock = 0
					ret := allocFromPage(page&)
					memset(ret,0,ObjSize)
					return ret
				}
			}
		}
	}

	allocFromPage := !(AllocatedStaticSize^ page) -> void^
	{
		headerSize := AlignUp16(AllocatedStaticSize->TypeSize)
		bitCount := (4096*32 - headerSize)*8

		// assert((bitCount div 8) + headerSize == 4096)
		assert(bitCount mod 16 == 0)


		if page.page.Size() == 0
		{
			alcSize := headerSize + (bitCount div 8) + bitCount*(AllocatedStaticInfo->TypeSize + ObjSize)
			page.page.Create(alcSize,"rw")

			ptr := page.page.GetPointer()->{AllocatedStaticSize^}
			ptr.memLeft = bitCount

			page.bitCount = bitCount
		}

		ptr := page.page.GetPointer()->{u8^}

		thisInfo := ptr->{AllocatedStaticSize^}

		if thisInfo.memLeft == 0
			return allocFromPage(thisInfo)

		bitPtr := ptr[headerSize]&
		infoPtr := bitPtr[bitCount div 8]&->{AllocatedStaticInfo^}
		blocksPtr := infoPtr[bitCount]&->{u8[ObjSize]^}

		page.metaOffset = infoPtr->{size_t} - ptr->{size_t}
		page.dataOffset = blocksPtr->{size_t} - ptr->{size_t}


		{
			i := page.bitIndex div 8
			j := page.bitIndex mod 8

			bitPtr[i] = bitPtr[i] or_b (1 shl j)

			page.bitIndex += 1
			thisInfo.memLeft -= 1
			return blocksPtr[i*8 + j]&
		}

		assert(false)
	}
	GetMemInfo := !(void^ ptr) -> AllocatedStaticPtrInfo
	{
		for page,i : pages128
		{
			itr := page&
			pageIndex := 0

			while itr != null and itr.page.Size() != 0
			{
				pgPtr := itr.page.GetPointer()->{u8^}
				begin := pgPtr->{u8^}[itr.dataOffset]&
				end := begin[itr.page.Size()]&

				if ptr >= begin and ptr < end
				{
					indx := (ptr->{size_t} - begin->{size_t}) div ObjSize

					result.IsFound = true

					result.BucketIndex = i
					result.PageIndex = pageIndex
					result.ObjectIndex = indx

					result.Generation = pgPtr[page.metaOffset]&->{AllocatedStaticInfo^}[indx].generation

					return void

				}else{
					itr = itr.page.GetPointer()->{AllocatedStaticSize^}
					pageIndex += 1
				}
			}
		}
	}
}

Allc := class extends IAllocator
{

	pages32 := Allc128.{32}
	pages64 := Allc128.{64}
	pages128 := Allc128.{128}

	pages := AllocatedPage[32]

	currentGeneration := u8
	gcThread := Thread

	AllocMem := virtual !(int size, bool dirty = false) -> void^
	{
		size = AlignUp16(size)

		if size <= 32
			return pages32.AllocMem()
		if size <= 64
			return pages64.AllocMem()
		if size <= 128
			return pages128.AllocMem()

		while true
		{
			for page : pages
			{
				isSet := InterlockSet(page.allocLock,1)
				
				if isSet == 0
				{
					defer page.allocLock = 0
					ret := allocFromPage(page&,size)
					if not dirty
						memset(ret,0,size)
					return ret
				}
			}
			//TODO wait, but cant use TaskYield, could be called in TaskCode
			// TaskYield()
		}
	}

	FreeMem := virtual !(void^ mem) -> void
	{

	}

	GetMemInfo := !(void^ mem) -> void
	{
		c := pages32.GetMemInfo(mem)
	}

	allocFromPage := !(AllocatedPage^ page, int size) -> void^
	{

		nodeSize := AlignUp16(CommonTreeNode.{AllocatedDataInfo}->TypeSize)

		if page.page.Size() == 0
		{
			alcSize := 32*1024*1024
			page.page.Create(alcSize,"rw")

			ptr := page.page.GetPointer()

			memset(ptr,0,AllocatedPage->TypeSize)
			internalHVInitClass(ptr->{AllocatedPage^}^)

			baseSize := AlignUp16(AllocatedPage->TypeSize)

			newNode := ptr->{u8^}[baseSize]&->{CommonTreeNode.{AllocatedDataInfo}^}
			newNode.data.dataSize = alcSize - (baseSize + nodeSize)

			page.freeMem.InsertNode(newNode)
		}

		needSize := nodeSize + AlignUp16(size)

		iterStack := CommonTreeNode.{AllocatedDataInfo}^[80]
		iterStack[0] = page.freeMem.Start
		stackSize := 1

		while stackSize != 0
		{
			p := iterStack[stackSize - 1]
			stackSize -= 1

			if p.Right != null
				iterStack[stackSize++] = p.Right
			if p.Left != null
				iterStack[stackSize++] = p.Left

			if p.data.dataSize >= needSize
			{
				res := p->{u8^}[nodeSize + p.data.dataSize - needSize]&
				p.data.dataSize -= needSize

				memset(res,0,nodeSize)
				node := res->{CommonTreeNode.{AllocatedDataInfo}^}
				page.usedMem.InsertNode(node)
				node.data.dataSize = size

				return res[nodeSize]&
			}
				
		}

		return allocFromPage(page.page.GetPointer()->{AllocatedPage^},size)

	}

	GetPointerInfo := !(void^ ptr) -> void
	{
		// actual pointer
		// typeid
		//
	}

	StartGCThread := !() -> void
	{
		gcThread."this"(() ==> [c = this&]{
			c.threadLoop()
		})

	}
	threadLoop := !() -> void
	{
		while true
		{
			currentGeneration += 1

			inf := MainTask.GetStackUsage()

			checkRootRange(inf.StackPointer,inf.TotalSize)

			checkGlobals()
		}
	}

	checkGlobals := !() -> void
	{
		for it : $GlobalVariables
		{
			checkRootRange(it&,it->TypeSize)
		}
	}

	checkRootRange := !(void^ inPtr, size_t size) -> void
	{
		ptr := inPtr->{void^^}
		size = size div 8

		for i : size
		{
			memInf := this.pages32.GetMemInfo(ptr[i])

			if memInf.IsFound
			{
				itr := pages32.pages128[memInf.BucketIndex]&

				for j : (memInf.PageIndex - 1)
					itr = itr.page.GetPointer()->{AllocatedStaticSize^}


				pagePtr := itr.page.GetPointer()->{u8^}

				pagePtr[itr.metaOffset]&->{AllocatedStaticInfo^}[memInf.ObjectIndex].generation = currentGeneration
			}

		}

	}
}
