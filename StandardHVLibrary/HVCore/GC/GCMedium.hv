AllocatedMediumBlock := class
{
	memOffset := int
	memSize := int

	generation := u8

	"=" := default
}

AllocatedPage := class
{
	page := PageMemory

	allocLock := int // atomic lock
}

AllocatedMediumBlockData := class
{
	usedMemTemp := AllocatedMediumBlock[80000]
	ringStart := u32
	ringEnd := u32

	usedMem := AllocatedMediumBlock[80000]
	usedMemCount := int

	freeMem := AllocatedMediumBlock[1024]
	freeCount := int

	createdObjects := int

	sortUsedMem := !() -> void
	{
		// sortPointers(usedMem[0]&,0,usedMemCount - 1)

		for i : usedMemCount
		{
			for j : (i + 1)..(usedMemCount - 1)
			{
				if usedMem[i].0 > usedMem[i].0
				{
					tmp := usedMem[i]
					usedMem[i] = usedMem[j]
					usedMem[j] = tmp
	
				}
			}
		}
	}
	sortPointers := !(AllocatedMediumBlock^ buf,int lo, int hi) -> void
	{
		if hi - lo <= 1
			return void
		mdl := buf[(lo + hi) div 2].0

		i := lo
		j := hi

		while true
		{
			while buf[i].0 < mdl
				i += 1
			while buf[j].0 > mdl
				j -= 1

			if j <= i
				break

			tmp := buf[j]
			buf[j] = buf[i]
			buf[i] = tmp

			i += 1
			j += 1
		}

		sortPointers(buf,lo,j)
		sortPointers(buf, j + 1, hi)
	}
}

AllocatorGCMedium := class
{
	pages := AllocatedPage[32]

	AllocMem := virtual !(int size,u8 generation, bool dirty = false) -> void^
	{
		size = AlignUp16(size)

		while true
		{
			for page : pages
			{
				isSet := InterlockSet(page.allocLock,1)
				
				if isSet == 0
				{
					defer page.allocLock = 0
					ret := allocFromPage(page&,size,generation)
					if not dirty
						memset(ret,0,size)
					return ret
				}
			}
			//TODO wait, but cant use TaskYield, could be called in TaskCode
			// TaskYield()
		}
	}

	allocFromPage := !(AllocatedPage^ page, int size,u8 generation) -> void^
	{
		linkSize := AlignUp16(AllocatedPage->TypeSize)
		blockSize := AlignUp16(AllocatedMediumBlockData->TypeSize)

		if page.page.GetPointer() == null
		{
			alcSize := 64*1024*1024
			page.page.Create(alcSize,"rw")

			ptr := page.page.GetPointer()

			memset(ptr,0,AllocatedPage->TypeSize)
			internalHVInitClass(ptr->{AllocatedPage^}^)

			baseSize := linkSize + blockSize

			dat := page.page.GetPointer()->{u8^}[linkSize]&->{AllocatedMediumBlockData^}

			dat.freeMem[0].memOffset = baseSize
			dat.freeMem[0].memSize = alcSize - baseSize
			dat.freeCount = 1
		}
		
		dat := page.page.GetPointer()->{u8^}[linkSize]&->{AllocatedMediumBlockData^}

		if dat.createdObjects >= dat.usedMemTemp.Size() {
			return allocFromPage(page.page.GetPointer()->{AllocatedPage^},size,generation)
		}

		for i : dat.freeCount
		{
			if dat.freeMem[i].memSize < size
				continue

			block := ref dat.freeMem[i]

			p := page.page.GetPointer()->{u8^}

			res := p[block.memOffset + (block.memSize - size)]&
			block.memSize -= size

			setIndx := InterlockAdd(dat.ringEnd,1) mod dat.usedMemTemp.Size()

			setBlock := ref dat.usedMemTemp[setIndx]

			setBlock.memOffset = res->{size_t} - p->{size_t}
			setBlock.memSize = size
			setBlock.generation = generation

			dat.createdObjects += 1

			return res
		}

		return allocFromPage(page.page.GetPointer()->{AllocatedPage^},size,generation)
	}
	GetMemInfo := !(void^ mem) -> GCMediumMemInfo
	{
		linkSize := AlignUp16(AllocatedPage->TypeSize)
		blockSize := AlignUp16(AllocatedMediumBlockData->TypeSize)

		for page : pages
		{
			itr := page&

			while itr != null
			{
				begin := itr.page.GetPointer()->{u8^}
				end := begin[itr.page.Size()]&

				if begin <= mem and mem < end
					break

				itr = itr.page.GetPointer()->{AllocatedPage^}
			}

			if itr == null continue

			dat := itr.page.GetPointer()->{u8^}[linkSize]&->{AllocatedMediumBlockData^}
			ptr := itr.page.GetPointer()->{u8^}


			// main check
			{
				l := 0
				r := dat.usedMemCount - 1

				while i <= j
				{
					mdl := (l + r) div 2

					memObj := ref dat.usedMem[mdl]
					bb := ptr[memObj.memOffset]&
					be := bb[memObj.memSize]&

					if mem < bb {
						r = mdl - 1
					}else if mem >= be {
						l = mdl + 1
					}else {
						result.IsFound = true
						result.OriginalPointer = bb
						result.GenerationPointer = memObj.generation&
						result.MemSize = memObj.memSize

						return void
					}
				}
			}

			// temp ring
			{
				rb := dat.ringStart mod dat.usedMemTemp.Size()
				re := dat.ringEnd mod dat.usedMemTemp.Size()

				if re < rb
					re += dat.usedMemTemp.Size()

				i := rb
				while i < re
				{
					memObj := ref dat.usedMemTemp[i mod dat.usedMemTemp.Size()]

					bb := ptr[memObj.memOffset]&
					be := bb[memObj.memSize]&

					if bb <= mem and mem < be
					{
						result.IsFound = true
						result.OriginalPointer = bb
						result.GenerationPointer = memObj.generation&
						result.MemSize = memObj.memSize

						return void
					}

					i++
				}
			}
		}
	}
	DeleteOldObjects := !(u8 currentGeneration) -> void
	{
		linkSize := AlignUp16(AllocatedPage->TypeSize)
		blockSize := AlignUp16(AllocatedMediumBlockData->TypeSize)

		for page : pages
		{
			while InterlockSet(page.allocLock,1) == 0 {}

			itr := page&

			while itr != null and itr.page.GetPointer() != null
			{
				pageInfo := itr.page.GetPointer()->{u8^}[linkSize]&->{AllocatedMediumBlockData^}

				if pageInfo.ringStart != pageInfo.ringEnd
				{
					i := pageInfo.ringStart mod pageInfo.usedMemTemp.Size()
					end := pageInfo.ringEnd mod pageInfo.usedMemTemp.Size()

					while i != end
					{
						id := pageInfo.usedMemCount++
						pageInfo.usedMem[id] = pageInfo.usedMemTemp[i]
						i = (i + 1) mod pageInfo.usedMemTemp.Size()
					}

					pageInfo.ringStart = pageInfo.ringEnd

					pageInfo.sortUsedMem()
				}

				i := 0
				while i < pageInfo.usedMemCount
				{
					if pageInfo.freeCount >= pageInfo.freeMem.Size()
						break

					if not GCCheckDistance(pageInfo.usedMem[i].generation,currentGeneration)
					{
						i += 1
						continue
					}

					old := pageInfo.usedMem[i]

					memset(itr.page.GetPointer()->{u8^}[old.memOffset]&,0xdd,old.memSize)
					// pageInfo.usedMem[i] = pageInfo.usedMem[pageInfo.usedMemCount - 1]
					// pageInfo.usedMemCount -= 1
					//
					// pageInfo.freeMem[pageInfo.freeCount++] = old

				}

				i = 0
				while i < pageInfo.freeCount
				{
					if pageInfo.freeMem[i].memSize == 0
					{
						pageInfo.freeMem[i] = pageInfo.freeMem[pageInfo.freeCount -= 1]
					}else{
						i += 1
					}
				}


				itr = itr.page.GetPointer()->{AllocatedPage^}
			}

			InterlockSet(page.allocLock,0)
		}
	}
}

GCMediumMemInfo := class
{
	IsFound := bool 

	OriginalPointer := void^
	GenerationPointer := u8^
	MemSize := int
}
