AllocatedMediumBlock := class
{
	memOffset := int
	memSize := int

	generation := u8

	"=" := default
}

AllocatedPage := class
{
	page := PageMemory

	allocLock := int // atomic lock
}

AllocatedMediumBlockData := class
{
	usedMemTemp := AllocatedMediumBlock[80000]
	ringStart := u32
	ringEnd := u32

	freeMem := AllocatedMediumBlock[1024]
	freeCount := int

	createdObjects := int
}

AllocatorGCMedium := class
{
	pages := AllocatedPage[32]

	AllocMem := virtual !(int size, bool dirty = false) -> void^
	{
		size = AlignUp16(size)

		while true
		{
			for page : pages
			{
				isSet := InterlockSet(page.allocLock,1)
				
				if isSet == 0
				{
					defer page.allocLock = 0
					ret := allocFromPage(page&,size)
					if not dirty
						memset(ret,0,size)
					return ret
				}
			}
			//TODO wait, but cant use TaskYield, could be called in TaskCode
			// TaskYield()
		}
	}

	allocFromPage := !(AllocatedPage^ page, int size,int indx = 0) -> void^
	{
		linkSize := AlignUp16(AllocatedPage->TypeSize)
		blockSize := AlignUp16(AllocatedMediumBlockData->TypeSize)

		if page.page.Size() == 0
		{
			alcSize := 64*1024*1024
			page.page.Create(alcSize,"rw")

			ptr := page.page.GetPointer()

			memset(ptr,0,AllocatedPage->TypeSize)
			internalHVInitClass(ptr->{AllocatedPage^}^)

			baseSize := linkSize + blockSize

			dat := page.page.GetPointer()->{u8^}[linkSize]&->{AllocatedMediumBlockData^}

			dat.freeMem[0].memOffset = baseSize
			dat.freeMem[0].memSize = alcSize - baseSize
			dat.freeCount = 1
		}
		
		dat := page.page.GetPointer()->{u8^}[linkSize]&->{AllocatedMediumBlockData^}

		if dat.createdObjects >= dat.usedMemTemp.Size() {
			return allocFromPage(page.page.GetPointer()->{AllocatedPage^},size)
		}

		for i : dat.freeCount
		{
			if dat.freeMem[i].memSize < size
				continue

			block := ref dat.freeMem[i]

			p := page.page.GetPointer()->{u8^}

			res := p[block.memOffset + (block.memSize - size)]&
			block.memSize -= size

			setIndx := InterlockAdd(dat.ringEnd,1) mod dat.usedMemTemp.Size()

			setBlock := ref dat.usedMemTemp[setIndx]

			setBlock.memOffset = res->{size_t} - p->{size_t}
			setBlock.memSize = size

			dat.createdObjects += 1

			return res
		}

		return allocFromPage(page.page.GetPointer()->{AllocatedPage^},size)
	}
	GetMemInfo := !(void^ mem) -> GCMediumMemInfo
	{
		linkSize := AlignUp16(AllocatedPage->TypeSize)
		blockSize := AlignUp16(AllocatedMediumBlockData->TypeSize)

		for page : pages
		{
			itr := page&

			while itr != null
			{
				begin := itr.page.GetPointer()->{u8^}
				end := begin[itr.page.Size()]&

				if begin <= mem and mem < end
					break

				itr = itr.page.GetPointer()->{AllocatedPage^}
			}

			if itr == null continue

			dat := itr.page.GetPointer()->{u8^}[linkSize]&->{AllocatedMediumBlockData^}
			
			rb := dat.ringStart mod dat.usedMemTemp.Size()
			re := dat.ringEnd mod dat.usedMemTemp.Size()

			if re < rb
				re += dat.usedMemTemp.Size()

			ptr := itr.page.GetPointer()->{u8^}

			i := rb
			while i < re
			{
				bb := ptr[dat.usedMemTemp[i].memOffset]&
				be := bb[dat.usedMemTemp[i].memSize]&

				if bb <= mem and mem < be
				{
					result.IsFound = true
					result.OriginalPointer = bb
					result.GenerationPointer = dat.usedMemTemp[i].generation&
					result.MemSize = dat.usedMemTemp[i].memSize

					return void
				}

				i++
			}
		}
	}
}

GCMediumMemInfo := class
{
	IsFound := bool 

	OriginalPointer := void^
	GenerationPointer := u8^
	MemSize := int
}
