



GCAllocator := class extends IAllocator
{

	pages32 := Allc128
	pages64 := Allc128
	pages128 := Allc128


	memMedium := AllocatorGCMedium

	currentGeneration := u8
	gcThread := BasicThread
	quit := bool

	rootMutex := Mutex
	rootCV := ConVar


	AllocMem := virtual !(int size, bool dirty = false) -> void^
	{
		size = AlignUp16(size)

		if size <= 32
			return pages32.AllocMem()
		if size <= 64
			return pages64.AllocMem()
		if size <= 128
			return pages128.AllocMem()

		return memMedium.AllocMem(size,dirty)
	}

	FreeMem := virtual !(void^ mem) -> void
	{

	}

	GetMemInfo := !(void^ mem) -> GC2MemInfo
	{
		for pg : ![pages32&,pages64&,pages128&]
		{
			c := pg.GetMemInfo(mem)
			if c.IsFound
			{
				result.IsFound = true
				result.OriginalPointer = c.OriginalPointer
				result.GenerationPointer = c.GenerationPointer
				result.MemSize = c.MemSize
				return void
			}
		}

		{
			c := memMedium.GetMemInfo(mem)
			if c.IsFound
			{
				result.IsFound = true
				result.OriginalPointer = c.OriginalPointer
				result.GenerationPointer = c.GenerationPointer
				result.MemSize = c.MemSize
				return void
			}
		}
	}


	GetPointerInfo := !(void^ ptr) -> void
	{
		// actual pointer
		// typeid
		//
	}

	StartGCThread := !() -> void
	{
		gcThread.Start(_callGC2Loop,this&)
	}
	threadLoop := !() -> void
	{
		rootMutex.Lock()
		defer rootMutex.Unlock()

		while not quit
		{
			checkFreeCalls()

			currentGeneration += 1

			for i : RootsCount
			{
				ptr := Roots[i].0
				size := Roots[i].1
				if ptr == null or size == 0
					continue

				checkRootRange(ptr,size)
			}

			checkGlobals()

			for pg : ![pages32&,pages64&,pages128&]
			{
				
			}

			rootCV.WaitFor(rootMutex&,0.1)
		}
	}

	checkDistance := !(u8 left,u8 right) -> bool
	{
		if left == right
			return false
		if left < right
			return right - left > 10
		c := u32
		c = right
		c += 256
		return c - left > 10
	}

	checkGlobals := !() -> void
	{
		for it : $GlobalVariables
		{
			checkRootRange(it&,it->TypeSize)
		}
	}

	checkRootRange := !(void^ inPtr, size_t size) -> void
	{
		ptr := inPtr->{void^^}
		size = size div 8

		for i : size
		{
			memInf := this.GetMemInfo(ptr[i])

			if memInf.IsFound
			{
				if memInf.GenerationPointer^ != currentGeneration
				{
					memInf.GenerationPointer^ = currentGeneration
					checkRootRange(memInf.OriginalPointer,memInf.MemSize)
				}
			}

		}
	}

	freeCalls := void^[512]
	freeCallsStart := u32
	freeCallsEnd := u32

	addFreeCall := !(void^ mem) -> void
	{
		if mem == null
			return void

		ind := InterlockAdd(freeCallsEnd,1) mod freeCalls.Size()
		freeCalls[ind] = mem
	}

	checkFreeCalls := !() -> void
	{
		while freeCallsStart != freeCallsEnd
		{
			ind := freeCallsStart mod freeCalls.Size()

			while freeCalls[ind] == null {}
			c := freeCalls[ind]
			freeCalls[ind] = null

			free(c)

			freeCallsStart += 1
		}
	}

	Roots := Tuple.{void^,size_t}[2048]
	RootsCount := int

	AddRoot := !(void^ mem,size_t size) -> void
	{
		if mem == null or size == 0
			return void

		// rootMutex.Lock()
		// defer rootMutex.Unlock()

		Roots[InterlockAdd(RootsCount,1)] = !{mem,size}
	}
	RemoveRoot := !(void^ mem) -> void
	{
		// rootMutex.Lock()
		// defer rootMutex.Unlock()

		for i : RootsCount
		{
			if Roots[i].0 == mem
			{
				RootsCount -= 1
				if RootsCount != 0
					Roots[i] = Roots[RootsCount]
				Roots[RootsCount].0 = null
				return void
			}
		}
	}

}

_callGC2Loop := !(void^ data) -> void
{
	data->{GCAllocator^}.threadLoop()
}

GC2MemInfo := class
{
	IsFound := bool

	OriginalPointer := void^
	GenerationPointer := u8^
	MemSize := int
}

GCThreadBegin := !() -> void
{
	buf := u8[256]
	pthread_getattr_np(pthread_self(),buf[0]&)

	ptr := void^
	size := size_t
	pthread_attr_getstack(buf[0]&,ptr&,size&)

	MainGC.AddRoot(ptr,size)
}
GCThreadEnd := !() -> void
{
	buf := u8[256]
	pthread_attr_init(buf[0]&)

	ptr := void^
	size := size_t
	pthread_attr_getstack(buf[0]&,ptr&,size&)

	MainGC.RemoveRoot(ptr)
}

MainGC := GCAllocator^
GCPage := PageMemory

InitMainGC := !() -> void
{
	#MarkFunction("ThreadBegin",GCThreadBegin)
	#MarkFunction("ThreadEnd",GCThreadEnd)

	GCPage.Create(GCAllocator->TypeSize,"rw")
	MainGC = GCPage.GetPointer()->{GCAllocator^}
	internalHVInitClass(MainGC^)
	MainGC.pages32.ObjSize = 32
	MainGC.pages64.ObjSize = 64
	MainGC.pages128.ObjSize = 128
	MainGC.StartGCThread()
}
StopMainGC := !() -> void
{
	MainGC.quit = true
	MainGC.gcThread.Join()

}
