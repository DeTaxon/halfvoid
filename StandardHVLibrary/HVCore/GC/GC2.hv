



GCAllocator := class extends IAllocator
{

	pages32 := Allc128
	pages64 := Allc128
	pages128 := Allc128


	memMedium := AllocatorGCMedium

	currentGeneration := u8
	gcThread := BasicThread
	quit := bool

	rootMutex := Mutex
	rootCV := ConVar


	AllocMem := virtual !(int size, bool dirty = false) -> void^
	{
		size = AlignUp16(size)
	
		// if size > 128
		// 	return memMedium.AllocMem(size,dirty)

		// res :=  malloc(size)
		// memset(res,0,size)
		// return res
		if size <= 32
			return pages32.AllocMem()
		if size <= 64
			return pages64.AllocMem()
		if size <= 128
			return pages128.AllocMem()

		return memMedium.AllocMem(size,dirty)
	}

	FreeMem := virtual !(void^ mem) -> void
	{

	}

	GetMemInfo := !(void^ mem) -> GC2MemInfo
	{
		// if false
		{
			for pg : ![pages32&,pages64&,pages128&]
			{
				c := pg.GetMemInfo(mem)
				if c.IsFound
				{
					result.IsFound = true
					result.OriginalPointer = c.OriginalPointer
					result.GenerationPointer = c.GenerationPointer
					result.MemSize = c.MemSize
					return void
				}
			}
		}

		// if false
		{
			c := memMedium.GetMemInfo(mem)
			if c.IsFound
			{
				result.IsFound = true
				result.OriginalPointer = c.OriginalPointer
				result.GenerationPointer = c.GenerationPointer
				result.MemSize = c.MemSize
				return void
			}
		}
	}


	GetPointerInfo := !(void^ ptr) -> void
	{
		// actual pointer
		// typeid
		//
	}

	StartGCThread := !() -> void
	{
		gcThread.Start(_callGC2Loop,this&)
	}
	threadLoop := !() -> void
	{
		rootMutex.Lock()
		defer rootMutex.Unlock()

		prevTime := GetSteadyTime()

		while not quit
		{
			addRootCheck()
			removeRootCheck()
			// checkFreeCalls()

			nowTime := GetSteadyTime()
			if nowTime - prevTime > 5.0
			{
				prevTime = nowTime - 4.0

				currentGeneration += 1
				// printf("wave %i\n",currentGeneration)
				//

				for i : RootsCount
				{
					ptr := Roots[i].0
					size := Roots[i].1
					if ptr == null or size == 0
						continue

					checkRootRange(ptr,size)
				}

				checkGlobals()

				if TaskMainTaskWorker != null
					checkRootRange(TaskMainTaskWorker,TaskWorker->TypeSize)

				for pg : ![pages32&,pages64&,pages128&]
				{
					pg.DeleteOldObjects(currentGeneration)
				}
			}

			rootCV.WaitFor(rootMutex&,0.1)
		}
	}

	checkGlobals := !() -> void
	{
		for it,name : $GlobalVariables
		{
			// printf("name %s\n",name)
			checkRootRange(it&,it->TypeSize)
		}
	}

	checkRootRange := !(void^ inPtr, size_t size) -> void
	{
		ptr := inPtr->{void^^}
		size = size div 8

		for i : size
		{
			if ptr[i] == null
				continue
			memInf := this.GetMemInfo(ptr[i])

			if memInf.IsFound
			{
				if memInf.GenerationPointer^ != currentGeneration
				{
					memInf.GenerationPointer^ = currentGeneration
					checkRootRange(memInf.OriginalPointer,memInf.MemSize)
				}
			}
		}
	}

	// freeCalls := void^[2048]
	// freeCallsStart := u32
	// freeCallsEnd := u32
	//
	// addFreeCall := !(void^ mem) -> void
	// {
	// 	if mem == null
	// 		return void
	//
	// 	// rootMutex.Lock()
	// 	// defer rootMutex.Unlock()
	// 	//
	// 	// free(mem)
	// 	//
	// 	// return void
	// 	assert(CyclicDistance(freeCallsStart,freeCallsEnd,freeCalls.Size()) < 1024)
	//
	// 	ind := InterlockAdd(freeCallsEnd,1) mod freeCalls.Size()
	// 	freeCalls[ind] = mem
	// }

	// checkFreeCalls := !() -> void
	// {
	// 	// return void
	// 	while freeCallsStart != freeCallsEnd
	// 	{
	// 		ind := freeCallsStart mod freeCalls.Size()
	//
	// 		while freeCalls[ind] == null {}
	// 		c := freeCalls[ind]
	// 		freeCalls[ind] = null
	//
	// 		free(c)
	//
	// 		freeCallsStart += 1
	// 	}
	// }

	Roots := Tuple.{void^,int,bool}[2048]
	RootsCount := int

	AddRootsBuf := Tuple.{void^,int,bool}[512]
	AddRootsBufIsSet := u8[512]
	AddRootsStart := u32
	AddRootsEnd := u32

	addRootCheck := !() -> void
	{
		left := AddRootsStart mod AddRootsBuf.Size()
		right := AddRootsEnd mod AddRootsBuf.Size()

		if left > right
			right += AddRootsBuf.Size()

		// printf("test %i\n",CyclicDistance(AddRootsStart,AddRootsEnd,AddRootsBuf.Size()))

		while left != right
		{
			// printf("called\n")
			assert(RootsCount < Roots.Size() - 100)
			ind := left mod AddRootsBuf.Size()

			while AddRootsBufIsSet[ind] == 0 {}

			Roots[RootsCount++] = AddRootsBuf[ind]

			InterlockSet(AddRootsBufIsSet[ind],0)

			left += 1
			AddRootsStart += 1
		}
	}
	AddRoot := !(void^ mem,int size, bool freeOnRemove = false) -> void
	{
		// printf("Add %p\n",mem)
		if mem == null or size == 0
			return void

		while CyclicDistance(AddRootsStart,AddRootsEnd,AddRootsBuf.Size()) > 128 {
			rootCV.Notify()
		}

		ind := InterlockAdd(AddRootsEnd,1) mod AddRootsBuf.Size()

		AddRootsBuf[ind] = !{mem,size,freeOnRemove}

		InterlockSet(AddRootsBufIsSet[ind],1)

		rootCV.Notify()
	}

	
	RemRootInd := int
	RemRootBufs := RemRootBufType[2]

	removeRootCheck := !() -> void
	{
		nowBuf := ref RemRootBufs[RemRootInd]

		if nowBuf.ItSize == 0
			return void

		InterlockedXor(RemRootInd,1)

		while nowBuf.Users != 0 {}

		// sortPointers(nowBuf.ToRem[0]&->{void^^},nowBuf.ItSize)

		i := 0

		while i < RootsCount
		{
			inSet := false

			for j : nowBuf.ItSize
			{
				if nowBuf.ToRem[j] == Roots[i].0
				{
					inSet = true
					break
				}
			}

			// left := 0
			// right := nowBuf.ItSize - 1
			//
			// while left <= right
			// {
			// 	mdl := (left + right) div 2
			//
			// 	cmpRes := nowBuf.ToRem[mdl] <=> Roots[i].0
			//
			// 	if cmpRes == 0
			// 	{
			// 		inSet = true
			// 		break
			// 	}else if cmpRes < 0 
			// 	{
			// 		left = mdl + 1
			// 	}else{
			// 		right = mdl - 1
			// 	}
			// }

			if inSet
			{
				oldPtr := Roots[i].0
				useFree := Roots[i].2

				Roots[i] = Roots[RootsCount -= 1]

				// printf("removin %p\n",oldPtr)

				if useFree
					free(oldPtr)
			}else {
				i += 1
			}
		}

		nowBuf.ItSize = 0
	}
	sortPointers := !(void^^ buf,int size) -> void
	{
		for i : size
		{
			for j : (i+1)..size
			{
				if buf[i] > buf[j]
				{
					tmp := buf[i]
					buf[i] = buf[j]
					buf[j] = tmp
				}
			}
		}
		// if size == 0
		// 	return void
		// mdl := buf[0]
		//
		// i := 0
		// j := size - 1
		//
		// while i < j
		// {
		// 	while buf[i] < mdl
		// 		i += 1
		// 	while buf[j] > mdl
		// 		j -= 1
		//
		// 	if j <= i
		// 		break
		//
		// 	tmp := buf[j]
		// 	buf[j] = buf[i]
		// 	buf[i] = tmp
		// }
		//
		// sortPointers(buf,j)
		// sortPointers(buf[i]&, size - (i + 1))
	}
	RemoveRoot := !(void^ mem) -> void
	{
		// printf("Rem %p\n",mem)

		nowInd := RemRootInd
		nowBuf := ref RemRootBufs[nowInd]

		if nowBuf.ItSize > 400
		{
			rootCV.Notify()
			while nowInd == RemRootInd {}
			RemoveRoot(mem)
			return void
		}

		InterlockAdd(nowBuf.Users,1)

		if nowInd != RemRootInd
		{
			InterlockSub(nowBuf.Users,1)
			RemoveRoot(mem)
			return void
		}

		newInd := InterlockAdd(nowBuf.ItSize,1)
		nowBuf.ToRem[newInd] = mem

		InterlockSub(nowBuf.Users,1)
	}
}

RemRootBufType := class
{
	ToRem := void^[512]
	Users := int
	ItSize := int
}

_callGC2Loop := !(void^ data) -> void
{
	data->{GCAllocator^}.threadLoop()
}

GC2MemInfo := class
{
	IsFound := bool

	OriginalPointer := void^
	GenerationPointer := u8^
	MemSize := int
}

GCThreadBegin := !() -> void
{
	buf := u8[256]
	pthread_getattr_np(pthread_self(),buf[0]&)

	ptr := void^
	size := size_t
	pthread_attr_getstack(buf[0]&,ptr&,size&)

	MainGC.AddRoot(ptr,size)
}
GCThreadEnd := !() -> void
{
	buf := u8[256]
	pthread_attr_init(buf[0]&)

	ptr := void^
	size := size_t
	pthread_attr_getstack(buf[0]&,ptr&,size&)

	MainGC.RemoveRoot(ptr)
}

MainGC := GCAllocator^
GCPage := PageMemory

InitMainGC := !() -> void
{
	#MarkFunction("ThreadBegin",GCThreadBegin)
	#MarkFunction("ThreadEnd",GCThreadEnd)

	GCPage.Create(GCAllocator->TypeSize,"rw")
	MainGC = GCPage.GetPointer()->{GCAllocator^}
	internalHVInitClass(MainGC^)
	MainGC.pages32.ObjSize = 32
	MainGC.pages64.ObjSize = 64
	MainGC.pages128.ObjSize = 128
	MainGC.StartGCThread()
}
StopMainGC := !() -> void
{
	MainGC.quit = true
	MainGC.gcThread.Join()

}

GCCheckDistance := !(u8 left,u8 right) -> bool
// {
// 	result = GCCheckDistance2(left,right)
//
// 	if result 
// 		printf("yep %i %i\n",left,right)
//
// 	return false
// }
// GCCheckDistance2 := !(u8 left,u8 right) -> bool
{
	// return false
	limit := 10

	if left == right
		return false
	if left < right
		return right - left > limit
	c := u32
	c = right
	c += 256
	return c - left > limit
}

