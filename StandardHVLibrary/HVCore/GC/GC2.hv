GCAllocator := class extends IAllocator
{

	pages32 := Allc128
	pages64 := Allc128
	pages128 := Allc128


	memMedium := AllocatorGCMedium

	currentGeneration := u8
	gcThread := BasicThread
	quit := bool

	rootMutex := Mutex
	rootCV := ConVar


	AllocMem := virtual !(int size, bool dirty = false) -> void^
	{
		size = AlignUp16(size)
	
		if size <= 32
			return pages32.AllocMem(currentGeneration)
		if size <= 64
			return pages64.AllocMem(currentGeneration)
		if size <= 128
			return pages128.AllocMem(currentGeneration)

		return memMedium.AllocMem(size,currentGeneration,dirty)
	}

	FreeMem := virtual !(void^ mem) -> void
	{

	}

	GetMemInfo := !(void^ mem) -> GC2MemInfo
	{
		// if false
		{
			for pg : ![pages32&,pages64&,pages128&]
			{
				c := pg.GetMemInfo(mem)
				if c.IsFound
				{
					result.IsFound = true
					result.OriginalPointer = c.OriginalPointer
					result.GenerationPointer = c.GenerationPointer
					result.MemSize = c.MemSize
					return void
				}
			}
		}

		// if false
		{
			c := memMedium.GetMemInfo(mem)
			if c.IsFound
			{
				result.IsFound = true
				result.OriginalPointer = c.OriginalPointer
				result.GenerationPointer = c.GenerationPointer
				result.MemSize = c.MemSize
				return void
			}
		}
	}


	GetPointerInfo := !(void^ ptr) -> void
	{
		// actual pointer
		// typeid
		//
	}


	memRange := Tuple.{void^,void^}

	StartGCThread := !() -> void
	{
		gcThread.Start(_callGC2Loop,this&)
	}
	threadLoop := !() -> void
	{
		rootMutex.Lock()
		defer rootMutex.Unlock()

		prevTime := GetSteadyTime()

		while not quit
		{
			addRootCheck()
			removeRootCheck()
			// checkFreeCalls()
			

			nowTime := GetSteadyTime()

			if nowTime - prevTime > 1.0
			{

				// wut := GetMemInfo(TaskMainTaskWorker)
				// printf("wut %i\n",wut.IsFound)

				prevTime = nowTime

				memRange.0 = null
				memRange.0&->{size_t^}^ -= 1
				memRange.1 = null
				
				for pg : ![pages32&,pages64&,pages128&]
				{
					rang := pg.getMinMax()
					memRange.0 = min(memRange.0,rang.0)
					memRange.1 = max(memRange.1,rang.1)
				}


				for i : RootsCount
				{
					ptr := Roots[i].0
					size := Roots[i].1
					if ptr == null or size == 0
					{
						RootsGens[i] = currentGeneration
						continue
					}

					checkRootRange(ptr,size)
				}

				for i : TaskRootsCount
				{
					ptr := TaskRoots[i].0
					size := TaskRoots[i].1
					if ptr == null or size == 0
						continue

					if TaskRoots[i].2 == 1
						continue

					checkRootRange(ptr,size)
				}

				checkGlobals()

				if TaskMainTaskWorker != null
					checkRootRange(TaskMainTaskWorker,TaskWorker->TypeSize)

				for i : TaskAdditionalWorkersCount
					checkRootRange(TaskAdditionalWorkers[i],TaskWorkerCreated->TypeSize)

				for pg : ![pages32&,pages64&,pages128&]
				{
					pg.DeleteOldObjects(currentGeneration)
				}
				memMedium.DeleteOldObjects(currentGeneration)
				currentGeneration += 1
			}

			rootCV.WaitFor(rootMutex&,0.1)
		}
	}

	checkGlobals := !() -> void
	{
		for it,name : $GlobalVariables
		{
			// printf("name %s\n",name)
			checkRootRange(it&,it->TypeSize)
		}
	}

	checkRootRange := !(void^ inPtr, size_t size) -> void
	{
		ptr := inPtr->{void^^}
		size = size div 8

		for i : size
		{
			pt := ptr[i]
			if pt == null
				continue
			// if pt < memRange.0 or pt > memRange.1
			// 	continue
			memInf := this.GetMemInfo(ptr[i])

			if memInf.IsFound
			{
				if memInf.GenerationPointer^ != currentGeneration
				{
					memInf.GenerationPointer^ = currentGeneration
					checkRootRange(memInf.OriginalPointer,memInf.MemSize)
				}
			}
		}
	}

	Roots := Tuple.{void^,int,bool}[2048]
	RootsGens := u8[2048]
	RootsCount := int

	AddRootsBuf := Tuple.{void^,int,bool}[512]
	AddRootsBufIsSet := u8[512]
	AddRootsStart := u32
	AddRootsEnd := u32

	addRootCheck := !() -> void
	{
		left := AddRootsStart mod AddRootsBuf.Size()
		right := AddRootsEnd mod AddRootsBuf.Size()

		if left > right
			right += AddRootsBuf.Size()

		// printf("test %i\n",CyclicDistance(AddRootsStart,AddRootsEnd,AddRootsBuf.Size()))

		while left != right
		{
			// printf("called\n")
			assert(RootsCount < Roots.Size() - 100)
			ind := left mod AddRootsBuf.Size()

			while AddRootsBufIsSet[ind] == 0 {}

			rInd := RootsCount++  
			Roots[rInd] = AddRootsBuf[ind]
			RootsGens[rInd] = currentGeneration - 1

			InterlockSet(AddRootsBufIsSet[ind],0)

			left += 1
			AddRootsStart += 1
		}
	}
	AddRoot := !(void^ mem,int size, bool freeOnRemove = false) -> void
	{
		// printf("Add %p\n",mem)
		if mem == null or size == 0
			return void

		while CyclicDistance(AddRootsStart,AddRootsEnd,AddRootsBuf.Size()) > 128 {
			rootCV.Notify()
		}

		ind := InterlockAdd(AddRootsEnd,1) mod AddRootsBuf.Size()

		AddRootsBuf[ind] = !{mem,size,freeOnRemove}

		InterlockSet(AddRootsBufIsSet[ind],1)

		rootCV.Notify()
	}

	
	RemRootInd := int
	RemRootBufs := RemRootBufType[2]

	removeRootCheck := !() -> void
	{
		nowBuf := ref RemRootBufs[RemRootInd]

		if nowBuf.ItSize == 0
			return void

		InterlockedXor(RemRootInd,1)

		while nowBuf.Users != 0 {}

		// sortPointers(nowBuf.ToRem[0]&->{void^^},nowBuf.ItSize)

		i := 0

		while i < RootsCount
		{
			inSet := false

			for j : nowBuf.ItSize
			{
				if nowBuf.ToRem[j] == Roots[i].0
				{
					inSet = true
					break
				}
			}

			// left := 0
			// right := nowBuf.ItSize - 1
			//
			// while left <= right
			// {
			// 	mdl := (left + right) div 2
			//
			// 	cmpRes := nowBuf.ToRem[mdl] <=> Roots[i].0
			//
			// 	if cmpRes == 0
			// 	{
			// 		inSet = true
			// 		break
			// 	}else if cmpRes < 0 
			// 	{
			// 		left = mdl + 1
			// 	}else{
			// 		right = mdl - 1
			// 	}
			// }

			if inSet
			{
				oldPtr := Roots[i].0
				useFree := Roots[i].2

				Roots[i] = Roots[RootsCount -= 1]
				RootsGens[i] = RootsGens[RootsCount]

				// printf("removin %p\n",oldPtr)

				if useFree
					free(oldPtr)
			}else {
				i += 1
			}
		}

		nowBuf.ItSize = 0
	}
	sortPointers := !(void^^ buf,int size) -> void
	{
		for i : size
		{
			for j : (i+1)..size
			{
				if buf[i] > buf[j]
				{
					tmp := buf[i]
					buf[i] = buf[j]
					buf[j] = tmp
				}
			}
		}
		// if size == 0
		// 	return void
		// mdl := buf[0]
		//
		// i := 0
		// j := size - 1
		//
		// while i < j
		// {
		// 	while buf[i] < mdl
		// 		i += 1
		// 	while buf[j] > mdl
		// 		j -= 1
		//
		// 	if j <= i
		// 		break
		//
		// 	tmp := buf[j]
		// 	buf[j] = buf[i]
		// 	buf[i] = tmp
		// }
		//
		// sortPointers(buf,j)
		// sortPointers(buf[i]&, size - (i + 1))
	}
	RemoveRoot := !(void^ mem) -> void
	{
		// printf("Rem %p\n",mem)

		nowInd := RemRootInd
		nowBuf := ref RemRootBufs[nowInd]

		if nowBuf.ItSize > 400
		{
			rootCV.Notify()
			while nowInd == RemRootInd {}
			RemoveRoot(mem)
			return void
		}

		InterlockAdd(nowBuf.Users,1)

		if nowInd != RemRootInd
		{
			InterlockSub(nowBuf.Users,1)
			RemoveRoot(mem)
			return void
		}

		newInd := InterlockAdd(nowBuf.ItSize,1)
		nowBuf.ToRem[newInd] = mem

		InterlockSub(nowBuf.Users,1)
	}

	TaskRoots := Tuple.{void^,size_t,u64}[512]
	TaskRootsCount := int

	GetTaskRootStackSize := !() -> int 
	{
		return 2*1024*1024
	}
	GetTaskRoot := !() -> void^
	{
		for i : TaskRootsCount
		{
			prev := InterlockSet(TaskRoots[i].2,0)
			if prev == 1
				return TaskRoots[i].0
		}

		newAddr := malloc(GetTaskRootStackSize())

		id := InterlockAdd(TaskRootsCount,1)

		TaskRoots[id].0 = newAddr
		TaskRoots[id].1 = GetTaskRootStackSize()

		return TaskRoots[id].0

	}

	RemoveTaskRoot := !(void^ mem) -> void
	{
		for i : TaskRootsCount
		{
			if TaskRoots[i].0 == mem
			{
				InterlockSet(TaskRoots[i].2,1)
			}
		}
	}

}



// debugGetMainGC := !() -> GCAllocator^
// 	#Mark("JITPass")
// {
// 	return MainGC
// }

// debugIsRootActive := !(void^ mem) -> bool
// 	#Mark("JITPass")
// {
// 	WUT = mem->{size_t}
// 	calldTask = CurrentTask?.stackPtr->{size_t}
// 	if #Var("GC")
// 	{
// 		for i : MainGC.RootsCount
// 		{
// 			root := ref MainGC.Roots[i]
// 			beg := root.0
// 			end := root.0->{u8^}[root.1]&
//
// 			if beg <= mem and mem < end
// 			{
// 				return true
// 			}
// 		}
// 		for i : MainGC.TaskRootsCount
// 		{
// 			root := ref MainGC.TaskRoots[i]
// 			beg := root.0
// 			end := root.0->{u8^}[root.1]&
//
// 			if beg <= mem and mem < end
// 			{
// 				return root.2 == 0
// 			}
// 		}
// 	}
// 	return false
// }

RemRootBufType := class
{
	ToRem := void^[512]
	Users := int
	ItSize := int
}

_callGC2Loop := !(void^ data) -> void
{
	data->{GCAllocator^}.threadLoop()
}

GC2MemInfo := class
{
	IsFound := bool

	OriginalPointer := void^
	GenerationPointer := u8^
	MemSize := int
}

GCThreadBegin := !() -> void
{
	buf := u8[256]
	pthread_getattr_np(pthread_self(),buf[0]&)

	ptr := void^
	size := size_t
	pthread_attr_getstack(buf[0]&,ptr&,size&)

	MainGC.AddRoot(ptr,size)
}
GCThreadEnd := !() -> void
{
	buf := u8[256]
	pthread_attr_init(buf[0]&)

	ptr := void^
	size := size_t
	pthread_attr_getstack(buf[0]&,ptr&,size&)

	MainGC.RemoveRoot(ptr)
}

MainGC := GCAllocator^
GCPage := PageMemory

InitMainGC := !() -> void
{
	#MarkFunction("ThreadBegin",GCThreadBegin)
	#MarkFunction("ThreadEnd",GCThreadEnd)

	GCPage.Create(GCAllocator->TypeSize,"rw")
	MainGC = GCPage.GetPointer()->{GCAllocator^}
	internalHVInitClass(MainGC^)
	MainGC.pages32.ObjSize = 32
	MainGC.pages64.ObjSize = 64
	MainGC.pages128.ObjSize = 128
	MainGC.StartGCThread()
}
StopMainGC := !() -> void
{
	MainGC.quit = true
	MainGC.gcThread.Join()

}

GCCheckDistance := !(u8 left,u8 right) -> bool
// {
// 	result = GCCheckDistance2(left,right)
//
// 	if result 
// 		printf("yep %i %i\n",left,right)
//
// 	return false
// }
// GCCheckDistance2 := !(u8 left,u8 right) -> bool
{
	// return false
	limit := 10

	if left == right
		return false
	if left < right
		return right - left > limit
	c := u32
	c = right
	c += 256
	return c - left > limit
}

