

EnterTaskThreadCycle := !(bool isMainThread) -> void
{
	TaskCheckMutex.Lock()
	
	while true
	{
		ct := CurrentThread

		if ct.DeleteTasks.Size() != 0
		{
			delTask := ct.DeleteTasks.Pop()
			ct.AllTasks.Remove(delTask)
			delTask.Destroy()
			//delete delTask //TODO delete it, and better api
			continue
		}

		//if TaskLoopWorkCounter != 0 and not someoneOnLoop
		//{
		//	someoneOnLoop = true
		//	TaskCodePollWork(0.0)
		//	someoneOnLoop = false
		//}
		//
		nowTime := GetSteadyTime()
		ct.CheckTimers(nowTime)

		doTask := ct.PopReadyTask()

		if doTask != null
		{
			doTask.switchToTask()
			continue
		}
		
		if ct.TaskTimersArray.Size() != 0 or TaskLoopWorkCounter != 0
		{
			waitTime := 1.0
			if ct.TaskTimersArray.Size() != 0
				waitTime = ct.TaskTimersArray[0].0 - nowTime
			ct.itConVar.WaitFor(TaskCheckMutex,waitTime)
		}else
		{
			TaskPausedWorkers += 1
			if TaskPausedWorkers == TaskAdditionalWorkersCount + 1
			{
				cntr := TaskMainTaskWorker.AllTasks.Size()
				for i : TaskAdditionalWorkersCount
				{
					cntr += TaskAdditionalWorkers[i].AllTasks.Size()
				}
				if cntr == 0
				{
					TaskQuitProgram = true
					TaskMainTaskWorker.innerNotify()
					for i : TaskAdditionalWorkersCount
						TaskAdditionalWorkers[i].innerNotify()
				}else{
					if TaskMainTaskWorker.PendingTasks.Size() != 0
						TaskMainTaskWorker.innerNotify()
					ct.itConVar.Wait(TaskCheckMutex)
				}
			}else{
				ct.itConVar.Wait(TaskCheckMutex)
			}
			TaskPausedWorkers -= 1
		}

		if TaskQuitProgram
			break
	}

	TaskCheckMutex.Unlock()

	if isMainThread
	{
		for i : TaskAdditionalWorkersCount
		{
			TaskAdditionalWorkers[i].itThread.Join()
		}
	}
}
TaskLoopWorkCounter := int
