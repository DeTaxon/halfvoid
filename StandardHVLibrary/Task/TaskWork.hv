
TaskWorkersToDo := List.{Task^}

"@work call" := !(!()&->@T lmbd ) -> T
{
	internalWorkCall(() ==> [cl = result&] {
		cl^ = lmbd()
	})
}


#MarkFunction("JITPass",internalWorkCall)
internalWorkCall := !(!()&->void lmbd) -> void
{
	TaskCheckMutex.Lock() //TODO optimize

	ExpectWorkers(1)

	TaskWorkersToDo.Push(GetCurrentTask())

	for i : TaskAdditionalWorkersCount //TODO optimize
	{
		TaskAdditionalWorkers[i].innerNotify()
	}

	GetCurrentThread().switchToMain()
	TaskCheckMutex.Unlock()

	lmbd()
	
	TaskCheckMutex.Lock()

	myTask := GetCurrentTask()
	myTask.resume()
	myTask.itTaskWorker.innerNotify()

	TaskMainEvent.Emit()
	GetCurrentThread().switchToMain()

	TaskCheckMutex.Unlock()
}

SpawnWork := !(!()&->void lmbd) -> Task^
	#Mark("JITPass")
{
	return spawnWorkInner(lmbd.Capture())
}

spawnWorkInner := !(!()&->void lmbd) -> Task^
{
	newTask := new Task(lmbd)
	TaskCheckMutex.Lock() //TODO optimize
	TaskWorkersToDo.Push(newTask)

	for i : TaskAdditionalWorkersCount //TODO optimize
	{
		TaskAdditionalWorkers[i].innerNotify()
	}

	TaskCheckMutex.Unlock()
	ExpectWorkers(1)

	return newTask
}


ExpectWorkers := !(int x) -> void
	#Mark("JITPass")
{
	diff := x - TaskAdditionalWorkersCount

	if x <= 0
		return void
	for i : diff
	{
		newWorker := new TaskWorkerCreated()
		
		newWorker.CreateThread()
		TaskAdditionalWorkers[InterlockAdd(TaskAdditionalWorkersCount,1)] = newWorker
	}
}
