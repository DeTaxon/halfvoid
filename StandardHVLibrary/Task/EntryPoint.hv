internalHVEntryPoint := !(int argc,char^^ argv) -> int
{
	TLSMutex."this"() //TODO only if TLS used

	//All function expects to CurrentTask be initialized, this is not working for first function
	//so first function MUST initialize CurrentTask
	internalInitThread()

	result = internalHVEntryPoint2(argc,argv)

	internalGlobalsDestroy()

	CurrentThread.ThreadMainTask = null
	CurrentThread = null
	internalThreadDestructor()
}

internalInitThread := !() -> void
{
	voidVal := calloc(1,Task->TypeSize)
	internalHVInitClass(voidVal->{Task^}^)
	CurrentTask = voidVal->{Task^}
	CurrentTask.DecRef()
}

internalGlobalsDestroy := !() -> void
{
	for it,ind : $GlobalVariables
	{
		if it->Type >= TGCIObject
		{
			it.Destroy()
		}
		if it->TypeGroup == "Array"
		{
			if it->TypeBase->IsGCPointer
			{
				for c : it
					c = null
			}
		}
	}
}
internalThreadDestructor := !() -> void
{
	CurrentTask = null
}


TSpawnTask := !(!()&-> void cb) -> void
{
	startTask := new Task(cb.Capture())

	CurrentThread.AllTasks.Insert(startTask)
	CurrentThread.CreateTasks.Push(startTask)
	startTask = null
}


ucontextStartTask := !() -> void
{
	CurrentTask.startTaskThread()
}

internalHVEntryPoint2 := !(int argc,char^^ argv) -> int
{
	InitTaskContext()


	CurrentThread = new TaskWorker()
	CurrentThread.ThreadMainTask = CurrentTask
	TaskMainTaskWorker = CurrentThread
	CurrentTask.OSFirstInit()


	for it : #MarkedFunctions("CallAtStart")
	{
		it()
	}

	for it : #MarkedFunctions("ThreadBegin")
	{
		it()
	}
	
	if #Tracy()
	{
		GlobalTracyInUse = true
	}


	TSpawnTask(() ==> [argv,argc] {	
		spn := TArraySpan.{char^}//(argv,argc)
		spn.pointer = argv
		spn.itSize = argc
		main(spn&)
	})

	EnterTaskThreadCycle(true)

	for it : #MarkedFunctions("ThreadEnd")
	{
		it()
	}

	if #Tracy()
	{
		GlobalTracyInUse = false
	}

	TaskContextDestructor()
	TaskMainTaskWorker = null
	
	//ur_exit(gTaskIORing)
	//ur_destroy(gTaskIORing)
}


