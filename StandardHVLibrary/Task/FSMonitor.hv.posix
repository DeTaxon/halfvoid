

IN_CLOSE := 24
IN_OPEN := 32
IN_MODIFY := 2


wd_struct := class
{
	wd := s32
	mask := u32
	cookie := u32

	len := u32
	name := char[1]
}

//TODO
//Check for repeats
FIONREAD := 21531
inotify_wrapper_fd := class
{
	fd := int

	fileNodes := AVLMap.{int,inotify_wrapper_node}

	Init := !() -> void
	{
	}

	MonitorFolder := !(StringView folderPath,bool recursive,!(FSObject^)& -> void cb) -> TGCObject^
	{
		@once {
			this.fd = inotify_init1(2048)

			TSpawnTask(() ==> [this&]{
				OSAsyncReadNonStop(fd,(blb) ==> [this&]{
					ptr := blb.GetPointer()->{wd_struct^}
					fileName := StringSpan(ptr.name[0]&,ptr.len)

					for it : fileNodes
					{

						sBuf := TEchoStream
						sBuf << it.objectName << "/" << fileName

						fullPath := sBuf.GetString()

						newFile := new File()
						newFile.absPath = fullPath
						newFile.objName = fileName.GetString()

						if it.isPaused
						{
							it.monitorTask.resume()
							it.isPaused = false
							it.changedObject = newFile
						}
					}
				})
			})
		}


		TLock(this&)

		wd := inotify_add_watch(this.fd,folderPath.GetString().Str(),IN_MODIFY)

		newNode := ref fileNodes[wd]
		newNode.objectName = folderPath.GetString()
		newNode.monitorTask = CurrentTask

		TUnlock(this&)

		thrd := CurrentThread
		//TODO Cancalable
		while true
		{
			TaskCheckMutex.Lock()
			newNode.isPaused = true
			thrd.switchToMain()
			TaskCheckMutex.Unlock()

			if newNode.changedObject != null
			{
				cb(newNode.changedObject)
				newNode.changedObject = null
			}
		}
	}
}
inotify_wrapper_node := class
{
	objectName := String^
	monitorTask := Task^
	changedObject := FSObject^
	isPaused := bool
}

iw_fd := inotify_wrapper_fd
//TODO add destroy
initMonitorFolder := !() -> void
{
	iw_fd.Init()
}


#MarkFunction("JITPass",AsyncMonitorFolderNonStop)
AsyncMonitorFolderNonStop := !(StringView folderPath,bool recursive,!(FSObject^)& -> void cb) -> TGCObject^
{
	#MarkFunction("CallAtStart",initMonitorFolder)

	return iw_fd.MonitorFolder(folderPath,recursive,cb)
}

