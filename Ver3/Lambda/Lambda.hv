BoxLambdaHolder := class extend BoxExeObj
{
	tmpl := BoxFuncTemplateBody^
	this := !(Token^ brackets, Token^ body,Token^ typeToken,Token^ capturesToken) -> void
	{

		attr := FuncAttributes
		bPtr := Token^
		itBody := body

		if itBody.GetValue() != "{}"
		{
			itBody = new TokenSymbol(StringSpan("{}"),1)
			dat := new TokenData
			re := new TokenSymbol(StringSpan("return"),1)
			itBody.Down = dat
			dat.Down = re
			re.Right = body
			itBody.Line = body.Line
			re.Line = body.Line
			dat.Line = body.Line
		}

		if brackets.Down?.GetValue() == "()"
		{
			bPtr = brackets.Down
		}else{
			if not (brackets is TokenIndent)
				brackets.EmitError("Unknown input object for lambda") //todo better error
			
			bPtr = new TokenSymbol(StringSpan("()"),1)
			bPtr.Down = new TokenIndent(brackets->{TokenIndent^}.Value)
		}

		rToken := typeToken
		if typeToken == null
		{
			rToken = new TokenIndent
			attr.IsAutoResult = true
			rToken->{TokenIndent^}.Value = StringSpan("void")
		}

		attr.IsLambda = true
		
		tmpl = new BoxFuncTemplateBody(attr,bPtr,null,null,rToken,itBody)
		tmpl.SetName(StringSpan("lambda"))

		ObjType = GObjNone.GetType()
	}
	IsOneFunc := !() -> bool
	{
		return tmpl.IsOneFunc()
	}
	CreateOneFuncLambda := !() -> BoxExeObj^
	{
		return createLambd(() ==> {
			return this.tmpl.GetOneFunc()->{BoxFuncBody^}
		})
	}
	CreateLambda := virtual !(Type^ toType) -> BoxExeObj^
	{
		if not (toType is in TypePoint)
			return null
		if not (toType.Base is in TypeClass)
			return null

		cls := toType.Base->{TypeClass^}.ToClass
		if cls.Constants == null or cls.Constants.Constants.Size() != 1
			return null
		cnst1 := cls.Constants.Constants[0]
		if not (cnst1 is ConstType)
			return null
		cnstTyp := cnst1->{ConstType^}.Value
		if not (cnstTyp is in TypePoint)
			return null
		if not (cnstTyp.Base is in TypeFunc)
			return null
		fTyp := cnstTyp.Base->{TypeFunc^}
		return createLambd(() ==> {
			cnsts := List.{BoxExeConstObj^}
			return tmpl.CreateFunc(fTyp,cnsts)->{BoxFuncBody^}
		})
	}

	createLambd := !(!()&->BoxFuncBody^ cb) -> BoxExeObj^
	{
		newFunc := cb() //Vars captured
		newFunc.ParseBodyForced()
		
		fncFnc := new FuncPointerParam(newFunc)
		fncPtr := fncFnc.CreateCall()

		getTupleVar := BoxExeObj^

		tplType := CurrentFunc.GetCaptureTuple().ItType

		if newFunc.CaptureUsed
		{
			getTupleMacro := new MacroParam(tplType.GetPoint(),false)
			CurrentFunc.CapturedVarsGets.Push(getTupleMacro)
			getTupleVar = getTupleMacro.CreateCall()
		}else{
			getTupleVar = GetExchange(GObjNull,tplType.GetPoint())
		}


		objs := CheckExeDownList
		objs.Push(fncPtr)
		objs.Push(getTupleVar)
		objs.Push(GetExchange(GObjNull,GTypeVoidP.GetPoint()))

		lst := List.{BoxExeConstObj^}
		lst.Push(GetConstType(newFunc.GetYieldTuple().ItType))
		lst.Push(GetExeInt(GCVarsInUse))
		assert(lst[1] is in BoxExeConstObj)
		
		createLambdaFunc := TemplateInternalCreateLambda.GetFunc(objs,lst)
		lst.Destroy()

		step1 := createLambdaFunc.CreateCall(objs)
		step2 := new UnrefFuncCall(step1)

		cnsts := List.{BoxExeConstObj^}
		cnsts.Push(GetConstType(newFunc.GetType().GetPoint()))
		InternalsHatch.Await()
		lambdaType := GCLambda.GetClass(cnsts).ItType
		cnsts.Destroy()
		return GetExchange(step2,lambdaType.GetPoint())
	}
	CanBeThisType := !(Type^ tp) -> bool
	{ //TODO: check argument count and types
		if not (tp is in TypePoint)
			return false
		if TypeFight(tp.Base,GCILambda.ItType) != GCILambda.ItType
			return false
		return true
	}
}
