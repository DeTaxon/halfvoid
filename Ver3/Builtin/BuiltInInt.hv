BuiltInIntBase := class extend BoxFuncCommon
{
	llvm := char^
	this := !(TypeFunc^ iType,char^ llvmOper) -> void
	{
		SetType(iType)
		llvm = llvmOper
	}
	PrintFuncCall := virtual !(TIOStream^ f,int resId,int debId,ExeDownList lst) -> void
	{
		lst[^].PrintPre(f)
		
		tFunc := GetType()->{TypeFunc^}
		tp := tFunc.Params[0].ItType

		f^ << "%T" << resId << " = " << llvm << " " 
		tp.PrintType(f)
		f^ << " "
		lst[0].PrintUse(f)
		f^ << ","
		lst[1].PrintUse(f)
		if DebugMode
			f^ << " , !dbg !" << GDebugLineCallId
		f^ << "\n"
	}
}

BuiltInIntEqAndOper := class extend BoxFuncCommon
{
	llvm := char^
	this := !(TypeFunc^ iType,char^ llvmOper) -> void
	{
		SetType(iType)
		llvm = llvmOper
	}
	PrintFuncCall := virtual !(TIOStream^ f,int resId,int debId,ExeDownList lst) -> void
	{
		lst[0].PrintPointPre(f)
		lst[1].PrintPre(f)

		tp := GetType()->{TypeFunc^}.ResultType

		f^ << "%Temp" << resId << " = load "
		tp.PrintType(f)
		f^ << ","
		tp.GetPoint().PrintType(f)
		f^ << " "
		lst[0].PrintPointUse(f)
		if DebugMode
			f^ << " , !dbg !" << GDebugLineCallId
		f^ << "\n"

		f^ << "%T" << resId << " = " << llvm << " " 
		tp.PrintType(f)
		f^ << " %Temp" << resId
		f^ << ","
		lst[1].PrintUse(f)
		if DebugMode
			f^ << " , !dbg !" << GDebugLineCallId
		f^ << "\n"

		f^ << "store "
		tp.PrintType(f)
		f^ << " %T" << resId << ","
		tp.GetPoint().PrintType(f)
		f^ << " "
		lst[0].PrintPointUse(f)
		if DebugMode
			f^ << " , !dbg !" << GDebugLineCallId
		f^ << "\n"
	}
}

BuiltInIntDecInc := class extend BoxFuncCommon
{
	llvm := char^
	this := !(TypeFunc^ iType,char^ llvmOper) -> void
	{
		SetType(iType)
		llvm = llvmOper
	}
	PrintFuncCall := virtual !(TIOStream^ f,int resId,int debId,ExeDownList lst) -> void
	{
		lst[0].PrintPointPre(f)

		tp := GetType()->{TypeFunc^}.ResultType

		f^ << "%T" << resId << " = load "
		tp.PrintType(f)
		f^ << ","
		tp.GetPoint().PrintType(f)
		f^ << " "
		lst[0].PrintPointUse(f)
		if DebugMode
			f^ << " , !dbg !" << GDebugLineCallId
		f^ << "\n"

		f^ << "%Temp" << resId << " = " << llvm << " " 
		tp.PrintType(f)
		f^ << " %T" << resId
		f^ << ", 1"
		if DebugMode
			f^ << " , !dbg !" << GDebugLineCallId
		f^ << "\n"

		f^ << "store "
		tp.PrintType(f)
		f^ << " %Temp" << resId << ","
		tp.GetPoint().PrintType(f)
		f^ << " "
		lst[0].PrintPointUse(f)
		if DebugMode
			f^ << " , !dbg !" << GDebugLineCallId
		f^ << "\n"
	}
}
BuiltInIntMinus := class extend BoxFuncCommon
{
	llvm := char^
	cnstVal := char^
	this := !(TypeFunc^ iType,char^ lvm,char^ cv) -> void
	{
		SetType(iType)
		llvm = lvm
		cnstVal = cv
	}
	PrintFuncCall := virtual !(TIOStream^ f,int resId,int debId,ExeDownList lst) -> void
	{
		lst[0].PrintPre(f)

		tp := GetType()->{TypeFunc^}.ResultType

		f^ << "%T" << resId << " = "<< llvm <<" " 
		tp.PrintType(f)
		f^ << " " << cnstVal << ", "
		lst[0].PrintUse(f)
		if DebugMode
			f^ << " , !dbg !" << GDebugLineCallId
		f^ << "\n"
	}
}
BuiltInPrimeStore := class extend BoxFuncCommon
{
	this := !(TypeFunc^ iType) -> void
	{
		SetType(iType)
	}
	PrintFuncCall := virtual !(TIOStream^ f,int resId,int debId,ExeDownList lst) -> void
	{
		lst[0].PrintPointPre(f)
		lst[1].PrintPre(f)

		bs := GetType()
		tp := bs->{TypeFunc^}.Params[0].ItType

		f^ << "store "
		tp.PrintType(f)
		f^ << " "
		lst[1].PrintUse(f)
		f^ << ","
		tp.PrintType(f)
		f^ << "* "
		lst[0].PrintPointUse(f)
		if DebugMode
			f^ << " , !dbg !" << GDebugLineCallId
		f^ << "\n"
	}
}


BuiltInIntSuffixU := class extend BoxFuncCommon
{
	this := !() -> void
	{
		SetType(GetFuncType(![GTypeInt],GTypeU64))
	}
	//PrintFuncCall := virtual !(TIOStream^ f,int resId,int debId,ExeDownList lst) -> void
	//{
	//}
	CreateCall := virtual !(CheckExeDownList objs) -> BoxExeObj^
	{
		assert(objs.Size() == 1)

		return GetExchange(objs[0],GTypeU64)
	}
}

CreateBuiltins := !() -> void
{
	CreateBuiltinsInt()
	CreateBuiltinsPoint()
	CreateBuiltinsBool()
	CreateBuildInTools()
}
CreateBuiltinsInt := !() -> void
{
	bSpace := CodeSpaces[-1]&

	bSpace.Functions[StringSpan("suffix U")].Push(new BuiltInIntSuffixU())

	ForEachIntType( (x,isSigned) ==> {
		strt := GetFuncType(![x,x],x)
		baseRefed := GetFuncType(![x,x],![true,false],x)
		storeType := GetFuncType(![x,x],![true,false],GTypeVoid)
		cmpType := GetFuncType(![x,x],GTypeBool)
		incType := GetFuncType(![x],![true],x)
		unarMinusType := GetFuncType(![x],x)

		bSpace.Functions[StringSpan("+")].Push(new BuiltInIntBase(strt,"add") )
		bSpace.Functions[StringSpan("-")].Push(new BuiltInIntBase(strt,"sub") )
		bSpace.Functions[StringSpan("*")].Push(new BuiltInIntBase(strt,"mul") )

		bSpace.Functions[StringSpan("shl")].Push(new BuiltInIntBase(strt,"shl") )
		if isSigned
		{
			bSpace.Functions[StringSpan("shr")].Push(new BuiltInIntBase(strt,"ashr") )
		}else{
			bSpace.Functions[StringSpan("shr")].Push(new BuiltInIntBase(strt,"lshr") )
		}

		bSpace.Functions[StringSpan("+=")].Push(new BuiltInIntEqAndOper(baseRefed,"add") )
		bSpace.Functions[StringSpan("-=")].Push(new BuiltInIntEqAndOper(baseRefed,"sub") )
		bSpace.Functions[StringSpan("+=")].Push(new BuiltInIntEqAndOper(baseRefed,"mul") )

		bSpace.Functions[StringSpan("++")].Push(new BuiltInIntDecInc(incType,"add") )
		bSpace.Functions[StringSpan("--")].Push(new BuiltInIntDecInc(incType,"sub") )

		bSpace.Functions[StringSpan(". -")].Push(new BuiltInIntMinus(unarMinusType,"sub","0") )

		bSpace.Functions[StringSpan("<=>")].Push(new BuiltInIntBase(strt,"sub") ) //TODO case for unsigned int

		bSpace.Functions[StringSpan("=")].Push(new BuiltInPrimeStore(storeType) )

		bSpace.Functions[StringSpan("and_b")].Push(new BuiltInIntBase(strt,"and") )
		bSpace.Functions[StringSpan("or_b")].Push(new BuiltInIntBase(strt,"or") )
		bSpace.Functions[StringSpan("xor_b")].Push(new BuiltInIntBase(strt,"xor") )

		bSpace.Functions[StringSpan(". not_b")].Push(new BuiltInIntMinus(unarMinusType,"xor","-1") )

		if isSigned
		{
			bSpace.Functions[StringSpan("div")].Push(new BuiltInIntBase(strt,"sdiv") )
			bSpace.Functions[StringSpan("mod")].Push(new BuiltInIntBase(strt,"srem") )
		}else{
			bSpace.Functions[StringSpan("div")].Push(new BuiltInIntBase(strt,"udiv") )
			bSpace.Functions[StringSpan("mod")].Push(new BuiltInIntBase(strt,"urem") )
		}

		bSpace.Functions[StringSpan("==")].Push(new BuiltInIntBase(cmpType,"icmp eq") )
		bSpace.Functions[StringSpan("!=")].Push(new BuiltInIntBase(cmpType,"icmp ne") )

		if isSigned
		{
			bSpace.Functions[StringSpan(">=")].Push(new BuiltInIntBase(cmpType,"icmp sge") )
			bSpace.Functions[StringSpan("<=")].Push(new BuiltInIntBase(cmpType,"icmp sle") )
			bSpace.Functions[StringSpan(">")].Push(new BuiltInIntBase(cmpType,"icmp sgt") )
			bSpace.Functions[StringSpan("<")].Push(new BuiltInIntBase(cmpType,"icmp slt") )
		}else{
			bSpace.Functions[StringSpan(">=")].Push(new BuiltInIntBase(cmpType,"icmp uge") )
			bSpace.Functions[StringSpan("<=")].Push(new BuiltInIntBase(cmpType,"icmp ule") )
			bSpace.Functions[StringSpan(">")].Push(new BuiltInIntBase(cmpType,"icmp ugt") )
			bSpace.Functions[StringSpan("<")].Push(new BuiltInIntBase(cmpType,"icmp ult") )
		}


	})
	ForEachFloatType( (x) ==> {
		strt := GetFuncType(![x,x],x)
		storeType := GetFuncType(![x,x],![true,false],GTypeVoid)
		unarMinusType := GetFuncType(![x],x)

		bSpace.Functions[StringSpan("=")].Push(new BuiltInPrimeStore(storeType) )

		//bSpace.Functions[StringSpan("+")].Push(new BuiltInIntBase(strt,"fadd") )
		//bSpace.Functions[StringSpan("-")].Push(new BuiltInIntBase(strt,"fsub") )
		//bSpace.Functions[StringSpan("*")].Push(new BuiltInIntBase(strt,"fmul") )
		//bSpace.Functions[StringSpan("*")].Push(new BuiltInIntBase(strt,"fmul") )

		//bSpace.Functions[StringSpan("+=")].Push(new BuiltInIntEqAndOper(baseRefed,"add") )
		//bSpace.Functions[StringSpan("-=")].Push(new BuiltInIntEqAndOper(baseRefed,"sub") )
		//bSpace.Functions[StringSpan("+=")].Push(new BuiltInIntEqAndOper(baseRefed,"mul") )

		bSpace.Functions[StringSpan(". -")].Push(new BuiltInIntMinus(unarMinusType,"fsub","0.0") )

		//bSpace.Functions[StringSpan("==")].Push(new BuiltInIntBase(cmpType,"fcmp eq") )
		//bSpace.Functions[StringSpan("!=")].Push(new BuiltInIntBase(cmpType,"fcmp ne") )
	})
}
