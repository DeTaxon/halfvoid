
CodeFiles := List.{BoxFile^}
CodeSpaces := AVLMap.{int,BoxCodeSpace}

PriorityData := PriorityBagOld^
LexHVFileRoot := PriorityBagOld^
LexHVInputVars := PriorityBagOld^

loadLex := !(char^ filName,PriorityBagOld^^ res) -> void 
{
	pri := gRepo.GetFile(filName)
	if pri == null
	{
		printf("%s not found\n",filName)
		throw new Exception("intput error")
	}
	if not pri.IsVirtual()
	{
		printf("%s loaded from outsize\n",filName)
	}
	res^ = new PriorityBagOld(pri.Map(),pri.Size())
	pri.Unmap()
}

GArchBitSize := 64

GDebugTypePrintMeta := List.{Type^}

GFuncsInProgress := List.{BoxFunc^}
GClassesInProgress := List.{BoxClass^}

OutputFile := char^
main := !(int argc, char^^ argv) -> int
{
	if argc == 1
	{
		args2 := char^[20]
		args2[0] = argv[0]
		args2[1] = "main2.hv"
		args2[2] = "-C0"
		args2[3] = "libs2"
		args2[4] = "-o"
		args2[5] = "out.ll"
		args2[6] = "-g"
		return main(7,args2[0]&)
	}


	files := new List.{char^}

	i := 1
	while i < argc
	{
		switch argv[i]
		{
			case "-g"
				DebugMode = true
			case "-o"
				OutputFile = argv[i+1] //TODO error check
				i += 1
			case void
				if StringSpan(argv[i][0..2]) == "-C"
				{
					num := StrToInt(argv[i][2..0]) //TODO: check for num and memory
					TFSReadFolder(StringSpan(argv[i+1]),true,zFil ==> {
						nm := zFil.GetName()
						if nm[-3..0] == ".hv"
						{
							printf("here %s\n", nm[-3..0])
						}else nm[-5..0] == ".clib"
						{
							spc := CodeSpaces[num]&
							spc.CLibs.Push(new CLib(zFil))
						}
					})
					i += 1
				}else{
					file := gRepo.GetFile(argv[i])
					fileBox := new BoxFile(file)
					CodeFiles.Push(fileBox)
					CodeSpaces[2000].Files.Push(fileBox)
				}
		}
		i += 1
	}
	
	loadLex("Priority.pr",PriorityData&)
	loadLex("LexHVFileRoot.pr",LexHVFileRoot&)
	loadLex("LexHVInputVars.pr",LexHVInputVars&)
	
	HVOperators.Insert(StringSpan(PriorityData.Opers[^]))
	
	mac := gRepo.GetFile("Mach.m") //TODO Error check
	LoadLexMachine(mac.Map(),mac.Size()) 

	CreateStandardTypes()
	CreateBuiltins()
	cuId = GetNewId()

	for spc : CodeSpaces
	{
		spc.CLibs[^].Work()
	}

	for fil : CodeFiles
	{
		fil2 := fil
		TSpawnTask(() ==> {
			fil2.Parse()
		})
	}
	GParsedAllFiles.Emit()

	for fil : CodeFiles
	{
		fil.loaded.Await()
	}

	mainFunc := BoxFuncBody^
	GetItemGlobal(StringSpan("main"),x ==> {
		assert(x.Size() == 1) //TODO: better main function
		assert(x[0] is BoxFuncBody)
		mainFunc = x[0]->{BoxFuncBody^}
		return true
	})
	assert(mainFunc != null)//TODO better main function

	mainFunc.ParseBody()
	mainFunc.WaitReadyState()

	while GClassesInProgress.Size() != 0
	{
		GClassesInProgress[0].AwaitReadyState()
		GClassesInProgress.Pop()
	}

	while GFuncsInProgress.Size() != 0
	{
		GFuncsInProgress[0].WaitReadyState()
		GFuncsInProgress.Pop()
	}
	printf("good to do\n")

	outFile := new TFile(OutputFile,"wb")

	if DebugMode
		PrintDebugMeta(outFile)
	
	for spc : CodeSpaces
	{
		for fil : spc.Files
		{
			GDebugFileId = fil.fileId
			fil.AllClasses[^].PrintAsType(outFile)
		}
	}
	for spc : CodeSpaces
	{
		for fil : spc.Files
		{
			fil.PrintCode(outFile)
		}
	}

	for st : GlobalStrings
	{
		st.PrintCode(outFile)
	}
	for spc : CodeSpaces
	{
		for lb : spc.CLibs
		{	
			lb.PrintCode(outFile)
		}
		for fil : spc.Files
		{
			GDebugFileId = fil.fileId
			fil.AllFunctions[^].PrintCode(outFile)
		}
	}

	while GDebugTypePrintMeta.Size() != 0
	{
		GDebugTypePrintMeta[0].PrintMeta(outFile)
		GDebugTypePrintMeta.Pop()
	}

	return 0
}
cuId := int
PrintDebugMeta := !(TIOStream^ fil) -> void
{
	globVar := GetNewId()

	fileId := 0

	for spc : CodeSpaces
	{
		for fil : spc.Files
		{
			fileId = fil.fileId
		}
		if fileId != 0
			break
	}


	fil^ << "!llvm.dbg.cu = !{!"<< cuId <<"}\n"
	fil^ << "!" << cuId << "= distinct !DICompileUnit(producer: \"max\", isOptimized: false, runtimeVersion: 0,emissionKind: FullDebug, enums: !{},globals: !"<< globVar <<", language: DW_LANG_C99,file: !"<< fileId <<")\n"

	nm := GetNewId()
	fil^ << "!" << nm << " = !{!\"Taxon's stupid compiler\"}\n" 
	fil^ << "!llvm.ident = !{!" << nm <<"}\n"
	fil^ << "declare void @llvm.dbg.declare(metadata, metadata, metadata)\n"
	fil^ << "declare void @llvm.dbg.value(metadata, metadata, metadata)\n"
	fil^ << "declare void @llvm.dbg.addr(metadata, metadata, metadata)\n"

	dwrdV := GetNewId() fil^ << "!" << dwrdV << " = !{i32 2, !\"Dwarf Version\", i32 4}\n"
	DbgInf := GetNewId() fil^ << "!" << DbgInf << " = !{i32 2, !\"Debug Info Version\",i32 3}\n"
	WchSize := GetNewId() fil^ << "!" << WchSize << " = !{i32 1, !\"wchar_size\",i32 4}\n"
	PicLevel := GetNewId() fil^ << "!" << PicLevel << " = !{i32 7, !\"PIC Level\", i32 2}\n"
	PieLevel := GetNewId() fil^ << "!" << PieLevel << " = !{i32 7, !\"PIE Level\", i32 2}\n"
	fil^ << "!llvm.module.flags = !{!" << dwrdV << ",!" << DbgInf << ",!" << WchSize << ",!" << PicLevel << ",!" << PieLevel << "}\n"

	fil^ << "!" << globVar << " = !{"
	fil^ << "}\n"


	//if DebugPretty.Size() != 0
	//{
	//	fattyPrint := (char^ pStr) ==> {
	//		miniBuff := char[1024]
	//		c := 0
	//		i := 0
	//		while pStr[i] != 0
	//		{
	//			if pStr[i] in "\"\n"
	//			{
	//				switch pStr[i]
	//				{
	//					case '\"'
	//						miniBuff[c++] = '\\'
	//						miniBuff[c++] = '5'
	//						miniBuff[c++] = 'C'
	//						miniBuff[c++] = '\\'
	//						miniBuff[c++] = '2'
	//						miniBuff[c++] = '2'
	//					case '\n'
	//						miniBuff[c++] = '\\'
	//						miniBuff[c++] = '5'
	//						miniBuff[c++] = 'C'
	//				}
	//				if pStr[i] == '\n' and pStr[i+1] == 0
	//				{
	//					c -= 3
	//				}
	//			}else{
	//				miniBuff[c++] = pStr[i]
	//			}
	//			i += 1
	//		}
	//		miniBuff[c] = 0
	//		fil << miniBuff[0]&
	//	}
	//	fil << "module asm \".pushsection \\22.debug_gdb_scripts\\22, \\22MS\\22, @progbits,1\"\n"
	//	fil << "module asm \".byte 4\"\n"
	//	for DebugPretty
	//	{
	//		fil << "module asm \".asciz \\22"
	//		fattyPrint(it)
	//		fil << "\\5Cn\\22\"\n"
	//	}
	//	fil << "module asm \".byte 0\"\n"
	//	fil << "module asm \".popsection\"\n"
	//}
}
