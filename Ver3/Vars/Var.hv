TryParseVar := !(Token^ obj) -> BoxUnit^
{
	if obj == null or obj.Down == null
		return null

	iter := obj.Down

	if iter.Right == null
		return null
	if iter.Right?.GetValue() != ":="
		return null

	if iter.Down?.Right?.GetValue() == "."
	{
		return TryParseTypedefTemplate(obj)
	}

	name := StringSpan
	isSuffix := bool
	if iter is TokenIndent
	{
		name = iter->{TokenIndent^}.Value
	}else if iter is TokenString
	{
		name = iter->{TokenString^}.Value
		isSuffix = true
	}

	varToken := iter.Right.Right

	if varToken == null
		return null
	
	if varToken?.GetValue() == "thread_local" or varToken?.GetValue() == "task_local"
	{
		if not CurrentScope is in BoxFile
			varToken.EmitError("task/thread local must be at the root of file")

		if varToken.GetValue() == "task_local"
		{
			return new TaskLocalVarDelayed(name,varToken.Right)
		}

		return new GlobalVarDelayed(name,varToken)
	}

	if not (CurrentScope is BoxFile)
	{
		varType := ParseType(varToken)
	
		if varType != null
		{
			assert(CurrentScope is in BoxFunc) 
			vr := CreateVar(varType,false)
			resVar := new MemVarBorrowed(name,vr)
			ModifyStackAllocatedVar(vr,resVar.Inits)
			return resVar
		}
	}

	cls := TryParseClass(varToken)
	if cls != null
	{
		if cls is in BoxClass
		{
			cls2 := cls->{BoxClass^}
			cls2.SetName(name)
			return new TypeVar(name,cls2.ItType)
		}
		assert( cls is in BoxClassTemplate)
		cls3 := cls->{BoxClassTemplate^}
		cls3.SetName(name)
		return new TemplateTypeVar(name,cls3)
	}

	fnc := TryParseFunction(varToken)

	if fnc != null
	{
		if fnc is in BoxFuncTemplate
		{
			return new TemplateFuncVar(name,isSuffix,fnc->{BoxFuncTemplate^})
		}
		return new FuncVar(name,isSuffix,fnc->{BoxFunc^})
	}

	exeObj := BoxExeObj^
	if not (CurrentScope is BoxFile)
		exeObj = TryGetExeCall(varToken)
	if exeObj != null
	{
		if CurrentScope is in BoxFunc
		{
			if exeObj is BoxArrayHolder
			{
				exeObj = exeObj->{BoxArrayHolder^}.CreateDefaultUse()
			}
			if exeObj is ConstructorCallWrapper
			{
				objAsCnstr := exeObj->{ConstructorCallWrapper^}
				vr3 := new MemVarBorrowed(name,objAsCnstr.itVar)
				vr3.Inits.Push(objAsCnstr.itCall)
				vr3.Inits.Push(objAsCnstr.ExtraWork[^])

				return vr3
			}

			if exeObj is BoxLambdaHolder
			{
				hldr := exeObj->{BoxLambdaHolder^}
				if not hldr.IsOneFunc()
					varToken.EmitError("lambda function can not be template for variable") //todo better explanation
				exeObj = hldr.CreateOneFuncLambda()
			}

			vr := ParamFunc^
			mVar := MemVar^

			if exeObj is in BoxFuncCall
			{
				fc := exeObj->{BoxFuncCall^}
				vr = fc.ResultVar
			}

			if vr == null
			{
				isGC := IsGCPtr(exeObj.GetType())

				vr = CreateVar(exeObj.GetType(),false)
				mVar = new MemVarBorrowed(name,vr)

				objs2 := CheckExeDownList
				objs2.Push(vr.CreateCall())
				objs2.Push(exeObj)
				cnsts := List.{BoxExeConstObj^}
				setCall := CreateFuncCall(StringSpan("="),objs2,cnsts)
				if setCall == null
					return null
				mVar.Inits.Push(setCall)
			}else{
				mVar = new MemVarBorrowed(name,vr)
				mVar.Inits.Push(exeObj)
			}
			return mVar
		}else{

			if CurrentScope is BoxFile
			{
				if exeObj is BoxArrayHolder
				{
					ah := exeObj->{BoxArrayHolder^}
					if ah.GetArraySize() == 0
						varToken.EmitError("Can not use empty array as global variable")
					if not ah.IsConst()
						varToken.EmitError("Array must be made of constants")
					aVar := new GlobalVar(name,ah.GetArrayType())
					aVar.MemValue = ah.GetAsConst()
					assert(aVar.MemValue != null)
					return aVar
				}else{
					if not (exeObj is in BoxExeConstObj)
					{
						varToken.EmitError("Can not create global variable out of object")
					}
					cnst := exeObj->{BoxExeConstObj^}
					rVar := new GlobalVar(name,cnst.GetType())
					rVar.MemValue = cnst
					return rVar	
				}
			}
			assert(false)
		}
	}
	
	if CurrentScope is BoxFile
	{
		return new GlobalVarDelayed(name,varToken)
	}
	return null
}

TypeVar := class extend BoxUnit
{
	Name := StringSpan
	Value := Type^

	this := !(StringSpan name, Type^ val) -> void
	{
		Name = name
		Value = val
	}
}
TemplateTypeVar := class extend BoxUnit
{
	Name := StringSpan
	Value := BoxClassTemplate^

	this := !(StringSpan name, BoxClassTemplate^ val) -> void
	{
		Name = name
		Value = val
	}
}

ConstVar := class extend BoxUnit
{
	Name := StringSpan
	Value := BoxExeConstObj^

	this := !(StringSpan vName, BoxExeConstObj^ clFunc) -> void
	{
		Name = vName
		Value = clFunc
	}
}
NamedVar := class extend BoxUnit
{
	Name := StringSpan
}
MemVar := class extend NamedVar
{
	debId := int
	Value := ParamFunc^
	Inits := List.{BoxExeObj^}

	this := !(StringSpan vName, ParamFunc^ clFunc) -> void
	{
		Name = vName
		Value = clFunc
		debId = GetNewId()
	}
	GetVarType := !() -> Type^
	{
		return Value.GetType()->{TypeFunc^}.ResultType
	}
	PrintCode := virtual !(TIOStream^ f) -> void
	{
		assert(Value != null)
		Value.PrintCode(f)
		pDebugCode(f)
		doInits(f)
	}
	NotifyCaptureUse := virtual !() -> void
	{
		assert(Value != null)
		Value.NotifyCaptureUse()
	}
	PrintDebugMeta := virtual !(TIOStream^ f) -> void
	{
		Value.PrintDebugMeta(f)
		pDebugMeta(f)
	}
	pDebugCode := !(TIOStream^ f) -> void
	{
		if not (Value.IsDebuggable())
			return void
		//if Value is FuncLocalParamCaptured //TODO, get debug data for captured variables
		//	return void
		//if Value is FuncInputParamCaptured //TODO, get debug data for captured variables
		//	return void
		
		tp := Value.GetVarType()
		if DebugMode
		{
			f^ << "call void @llvm.dbg."
			if Value.IsValue()
			{
				f^ << "value"
			}else{
				f^ << "declare"
			}
			f^ << "(metadata "
			tp.PrintType(f)
			if not Value.IsValue()
				f^ << "*"
			if Value.IsRef() //TODO?
				f^ << "*"
			f^ << " " 
			Value.PrintDebugLine(f)
			f^ << " , metadata !" << debId << " , metadata !DIExpression()) , !dbg !" << GDebugLineCallId << "\n"
		}
			
	}
	doInits := !(TIOStream^ f) -> void
	{
		Inits[^].PrintDefaultUse(f)
	}
	pDebugMeta := !(TIOStream^ f) -> void
	{
		if not DebugMode
			return void

		if Value is in FuncLocalParam or Value is in FuncInputParam
		{
			pType := Value.GetType()->{TypeFunc^}.ResultType
			f^ << "!" << debId << " = !DILocalVariable(name: \"" << Name << "\" , scope:!" << GDebugScopeId << " , file:!" << GDebugFileId
			//if it.6 != 0
			//{
			//	f^ << ", arg: " << it.6
			//	f^ << ", flags: DIFlagArtificial"
			//}
			f^ << ", line: " << 0 << ", type:!"
			if Value.IsRef()
			{
				f^ <<pType.MakeDebugRef().MetaId
			}else{
				f^ <<pType.MetaId
			}
			f^ << ")\n"
		}
	}
}
MemVarRef := class extend MemVar
{
	this := !(StringSpan vName, ParamFunc^ clFunc) -> void
	{
		Name = vName
		Value = clFunc
		debId = GetNewId()
	}
}

MemVarBorrowed := class extend MemVar
{
	this := !(StringSpan vName, ParamFunc^ clFunc) -> void
	{
		this."MemVar.this"(vName,clFunc)
	}
	PrintCode := virtual !(TIOStream^ f) -> void
	{
		pDebugCode(f)
		doInits(f)
	}
	PrintDebugMeta := virtual !(TIOStream^ f) -> void
	{
		pDebugMeta(f)
	}
}

FuncVar := class extend BoxUnit
{
	Name := StringSpan
	Value := BoxUnit^
	IsSuffix := bool

	MemObj := BoxFunc^

	this := !(StringSpan nm, bool isSuf,BoxFunc^ obj) -> void
	{
		Name = nm
		IsSuffix = isSuf
		MemObj = obj
	}
	PrintCode := virtual !(TIOStream^ f) -> void
	{
		assert(MemObj != null)
		MemObj.PrintCode(f)
	}
	PrintDebugMeta := virtual !(TIOStream^ f) -> void
	{
		MemObj.PrintDebugMeta(f)
	}

	Work := virtual !() -> void
	{
		MemObj.SetName(Name)
		MemObj.Work()
	}
}

TemplateFuncVar := class extend BoxUnit
{
	Name := StringSpan
	Value := BoxUnit^
	IsSuffix := bool

	MemObj := BoxFuncTemplate^

	this := !(StringSpan nm, bool isSuf,BoxFuncTemplate^ obj) -> void
	{
		Name = nm
		IsSuffix = isSuf
		MemObj = obj
	}
	PrintCode := virtual !(TIOStream^ f) -> void
	{
		assert(MemObj != null)
		MemObj.PrintCode(f)
	}
	PrintDebugMeta := virtual !(TIOStream^ f) -> void
	{
		MemObj.PrintDebugMeta(f)
	}

	Work := virtual !() -> void
	{
		MemObj.SetName(Name)
		MemObj.Work()
	}
}
