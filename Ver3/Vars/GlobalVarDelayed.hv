GlobalVarDelayed := class extend GlobalVar
{
	downToken := Token^

	awaitHatch := THatch

	this := !(StringSpan sn,Token^ tkn) -> void
	{	
		Name = sn
		downToken = tkn

		c := this&
		SubWork(() ==> [c] {
			c.CheckVal()
		})
	}
	CheckVal := !() -> void
	{
		GParsedAllFiles.Await()

		typeToken := downToken
		isThreadLocal := false
		if downToken.GetValue() == "thread_local"
		{
			typeToken = downToken.Right
			isThreadLocal = true
		}
		if downToken.GetValue() == "task_local"
		{
			assert(false)
		}

		tp := ParseType(typeToken)

		if tp == null
		{
			MemValue = TryGetExeCall(typeToken) ->{BoxExeConstObj^} //TODO if not Const
			if MemValue? is BoxArrayHolder
			{
				ah := MemValue->{BoxArrayHolder^}
				if ah.GetArraySize() == 0
					typeToken.EmitError("Can not use empty array as global variable")
				if not ah.IsConst()
					typeToken.EmitError("Array must be made of constants")
				tp = ah.GetArrayType()
				MemValue = ah.GetAsConst()
			}
			assert(tp != GTypeVoid)
			if MemValue != null
				tp = MemValue.GetType()
		}

		if tp != null
		{
			assert(tp != GTypeVoid)
			Value = new GlobalVarFunc(Name,tp)
			if isThreadLocal
				Value->SetType(ThreadLocalVarFunc)
		}else{
			downToken.EmitError("Can not get type of global variable")
		}

		awaitHatch.Emit()
	}
	AwaitType := virtual !() -> void
	{
		awaitHatch.Await()
	}
	Work := virtual !() -> void
	{

	}
}
