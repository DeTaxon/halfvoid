TryParseFunction := !(Token^ obj) -> BoxFunc^
{
	Attr := FuncAttributes

	if obj == null or obj.Down == null return null

	iter := obj.Down

	switch iter.GetValue() //TODO to cycle
	{
		case "virtual"
			Attr.IsVirtual = true
			iter = iter.Right
			if iter == null
				return null
		case void
	}

	if iter.GetValue() != "!"
		return null
	
	iter = iter.Right
	if iter == null return null

	if iter.GetValue() != "()"
		return null

	brackets := iter

	iter = iter.Right
	if iter == null return null

	resultToken := Token^

	if iter.GetValue() == "->" 
	{
		iter = iter.Right
		if iter == null return null
		resultToken = iter

		iter = iter.Right
		if iter == null return null
	}

	if iter.GetValue() != "{}" return null

	return new BoxFuncBody(Attr,brackets,null,resultToken,iter)
}

FuncAttributes := class
{
	IsMethod := bool
	IsVirtual := bool
	IsStatic := bool
		
	"=" := default
}

BoxFunc := class extend BoxUnit
{
	WorkBody := virtual !() -> void
	{
	}
	SetName := virtual !(StringSpan nm) -> void
	{
	}
	ReadyState := virtual !() -> void
	{
	}
}

BoxFuncDeclare := class extend BoxFunc
{
	itType := Type^
	itName := StringSpan
	this := !(Type^ tp, StringSpan fName) -> void
	{
		itType = tp
		itName = fName
	}

	PrintCode := virtual !(TIOStream f) -> void
	{
	}
}

BoxFuncBody := class extend BoxFunc
{
	headerHatch := THatch

	ItType := Type^
	ItTypeHatch := THatch

	Attrs := FuncAttributes

	Name := StringSpan

	inps1 := Token^
	resTyp := Token^
	bdy := Token^

	this := !(FuncAttributes atrs,Token^ brackets1,Token^ brackets2, Token^ resToken,Token^ bodyIn) -> void
	{
		assert(brackets2 == null)//not implemented
		Attrs = atrs
		inps1 = brackets1
		resTyp = resToken
		bdy = bodyIn
	}

	GetType := !() -> Type^
	{
		ItTypeHatch.Await()
		return ItType
	}

	StartedParse := bool
	ParseBody := !() -> void
	{
		if StartedParse
			return void
		StartedParse = true
		cls := this&
		TSpawnTask(() ==> [cls] {
			cls.WorkBody()
		})
	}
	SetName := virtual !(StringSpan nm) -> void
	{
		Name = nm
	}
	
	ParseHeader := !() -> void
	{
		SyntaxCompress(inps1,LexHVInputVars)

		k := 0
		args := Type^[40] //TODO: infinite args?
		refs := bool[40]
		isVargs := false

		objs := HybridQueue.{Token^,6}
		defer objs.Destroy()

		itr := inps1.Down

		checkObjs := () ==> {

			if objs.Size() == 2
			{
				args[k] = GetType(objs[0])
				refs[k] = false
				assert(args[k] != null) //TODO error
				k += 1
			}else{
				assert(false)
			}
			objs.Clear()
		}

		while itr != null
		{
			if itr.GetValue() == ","
			{
				checkObjs()
			}else
			{
				objs.Push(itr)
			}
			itr = itr.Right
		}
		if objs.Size() != 0
			checkObjs()
		outType := GetType(resTyp)
		resRef := false
		//TODO ref check

		ItType = GetFuncType(k,args[0]&,refs[0]&,outType,resRef,isVargs)
	}

	Work := virtual !() -> void
	{
		if Name.Get() == null
			return void

		ParseHeader()

		if CurrentCodeSpace != null
		{
			//assert(not CurrentCodeSpace.Functions[Name].Contain()) TODO
			CurrentCodeSpace.Functions[Name].Push(this&)
			return void
		}
		assert(false) //TODO: not using anon functions
	}

	body := BoxBlock^
	readyState := THatch
	WorkBody := virtual !() -> void
	{
		UnitStack.PushFront(this&)
		defer UnitStack.Pop()
		defer readyState.Emit()
		
		body = new BoxBlock(bdy)
		body.Work()
	}
	WaitReadyState := virtual !() -> void
	{
		readyState.Await()
	}

	PrintCode := virtual !(TIOStream f) -> void
	{
	}
}

BoxBlock := class extend BoxUnit
{
	down := Token^
	exeLines := List.{BoxUnit^} //TODO : to hybrid
	this := !(Token^ bdy) -> void
	{
		down = bdy
	}
	Work := virtual !() -> void
	{
		SyntaxCompress(down,PriorityData)

		iter := down.Down
		stackAtStart := UnitStack.Size()

		while iter != null
		{
			//TODO: check switch,if,while
			
			pad := new BoxExeLine
			pad.DoLine(iter)
			UnitStack.PushFront(pad)
		
			iter = iter.Right
		}

		while UnitStack.Size() > stackAtStart
		{
			UnitStack.Pop()
		}

		down.Print(0)
	}
}
BoxExeLine := class extend BoxUnit
{

	exitLabel := BoxLabel^
	GetLabel := !() -> BoxLabel^
	{
		if exitLabel == null
			exitLabel = new BoxLabel()
		return exitLabel
	}

	DoLine := !(Token^ itm) -> void
	{
	}

}

labelIdIterator := 1
BoxLabel := class
{
	id := int
	this := !() -> void
	{
		id = labelIdIterator
		labelIdIterator += 1
	}
	PrintCode := virtual !(TIOStream f) -> void
	{
		assert(false)
	}
}



