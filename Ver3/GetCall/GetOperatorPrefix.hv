TryGetPrefixOperator := !(Token^ itm) -> BoxExeObj^
{
	if itm.Down?.GetValue() == "return" or  itm.Down?.GetValue() == "yield"
	{
		isYield := false
		if itm.Down.GetValue() == "yield"
			isYield = true

		resultCall := BoxExeObj^

		preRes := ReturnHalfState^

		//TODO check return type vs func result. + result ref

		if itm.Down.Right is TokenIndent and itm.Down.Right->{TokenIndent^}.Value == "void"
		{
			preRes = new ReturnHalfState(null,isYield)
		}else{
			dwnRes := TryGetExeCall(itm.Down.Right)
			assert(dwnRes != null) //TODO EmitError
			preRes = new ReturnHalfState(dwnRes,isYield)
		}

		if CurrentFunc.Attrs.IsAutoResult
		{
			CurrentFunc.Returns.Push(preRes)
			return preRes
		}

		preRes.ResolveStep()
		return preRes.GetReturnObj()
	}
	if itm.Down?.GetValue() == "defer"
	{
		lmbdPre := CreateHeadlessLambda(itm.Down.Right)->{BoxLambdaHolder^}
		assert(lmbdPre is BoxLambdaHolder)
		//assert(lmbdPre.IsOneFunc())
		lmbd := lmbdPre.CreateOneFuncLambda()
		tp := lmbd.GetType()
		assert(tp is in TypePoint and tp.Base is TypeClass)
		arr := List.{BoxExeConstObj^}
		arr.Push(GetConstType(tp.Base))
		newType := GCDeferLambda.GetClass(arr).ItType
		arr.Destroy()
		return innerTrySetType(lmbd,newType)
	}
	return null
}
