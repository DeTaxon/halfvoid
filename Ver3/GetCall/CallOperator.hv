TryCheckMathOperatorCall := !(Token^ itm) -> BoxExeObj^
{
	if itm == null return null
	if itm.Down == null return null
	if itm.Down.Right == null return null
	if itm.Down.Right.Right == null return null
	if itm.Down.Right.Right.Right != null return null

	if not HVOperators.Contain(itm.Down.Right.GetValue())
		return null
	if itm.Down.Right.GetValue() == "->" return null

	tmpList := CheckExeDownList
	defer tmpList.Destroy()

	oper := itm.Down.Right.GetValue()

	if oper == "or" or oper == "and"
	{
		return TryGetAndOrCall(itm)
	}

	tmpList.Push(TryGetExeCall(itm.Down))
	tmpList.Push(TryGetExeCall(itm.Down.Right.Right))

	if tmpList[0] == null or tmpList[1] == null
		itm.EmitError("Unknown error")


	return TryComputeOperators(oper,tmpList)?

	consts := List.{BoxExeConstObj^}
	return CreateFuncCall(oper,tmpList,consts)?

	return null
}

TryComputeOperators := !(StringSpan oper, CheckExeDownList  objs) -> BoxExeObj^
{
	if oper == "==" or oper == "!="
	{
		if objs.Size() != 2
			return null

		c1 := objs[0]
		c2 := objs[1]

		if c1 == c2
		{
			if oper == "=="
				return GBoolTrue
			return GBoolFalse
		}
		if c1 == GObjNone or c2 == GObjNone
		{
			if oper == "=="
				return GBoolFalse
			return GBoolTrue
		}

		if not objs[^].IsConst //CONSTANTS CHECK ONLY NEXT
			return null


		if c1 is BoxExeString and c2 is BoxExeString
		{
			if oper == "=="
				return GBoolFalse
			return GBoolTrue
		}

	}
}
