
TryCheckRegularFuncCall := !(Token^ itm) -> BoxExeObj^
{
	if itm == null or itm.Down == null or itm.Down.Right == null
		return null
	if itm.Down?.Right.GetValue() != "()"
		return null
	brc := itm.Down.Right
	constsToken := brc.Right
	if constsToken != null
	{
		if constsToken.GetValue() != "."
			return null
		constsToken = constsToken.Right
		if constsToken == null or constsToken.GetValue() != "{}"
			return null
		if constsToken.Right != null
			return null
	}

	Objs := CheckExeDownList
	defer Objs.Destroy()
	CheckFuncCallBrackets(brc,Objs)

	consts := List.{BoxExeConstObj^}
	defer consts.Destroy()
	if constsToken != null
	{
		SyntaxCompress(constsToken,LexHVInputVars)
		CheckFuncCallConsts(constsToken,consts)
	}


	cnstrCall := ParseType(itm.Down)
	if cnstrCall != null
	{
		c := CreateVar(cnstrCall,false)
		cCall := c.CreateCall()

		constrObj := innerTryGetMethodCall(StringSpan("this"),cCall,Objs,consts)
		if constrObj != null
			return new ConstructorCallWrapper(c,constrObj)

		objs22 := CheckExeDownList
		objs22.Push(cCall)
		objs22.Push(Objs[^])
		check2 := CreateFuncCall(StringSpan(". this"),objs22)
		if check2 != null
			return new ConstructorCallWrapper(c,check2)
		itm.EmitError("Constructor not found")
	}
	
	if itm.Down is TokenIndent
	{
		asInd := itm.Down->{TokenIndent^}
		for ob : UnitStack
		{
			if ob is in BoxFuncBody and asInd.Value != "this"
			{
				fnc := ob->{BoxFuncBody^}
				if fnc.Attrs.IsMethod
				{
					resTryCall := BoxExeObj^
					try
					{
						tkn1 := TokenIndent(StringSpan("this"))
						tkn1.Line = itm.Line
						vr := TryGetExeCall(tkn1&)

						resTryCall = innerTryGetMethodCall(asInd.Value,vr,Objs,consts) //TODO: check for recursion this.func -> func -> this.func
					}catch(IException^ e){}
					if resTryCall != null
						return resTryCall
				}
			}
		}

		resFunc := BoxExeObj^
		try
		{
			resFunc = CreateFuncCall(asInd.Value,Objs,consts)
		}catch(IException^ e)
		{}
		if resFunc != null
			return resFunc
	}
	dwnItem := TryGetExeCall(itm.Down)
	if dwnItem != null
	{
		return innerTryGetPtrCall(dwnItem,Objs)?
		return innerTryGetSkobCall(dwnItem,Objs,consts)?
	}
	itm.EmitError("Can not parse function call")
	assert(false)
}

innerTryGetPtrCall := !(BoxExeObj^ dwnItem, CheckExeDownList Objs) -> BoxExeObj^
{
	dType := dwnItem.GetType()
	if dType is in TypePoint and dType.Base is TypeFunc
	{
		fType := dType.Base->{TypeFunc^}
		if CmpFuncPriority(fType,Objs,0) != CmpNoExchange
		{
			return new BoxFuncPointerCall(dwnItem,Objs)
		}
	}
	return null
}
innerTryGetSkobCall := !(BoxExeObj^ dwnItem, CheckExeDownList Objs,List.{BoxExeConstObj^} consts) -> BoxExeObj^
{
	dType := dwnItem.GetType()
	cls := BoxClass^
	if dType is TypeClass
	{
		cls = dType->{TypeClass^}.ToClass
	}else{
		if dType is in TypePoint and dType.Base is TypeClass
		{
			cls = dType.Base->{TypeClass^}.ToClass
		}
	}
	if cls != null
	{
		Objs2 := CheckExeDownList
		Objs2.Push(dwnItem)
		Objs2.Push(Objs[^])
		resFunc := BoxFunc^
		cls.GetMethods(StringSpan("()"), x ==> {
			resFunc = GetBestFunc(x,Objs2,consts)->{BoxFunc^}
		})
		if resFunc != null
		{
			assert(resFunc is in BoxFunc) //TODO: template
			return resFunc.CreateCall(Objs2)
		}
	}
	return null
}

ConstructorCallWrapper := class extend BoxExeObj
{
	itVar := ParamFunc^
	itCall := BoxExeObj^
	varCall := BoxExeObj^
	this := !(ParamFunc^ vr, BoxExeObj^ bj) -> void
	{
		itVar = vr
		itCall = bj
		varCall = vr.CreateCall()
		ObjType = vr.GetVarType()
	}
	IsMem := virtual !() -> bool
	{
		return true
	}

	PrintPointPre := virtual !(TIOStream^ f) -> void
	{
		itCall.PrintDefaultUse(f)
		varCall.PrintPointPre(f)
	}
	PrintPointUse := virtual !(TIOStream^ f) -> void
	{
		varCall.PrintPointUse(f)
	}
	PrintPre := virtual !(TIOStream^ f) -> void
	{
		assert(false)
	}
	PrintUse := virtual !(TIOStream^ f) -> void
	{
		assert(false)
	}
}
