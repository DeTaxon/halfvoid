TryGetArrayCall := !(Token^ itm) -> BoxExeObj^
{
	if itm?.Down?.GetValue() == "!" and itm.Down.Right?.GetValue() == "[]"
	{
		//continue
	}else{
		return null
	}

	objs := CheckExeDownList
	allConsts := true
	allType := Type^

	itr := itm.Down.Right.Down
	while itr != null
	{
		if itr.GetValue() != ","
		{
			o := TryGetExeCall(itr)
			if o == null
				itr.EmitError("could not get array element\n")
			if not (o is in BoxExeConstObj)
				allConsts = false
			if allType == null
			{
				allType = o.GetType()
			}else{
				allType = TypeFight(allType,o.GetType())
				if allType == null
					itr.EmitError("all elements of array must be same type\n")
			}
			objs.Push(o)
		}
		itr = itr.Right
	}

	if objs.Size() == 0
	{
		return new BoxArrayHolder()
	}

	if allConsts
	{
		arrType := allType.GetArray(objs.Size())
		glbVar := CreateGlobalVar(StringSpan("anon"),arrType,false)
		cnst := new BoxArrayConst(arrType)
		cnst.dwns.Push(objs[^]->{BoxExeConstObj^})
		glbVar.MemValue = cnst

		return glbVar.Value.CreateCall()
	}

	cnsts := List.{BoxExeConstObj^}
	cnsts.Push(GetConstType(allType.GetArray(objs.Size())))
	resCall := CreateFuncCall(StringSpan("![]"),objs,cnsts)
	cnsts.Destroy()

	if resCall == null
		itm.EmitError("could not create array, function ![] not found")
	return resCall
}

BoxArrayConst := class extend BoxExeConstObj
{
	dwns := List.{BoxExeConstObj^} //todo Vector is better

	this := !(Type^ tp) -> void
	{
		ObjType = tp
	}
	PrintConst := virtual !(TIOStream^ f) -> void
	{
		f^ << "["
		for it,i : dwns
		{
			if i != 0
				f^ << ","
			it.PrintConst(f)
		}
		f^ << "]"
	}

}

BoxArrayHolder := class extend BoxExeObj
{
	vals := CheckExeDownList
	this := !() -> void
	{
		ObjType = GTypeVoid
	}
	CreateViewArray := !(Type^ tp) -> BoxExeObj^
	{
		if vals.Size() == 0
		{
			objs := CheckExeDownList
			cnsts := List.{BoxExeConstObj^}
			cnsts.Push(GetConstType(GetViewBaseType(tp)))
			resFunc := ArrayViewCreateEmptyArray.GetFunc(objs,cnsts)
			cnsts.Destroy()
			return resFunc.CreateCall()
		}
		assert(false)
		return null
	}
}
IsViewType := !(Type^ tp) -> bool
{
	if not (tp is in TypePoint)
		return false
	if not (tp.Base is in TypeClass)
		return false
	cls := tp.Base->{TypeClass^}.ToClass

	InternalsHatch.Await()
	if cls.TemplateParent != ArrayViewTemplate
		return false
	return true
}

GetViewBaseType := !(Type^ tp) -> Type^
{
	if not (tp is in TypePoint)
		return null
	if not (tp.Base is in TypeClass)
		return null
	cls := tp.Base->{TypeClass^}.ToClass

	InternalsHatch.Await()
	if cls.TemplateParent != ArrayViewTemplate
		return null
	return cls.Constants?.Constants[0]->{ConstType^}.Value
	return null
}
