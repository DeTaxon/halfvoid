TryGetFieldCall := !(Token^ itm) -> BoxExeObj^
{
	if itm == null return null
	if itm.Down == null return null
	if itm.Down.Right == null return null
	if itm.Down.Right.Right == null return null
	if itm.Down.Right.Right.Right != null return null
	if itm.Down.Right.GetValue() != "." return null

	val := TryGetExeCall(itm.Down)
	if val == null
		itm.Down.EmitError("Could not get left of . object")
	return innerTryGetFieldCall(val,itm.Down.Right.Right)
}

innerTryGetFieldCall := !(BoxExeObj^ val,Token^ rObj) -> BoxExeObj^
{
	if rObj is TokenIndent
	{
		name := rObj->{TokenIndent^}.Value

		cls := BoxClass^
		typ := val.GetType()

		if typ is TypeClass
		{
			cls = typ->{TypeClass^}.ToClass
		}else{
			if typ is in TypePoint and typ.Base is TypeClass
			{
				cls = typ.Base->{TypeClass^}.ToClass
			}
		}
		if cls != null
		{
			cls.AwaitTypeState()
			fld := cls.GetField(name)

			//if fld == null
			//	return null //TODO use exception path
			//if fld == null

			if fld != null
			{
				itms := CheckExeDownList
				itms.Push(val)
				return new BoxFuncCall(fld,itms)
			}
		}
	}

	rObjVal := BoxExeObj^

	try{
		rObjVal = TryGetExeCall(rObj)
	}catch(IException^ e) {}

	if rObjVal? is BoxExeInt
	{
		fieldInd := rObjVal->{BoxExeInt^}.Value

		typ := val.GetType()
		if typ is TypeClass or typ.Base? is TypeClass
		{
			cls :=  BoxClass^
			if typ is TypeClass
			{
				cls = typ->{TypeClass^}.ToClass
			}else{
				cls = typ.Base->{TypeClass^}.ToClass
			}
			
			fld := cls.GetFieldByIndex(fieldInd)
			if fld == null
				rObj.EmitError("field does not exist") //todo: better error

			itms := CheckExeDownList
			itms.Push(val)
			return new BoxFuncCall(fld,itms)
		}
	}
	rObj.EmitError("Field not found")

	return null
}
