TryCheckMathOperatorCall := !(Token^ itm) -> BoxExeObj^
{
	if itm == null return null
	if itm.Down == null return null
	if itm.Down.Right == null return null
	if itm.Down.Right.Right == null return null
	if itm.Down.Right.Right.Right != null return null

	if not HVOperators.Contain(itm.Down.Right.GetValue())
		return null
	if itm.Down.Right.GetValue() == "->" return null

	tmpList := CheckExeDownList

	oper := itm.Down.Right.GetValue()

	if oper == "or" or oper == "and"
	{
		return TryGetAndOrCall(itm)
	}
	tmpList.Push(TryGetExeCall(itm.Down))
	tmpList.Push(TryGetExeCall(itm.Down.Right.Right))

	return innerTryGetInfixCall(oper,tmpList,itm)
}

innerTryGetInfixCall := !(StringSpan oper,CheckExeDownList lst,Token^ errToken)
{
	if lst[0] == null or lst[1] == null
		errToken.EmitError("Unknown error")
	assert(lst.Size() == 2)

	tmpList := CheckExeDownList
	if oper == "in"
	{
		tmpList.Push(lst[1])
		tmpList.Push(lst[0])
	}else{
		tmpList.Push(lst[0])
		tmpList.Push(lst[1])
	}

	return TryComputeOperators(oper,tmpList)?

	consts := List.{BoxExeConstObj^}
	return CreateFuncCall(oper,tmpList,consts)?

	if tmpList[0].GetType() is in TypeClass
	{
		cnsts := List.{BoxExeConstObj^}
		objs8 := CheckExeDownList
		objs8.Push(tmpList[1])
		return innerTryGetMethodCall(oper,tmpList[0],objs8,cnsts)?
	}

	return null
}

TryComputeOperators := !(StringSpan oper, CheckExeDownList  objs) -> BoxExeObj^
{
	if oper == "==" or oper == "!="
	{
		if objs.Size() != 2
			return null

		c1 := objs[0]
		c2 := objs[1]

		if c1 == c2
		{
			if oper == "=="
				return GBoolTrue
			return GBoolFalse
		}
		if c1 == GObjNone or c2 == GObjNone
		{
			if oper == "=="
				return GBoolFalse
			return GBoolTrue
		}

		if not objs[^].IsConst //TODO: CONSTANTS CHECK ONLY NEXT
			return null


		if c1 is BoxExeString and c2 is BoxExeString
		{
			if oper == "=="
				return GBoolFalse
			return GBoolTrue
		}

	}
}
