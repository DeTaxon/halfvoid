TryCheckMathOperatorCall := !(Token^ itm) -> BoxExeObj^
{
	if itm == null return null
	if itm.Down == null return null
	if itm.Down.Right == null return null
	if itm.Down.Right.Right == null return null

	if itm.Down.Right.GetValue() == "not" and itm.Down.Right.Right.GetValue() == "in"
	{
		lst3 := CheckExeDownList
		lst3.Push(TryGetExeCall(itm.Down))
		lst3.Push(TryGetExeCall(itm.Down.Right.Right.Right))

		res := innerTryGetInfixCall(StringSpan("in"),lst3,itm)
		if res == null
			return null

		lst4 := CheckExeDownList
		lst4.Push(res)
		cnsts := List.{BoxExeConstObj^}
		return CreateFuncCall(StringSpan(". not"),lst4,cnsts)
	}

	if itm.Down.Right.Right.Right != null return null

	if not HVOperators.Contain(itm.Down.Right.GetValue())
		return null
	if itm.Down.Right.GetValue() == "->" return null

	tmpList := CheckExeDownList

	oper := itm.Down.Right.GetValue()

	if oper == "or" or oper == "and"
	{
		return TryGetAndOrCall(itm)
	}


	tmpList.Push(TryGetExeCall(itm.Down))
	tmpList.Push(TryGetExeCall(itm.Down.Right.Right))


	if oper in ![">",">=","<","<=","==","!="]
	{
		return innertTryGetCompareOverSpaceship(oper,tmpList,itm)?
	}

	res1 := innerTryGetInfixCall(oper,tmpList,itm)
	if res1 != null
		return res1

	return innerTryGetOperMeta(itm)?
	

}

innertTryGetCompareOverSpaceship := !(StringSpan oper,CheckExeDownList lst,Token^ debugItem) -> BoxExeObj^
{
	mdlCall := innerTryGetInfixCall(StringSpan("<=>"),lst,debugItem)
	if mdlCall != null
	{
		objs7 := CheckExeDownList
		objs7.Push(mdlCall)

		zero := GetExeInt(0)->{BoxExeObj^}
		if mdlCall.GetType() != GTypeInt
		{
			zero = GetExchange(zero,mdlCall.GetType())
		}
		if zero == null
			return null
		objs7.Push(zero)
		switch oper
		{
			case ">"
				return innerTryGetInfixCall(StringSpan(">"),objs7,debugItem)
			case ">="
				return innerTryGetInfixCall(StringSpan(">="),objs7,debugItem)
			case "<"
				return innerTryGetInfixCall(StringSpan("<"),objs7,debugItem)
			case "<="
				return innerTryGetInfixCall(StringSpan("<="),objs7,debugItem)
			case "=="
				return innerTryGetInfixCall(StringSpan("=="),objs7,debugItem)
			case "!="
				return innerTryGetInfixCall(StringSpan("!="),objs7,debugItem)
		}
	}
}

innerTryGetInfixCall := !(StringSpan oper,CheckExeDownList lst,Token^ errToken) -> BoxExeObj^
{
	if lst[0] == null or lst[1] == null
	{
		return null
	}
	assert(lst.Size() == 2)

	tmpList := CheckExeDownList
	if oper == "in"
	{
		tmpList.Push(lst[1])
		tmpList.Push(lst[0])
	}else{
		tmpList.Push(lst[0])
		tmpList.Push(lst[1])
	}

	if tmpList[0] is FieldSpaceHolder
	{
		holder := tmpList[0]->{FieldSpaceHolder^}

		lst2 := CheckExeDownList
		for it,i : tmpList
		{
			if i == 0
			{
				lst2.Push(holder.GetObject())
			}else{
				lst2.Push(it)
			}
		}
		
		holderType := holder.GetObject().GetType()
		cls := BoxClass^
		if holderType is TypeClass
		{
			cls = holderType->{TypeClass^}.ToClass
		}else{
			assert(holderType is in TypePoint and holderType.Base is TypeClass)
			cls = holderType.Base->{TypeClass^}.ToClass
		}
		resFunc := BoxUnit^
		cls.GetMethodsInFields(oper,holder.GetFieldSpace(),(fncs) ==> {
			cnsts := List.{BoxExeConstObj^}
			resFunc = GetBestFunc(fncs,lst2,cnsts,false)
		})
		if resFunc == null
			errToken.EmitError("can not get function")
		if resFunc is in BoxFunc
		{
			return resFunc->{BoxFunc^}.CreateCall(lst2)
		}else{
			errToken.EmitError("Unknown function recived, software error")
		}
		assert(false)
	}

	return TryComputeOperators(oper,tmpList)?

	consts := List.{BoxExeConstObj^}
	return CreateFuncCall(oper,tmpList,consts)?

	if tmpList[0].GetType() is in TypeClass
	{
		cnsts := List.{BoxExeConstObj^}
		objs8 := CheckExeDownList
		objs8.Push(tmpList[1])
		return innerTryGetMethodCall(oper,tmpList[0],objs8,cnsts)?
	}

	return null
}

TryComputeOperators := !(StringSpan oper, CheckExeDownList  objs) -> BoxExeObj^
{
	if oper in !["==","!="]
	{
		if objs.Size() != 2
			return null

		c1 := objs[0]
		c2 := objs[1]

		if c1 == c2
		{
			if oper == "=="
				return GBoolTrue
			return GBoolFalse
		}
		if c1 == GObjNone or c2 == GObjNone
		{
			if oper == "=="
				return GBoolFalse
			return GBoolTrue
		}

		if not objs[^].IsConst //TODO: CONSTANTS CHECK ONLY NEXT
			return null


		if c1 is BoxExeString and c2 is BoxExeString
		{
			if oper == "=="
				return GBoolFalse
			return GBoolTrue
		}

		if c1 is BoxExeInt and c2 is BoxExeInt
		{
			if oper == "=="
				return GBoolFalse
			return GBoolTrue
		}

	}
	if oper == "<=>"
	{
		if objs.Size() != 2
			return null

		c1 := objs[0]
		c2 := objs[1]

		if c1 == c2
		{
			return GetExeInt(0)
		}
		if c1.GetType() == c2.GetType()
		{
			if c1 is BoxExeString and c2 is BoxExeString
			{
				return GetExeInt(c1->{BoxExeString^}.val <=> c2->{BoxExeString^}.val)
			}
		}
	}
}
