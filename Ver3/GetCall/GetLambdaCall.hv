TryGetLambdaCall := !(Token^ itm) -> BoxExeObj^
{
	if itm.Down?.Right?.GetValue() == "==>"
	{
	}else{
		return null
	}

	bodyToken := Token^
	typeToken := Token^
	captureToken := Token^

	iter := itm.Down.Right.Right

	while iter.GetValue() != "{}"
	{
		if iter.GetValue() == "[]"
		{
			captureToken = iter
		}else{
			typeToken = iter
		}
		iter = iter.Right
	}
	bodyToken = iter


	res := new BoxLambdaHolder(itm.Down,bodyToken,typeToken,captureToken)

	if res.IsOneFunc()
	{
		tplTypeBefore := CurrentFunc.GetCaptureTuple().ItType

		newFunc := res.GetOneFunc()->{BoxFuncBody^} //Vars captured
		
		miniObj := CheckExeDownList
		fncFnc := new FuncPointerParam(newFunc)
		fncPtr := new BoxFuncCall(fncFnc,miniObj)
		newFunc.ParseBodyForced()
		newFunc->{BoxFuncBody^}.WorkBodyCaptures()


		empty := CheckExeDownList

		getTupleVar := BoxExeObj^

		tplType := CurrentFunc.GetCaptureTuple().ItType
		newFunc->{BoxFuncBody^}.ThisCaptureTupleType = tplType

		if tplType != tplTypeBefore
		{
			tplVar := new FuncResultParam(tplType.GetPoint(),false)
			newFunc->{BoxFuncBody^}.CreateGetCaptureCall()
			CurrentFunc.CapturedVarsGets.Push(tplVar)

			getTupleVar = new BoxFuncCall(tplVar,empty)
		}else{
			getTupleVar = GetExchange(GObjNull,tplType.GetPoint())
		}


		objs := CheckExeDownList
		objs.Push(fncPtr)
		objs.Push(getTupleVar)

		lst := List.{BoxExeConstObj^}
		lst.Push(GetConstType(newFunc.GetYieldTuple().ItType))

		createLambdaFunc := TemplateInternalCreateLambda.GetFunc(objs,lst)
		lst.Destroy()

		return new BoxFuncCall(createLambdaFunc,objs)
	}

	return res
}
