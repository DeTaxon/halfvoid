GetForCycle := !(Token^ itm) -> BoxUnit^
{
	forItems := HybridQueue.{ForSubObjects,5}

	iter := itm.Down.Right

	if iter.Right.GetValue() == "{}"
	{
		//TODO, name only
	}else{
		while iter.GetValue() != "{}" //TODO non {} variant
		{
			if iter.GetValue() == ","
				iter = iter.Right
			
			forElement := ForSubObjects

			if not (iter is TokenIndent)
				iter.EmitError("not a name for cycle element variable") //todo better error explanation
			
			name := iter->{TokenIndent^}.Value
			index := StringSpan("")

			iter = iter.Right

			if iter.GetValue() == ","
			{
				iter = iter.Right

				if not (iter is TokenIndent)
					iter.EmitError("not a name for cycle index variable") //todo better error explanation
				
				index = iter->{TokenIndent^}.Value

				iter = iter.Right
			}

			assert(iter.GetValue() == ":")
			iter = iter.Right

			forElement.ValueName = name
			forElement.IndexName = index
			forElement.DownToken = iter

			forItems.Push(forElement)

			iter = iter.Right
		}
	}
	assert(iter.GetValue() == "{}")

	return GetForParsed(iter,forItems)
}

GetForParsed := !(Token^ itm,HybridQueue.{ForSubObjects,5} lst) -> BoxUnit^
{
	return GetForParsed(itm,lst,() ==> { //TODO REFACTOR, IT'S OVERCOMPLICATED
		if itm.GetValue() == "{}"
			return new BoxBlock(itm)
		
		pad := new BoxExeLine()
		pad.DoLine(itm)
		return pad
	})
}
GetForParsed := !(Token^ itm,HybridQueue.{ForSubObjects,5} lst,!()&->BoxUnit^ cb) -> BoxUnit^
{
	return new BoxBlockBreak(itm, () ==> {

		forLine := new BoxExeLine()
		forLine.ItToken = itm

		containMeta := false

		for it : lst
		{
			dwnRes := TryGetExeCall(it.DownToken)

			if dwnRes == null
				it.DownToken.EmitError("Could not get result for cycle over obj")
			

			if dwnRes is in BoxMetaObj
			{
				//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< META VERSION

				if not dwnRes->{BoxMetaObj^}.IsMetaIteratable()
					it.DownToken.EmitError("Meta object is not iteratable")

				it.IsMeta = true
				it.MetaObj = dwnRes->{BoxMetaObj^}

				containMeta = true
			}else{
				//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< REGULAR VERSION
				it.DownResult = dwnRes
			}//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<END
		}

		if containMeta
		{
			return new BoxForOverMeta(lst,itm)
		}

		resFor := new BoxFor()
		resFor.values.Push(lst[^])
		resFor.HeadLine = forLine

		resFor.StepTwo(itm,cb)

		return resFor
	})
}

ForSubObjects := class
{
	ValueName := StringSpan
	IndexName := StringSpan
	DownToken := Token^

	DownResult := BoxExeObj^
	ValueVar := MemVar^
	IndVar := NamedVar^
	GetCall := BoxExeObj^
	IsFinished := BoxExeObj^
	HaveValue := BoxExeObj^
	InitStep := ParamFunc^
	NextCheck := BoxLabel^

	MetaObj := BoxMetaObj^
	IsMeta := bool

	CheckRegularStep := !() -> void
	{

		dwnRes := DownResult

		objs7 := CheckExeDownList
		objs7.Push(dwnRes)
		getForCall := BoxExeObj^
		getForCall = CreateFuncCall(StringSpan("for"),objs7)

		if getForCall == null
		{
			empty7 := CheckExeDownList
			cnsts6 := List.{BoxExeConstObj^}
			getForCall = innerTryGetMethodCall(StringSpan("for"),dwnRes,empty7,cnsts6)
		}

		if getForCall == null
			DownToken.EmitError("Object does not have operator for")

		dwnVar := new FuncResultParam(getForCall)
		
		cnsts := List.{BoxExeConstObj^}
		objs := CheckExeDownList

		haveValue := innerTryGetMethodCall(StringSpan("HaveValue"),dwnVar.CreateCall(),objs,cnsts)
		checkFunc := haveValue
		iFins := BoxExeObj^
		if haveValue == null
		{
			iFins = innerTryGetMethodCall(StringSpan("IsFinished"),dwnVar.CreateCall(),objs,cnsts)
			checkFunc = iFins
		}

		if checkFunc == null
			DownToken.EmitError("iteratable object does not contain IsFinished or HaveValue")
		if checkFunc.GetType() != GTypeBool
			DownToken.EmitError("IsFinished or HaveValue return non boolean type")
		
		mainCall := dwnVar.CreateCall()
		dwnType := mainCall.GetType()

		cls := BoxClass^
		if dwnType is in TypeClass
		{
			cls = dwnType->{TypeClass^}.ToClass
		}
		if dwnType is in TypePoint and dwnType.Base is in TypeClass
		{
			cls = dwnType.Base->{TypeClass^}.ToClass
		}
		
		if cls == null
			DownToken.EmitError("unknown iteretable result")
		
		objCall := BoxUnit^
		cls.GetMethods(StringSpan("()"),x ==> {
			if x.Size() == 1
			{
				objCall = x[0]
			}
		})

		if objCall == null
			DownToken.EmitError("iteratable object must have exacly one operator ()")
		
		if not (objCall is in BoxFunc)
			DownToken.EmitError("operator () is not a function")
		
		fncOperType := objCall->{BoxFunc^}.GetType()->{TypeFunc^}

		indVar := ParamFunc^
		if fncOperType.Params.Size() >= 3
			DownToken.EmitError("iteretable operator have too many inputs")
		if fncOperType.Params.Size() == 2
		{
			if not fncOperType.Params[1].IsRef
				DownToken.EmitError("iterateble operator () , input must be reference to a pointer")
			if not (fncOperType.Params[1].ItType is in TypePoint)
				DownToken.EmitError("iterateble operator () , input must be reference to a pointer")
			indVar = CreateVar(fncOperType.Params[1].ItType,false)
		}

		objs2 := CheckExeDownList
		objs2.Push(mainCall)
		if indVar != null
			objs2.Push(indVar.CreateCall())

		iCall := objCall->{BoxFunc^}.CreateCall(objs2)

		if iCall == null
			DownToken.EmitError("iteratable object is not callable, no () function")


		if indVar != null and IndexName.Size() != 0
		{
			IndVar = new MacroVar(IndexName,() ==> [indVar] {
				getVar := indVar.CreateCall()
				return new PtrToRefFuncCall(getVar)
			})
		}
		GetCall = iCall
		IsFinished = iFins
		HaveValue = haveValue
		InitStep = dwnVar
		ValueVar = new MemVar(StringSpan(ValueName),new FuncResultParam(iCall))
	}

	"=" := default
}

BoxFor := class extend BoxExeObj
{
	values := HybridQueue.{ForSubObjects,5}

	CheckStep := BoxLabel
	EndLabel := BoxLabel

	body := BoxBlock^

	HeadLine := BoxExeLine^
	
	this := !() -> void
	{
		CheckStep."this"()
		EndLabel."this"()
	}
	StepTwo := !(Token^ itm,!()&->BoxUnit^ cb) -> void
	{
		values[^].CheckRegularStep()
		values[^].NextCheck = new BoxLabel()

		stackSize := UnitStack.Size()

		for it : values
		{
			UnitStack.PushFront(it.ValueVar?)
			UnitStack.PushFront(it.IndVar?)
		}

		body = new BoxBlockContinue(itm,cb)

		while stackSize > UnitStack.Size()
			UnitStack.Pop()
	}

	PrintCode := virtual !(TIOStream^ f) -> void
	{
		oldLineCall := GDebugLineCallId
		GDebugLineCallId = HeadLine.MetaId

		values[^].InitStep.PrintCode(f)
		CheckStep.PrintCode(f)

		for it : values
		{
			if it.HaveValue != null
			{
				it.HaveValue.PrintPre(f)
				PrintBranch(f,it.HaveValue,it.NextCheck,EndLabel&)
				it.NextCheck.PrintCode(f)
			}

			it.GetCall.PrintDefaultUse(f)

			if it.IsFinished != null
			{
				it.IsFinished.PrintPre(f)
				PrintBranch(f,it.IsFinished,EndLabel&,it.NextCheck)
				it.NextCheck.PrintCode(f)
			}
		}

		body.PrintCode(f)

		CheckStep.PrintGo(f)
		EndLabel.PrintCode(f)

		GDebugLineCallId = oldLineCall
	}
	PrintDebugMeta := virtual !(TIOStream^ f) -> void
	{
		HeadLine?.PrintDebugMeta(f)
		body.PrintDebugMeta(f)
	}
}

BoxForOverMeta := class extend BoxExeObj
{
	blocks := List.{BoxBlock^}
	dwnObjs := HybridQueue.{ForSubObjects,5}

	metaCount := int

	middleVars := AVLMap.{int,List.{NamedVar^}}

	this := !(HybridQueue.{ForSubObjects,5} dwns,Token^ bdy) -> void
	{
		if not dwns[^].IsMeta
			bdy.EmitError("All of iteratables must be metadata")
		k := dwns[0].MetaObj.MetaIteretableSize()
		if k != dwns[^].MetaObj.MetaIteretableSize()
			bdy.EmitError("All of iteretables must be same size")

		dwnObjs.Push(dwns[^])
		
		stackSize := UnitStack.Size()

		tryAddVar := (BoxExeObj^ toAdd,int num,StringSpan itName) ==> {
			if toAdd == null
				return void
			
			if toAdd is in BoxExeConstObj
			{
				UnitStack.PushFront(new ConstVar(itName,toAdd->{BoxExeConstObj^}))
				return void
			}
			
			fr := new FuncResultParam(toAdd)
			newVar := new MemVar(itName,fr)
			middleVars[num].Push(newVar)
			UnitStack.PushFront(newVar)
		}
		
		for i : k
		{
			for j : dwnObjs.Size()
			{
				tryAddVar(dwnObjs[j].MetaObj.GetMetaIterValue(i),i,dwnObjs[j].ValueName)

				if dwnObjs[j].IndexName.Size() != 0
				{
					indConst := dwnObjs[j].MetaObj.GetMetaIterIndex(i)
					if indConst == null
						indConst = GetExeInt(i)
					tryAddVar(indConst,i,dwnObjs[j].IndexName)
				}
			}
			blocks.Push(new BoxBlockContinue(bdy))

			while stackSize < UnitStack.Size()
				UnitStack.Pop()
		}
		metaCount = k
	}
	PrintCode := virtual !(TIOStream^ f) -> void
	{
		dwnObjs[^].MetaObj.PrintDefaultUse(f)

		for i : blocks.Size()
		{
			if middleVars.Contain(i)
				middleVars[i][^].PrintCode(f)

			blocks[i].PrintCode(f)
		}
	}
	PrintDebugMeta := virtual !(TIOStream^ f) -> void
	{
		dwnObjs[^].MetaObj.PrintDebugMeta(f)
		blocks[^].PrintDebugMeta(f)
	}
}
