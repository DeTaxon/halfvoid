GetForCycle := !(Token^ itm) -> BoxExeObj^
{
    resFor := new BoxFor()

    iter := itm.Down.Right

    if iter.Right.GetValue() == "{}"
    {
        //TODO, name only
    }else{
        while iter.GetValue() != "{}" //TODO non {} variant
        {
            if iter.GetValue() == ","
                iter = iter.Right
            
            forElement := ForSubObjects

            if not (iter is TokenIndent)
                iter.EmitError("not a name for cycle element variable") //todo better error explanation
            
            name := iter->{TokenIndent^}.Value
            index := StringSpan("")

            iter = iter.Right

            if iter.GetValue() == ","
            {
                iter = iter.Right

                if not (iter is TokenIndent)
                    iter.EmitError("not a name for cycle index variable") //todo better error explanation
                
                index = iter->{TokenIndent^}.Value

                iter = iter.Right
            }

            assert(iter.GetValue() == ":")
            iter = iter.Right

            dwnRes := TryGetExeCall(iter)

            if dwnRes == null
                iter.EmitError("Could not get result for cycle over obj")

            dwnVar := new FuncResultParam(dwnRes)
            
            cnsts := List.{BoxExeConstObj^}
            objs := CheckExeDownList
            iFins := innerTryGetMethodCall(StringSpan("IsFinished"),new BoxFuncCall(dwnVar),objs,cnsts) //TODO: checkType

            if iFins == null
                iter.EmitError("iteratable object does not contain IsFinished")

            iCall := innerTryGetMethodCall(StringSpan("()"),new BoxFuncCall(dwnVar),objs,cnsts)

            if iCall == null
                iter.EmitError("iteratable object is not callable, no () function")

            forElement.GetCall = iCall
            forElement.IsFinished = iFins
            forElement.InitStep = dwnVar
            //new FuncResultParam(iCall)
            forElement.ValueVar = new MemVar(StringSpan(name),new FuncResultParam(iCall))

            resFor.values.Push(forElement)

            iter = iter.Right
        }
    }

    assert(iter.GetValue() == "{}")

    resFor.StepTwo(iter)

    return resFor
}

ForSubObjects := class
{
    ValueVar := MemVar^
    IndVar := MemVar^
    GetCall := BoxExeObj^
    IsFinished := BoxExeObj^
    InitStep := ParamFunc^
    NextCheck := BoxLabel^

    "=" := default
}

BoxFor := class extend BoxExeObj
{
    values := HybridQueue.{ForSubObjects,5}

    CheckStep := BoxLabel
    EndLabel := BoxLabel

    body := BoxBlock^
    
    this := !() -> void
    {
        CheckStep."this"()
        EndLabel."this"()
    }
    StepTwo := !(Token^ itm) -> void
    {
        values[^].NextCheck = new BoxLabel()

        stackSize := UnitStack.Size()

        for it : values
        {
            UnitStack.Push(it.ValueVar?)
            UnitStack.Push(it.IndVar?)
        }

        body = new BoxBlock(itm)

        while stackSize > UnitStack.Size()
            UnitStack.Pop()
    }

    PrintCode := virtual !(TIOStream^ f) -> void
    {
        values[^].InitStep.PrintCode(f)
        CheckStep.PrintCode(f)

        for it : values
        {
            it.GetCall.PrintDefaultUse(f)
            it.IsFinished.PrintPre(f)

            f^ << "br i1 "
            it.IsFinished.PrintUse(f) //TODO: non zero
            f^ << ", label "
            EndLabel.PrintLabel(f)
            f^ << ", label "
            it.NextCheck.PrintLabel(f)
            if DebugMode 
                f^ << ", !dbg !" << GDebugLineCallId
            f^ << "\n"
            it.NextCheck.PrintCode(f)
        }

        body.PrintCode(f)

        CheckStep.PrintGo(f)
        EndLabel.PrintCode(f)
    }
    PrintDebugMeta := virtual !(TIOStream^ f) -> void
	{
        body.PrintDebugMeta(f)
    }
}