GetForCycle := !(Token^ itm) -> BoxUnit^
{
    return new BoxBlockBreak(itm, () ==> {
        resFor := new BoxFor()

        iter := itm.Down.Right

        if iter.Right.GetValue() == "{}"
        {
            //TODO, name only
        }else{
            while iter.GetValue() != "{}" //TODO non {} variant
            {
                if iter.GetValue() == ","
                    iter = iter.Right
                
                forElement := ForSubObjects

                if not (iter is TokenIndent)
                    iter.EmitError("not a name for cycle element variable") //todo better error explanation
                
                name := iter->{TokenIndent^}.Value
                index := StringSpan("")

                iter = iter.Right

                if iter.GetValue() == ","
                {
                    iter = iter.Right

                    if not (iter is TokenIndent)
                        iter.EmitError("not a name for cycle index variable") //todo better error explanation
                    
                    index = iter->{TokenIndent^}.Value

                    iter = iter.Right
                }

                assert(iter.GetValue() == ":")
                iter = iter.Right

                dwnRes := TryGetExeCall(iter)

                if dwnRes == null
                    iter.EmitError("Could not get result for cycle over obj")
                
                objs7 := CheckExeDownList
                objs7.Push(dwnRes)
                getForCall := BoxExeObj^
                getForCall = CreateFuncCall(StringSpan("for"),objs7)

                if getForCall == null
                {
                    empty7 := CheckExeDownList
                    cnsts6 := List.{BoxExeConstObj^}
                    getForCall = innerTryGetMethodCall(StringSpan("for"),dwnRes,empty7,cnsts6)
                }

                if getForCall == null
                    iter.EmitError("Object does not have operator for")

                dwnVar := new FuncResultParam(getForCall)
                
                cnsts := List.{BoxExeConstObj^}
                objs := CheckExeDownList
                iFins := innerTryGetMethodCall(StringSpan("IsFinished"),new BoxFuncCall(dwnVar),objs,cnsts) //TODO: checkType

                if iFins == null
                    iter.EmitError("iteratable object does not contain IsFinished")

                iCall := innerTryGetMethodCall(StringSpan("()"),new BoxFuncCall(dwnVar),objs,cnsts)

                if iCall == null
                    iter.EmitError("iteratable object is not callable, no () function")

                forElement.GetCall = iCall
                forElement.IsFinished = iFins
                forElement.InitStep = dwnVar
                forElement.ValueVar = new MemVar(StringSpan(name),new FuncResultParam(iCall))

                resFor.values.Push(forElement)

                iter = iter.Right
            }
        }

        assert(iter.GetValue() == "{}")

        resFor.StepTwo(iter)

        return resFor
    })
}

ForSubObjects := class
{
    ValueVar := MemVar^
    IndVar := MemVar^
    GetCall := BoxExeObj^
    IsFinished := BoxExeObj^
    InitStep := ParamFunc^
    NextCheck := BoxLabel^

    "=" := default
}

BoxFor := class extend BoxExeObj
{
    values := HybridQueue.{ForSubObjects,5}

    CheckStep := BoxLabel
    EndLabel := BoxLabel

    body := BoxBlock^
    
    this := !() -> void
    {
        CheckStep."this"()
        EndLabel."this"()
    }
    StepTwo := !(Token^ itm) -> void
    {
        values[^].NextCheck = new BoxLabel()

        stackSize := UnitStack.Size()

        for it : values
        {
            UnitStack.Push(it.ValueVar?)
            UnitStack.Push(it.IndVar?)
        }

        body = new BoxBlockContinue(itm)

        while stackSize > UnitStack.Size()
            UnitStack.Pop()
    }

    PrintCode := virtual !(TIOStream^ f) -> void
    {
        values[^].InitStep.PrintCode(f)
        CheckStep.PrintCode(f)

        for it : values
        {
            it.GetCall.PrintDefaultUse(f)
            it.IsFinished.PrintPre(f)

            f^ << "br i1 "
            it.IsFinished.PrintUse(f) //TODO: non zero
            f^ << ", label "
            EndLabel.PrintLabel(f)
            f^ << ", label "
            it.NextCheck.PrintLabel(f)
            if DebugMode 
                f^ << ", !dbg !" << GDebugLineCallId
            f^ << "\n"
            it.NextCheck.PrintCode(f)
        }

        body.PrintCode(f)

        CheckStep.PrintGo(f)
        EndLabel.PrintCode(f)
    }
    PrintDebugMeta := virtual !(TIOStream^ f) -> void
	{
        body.PrintDebugMeta(f)
    }
}