BoxReturn := class extend BoxExeObj
{
	EndLabel := BoxLabel^
	ResultCall := BoxExeObj^
	cleanupCall := BoxExeObj^
	this := !(BoxLabel^ l,BoxExeObj^ rc) -> void
	{
		EndLabel = l
		ObjType = GTypeVoid
		ResultCall = rc

		if GCVarsInUse != 0
		{
			objs := CheckExeDownList
			gcPtr := CurrentFunc->{BoxFuncBody^}.gcArrayPtr
			assert(gcPtr != null)
			getGCPtr := new BoxFuncCall(gcPtr,objs)

			objs.Push(getGCPtr)
			objs.Push(GetExeInt(0))
			objs.Push(GetExeInt(GCVarsInUse - 1))

			cleanupCall = new BoxFuncCall(GFuncGCSetNullArray,objs)
		}
	}
	PrintDefaultUse := virtual !(TIOStream^ f) -> void
	{
		ResultCall?.PrintDefaultUse(f)
		cleanupCall?.PrintDefaultUse(f)
		EndLabel.PrintGo(f)
	}
}

BoxYield := class extend BoxReturn
{
	toThis := BoxLabel^
	callSet := BoxExeObj^
	this := !(BoxLabel^ l,BoxExeObj^ rc) -> void
	{
		this."BoxReturn.this"(l,rc)

		yieldVal := CurrentFunc.PutYieldState(this&)
		yVar := CurrentFunc.GetYieldStateParam()

		empty := CheckExeDownList
		objs := CheckExeDownList
		objs.Push(new BoxFuncCall(yVar,empty))
		objs.Push(GetExeInt(yieldVal))

		callSet = CreateFuncCall(StringSpan("="),objs)
		toThis = new BoxLabel()
	}

	PrintDefaultUse := virtual !(TIOStream^ f) -> void
	{
		ResultCall?.PrintDefaultUse(f)
		callSet.PrintDefaultUse(f)
		EndLabel.PrintGo(f)
		toThis.PrintCode(f)
	}
	GetLabel := virtual !() -> BoxLabel^
	{
		return toThis
	}
}

GetCurrentFunc := !() -> BoxFunc^
{
	for it : UnitStack
	{
		if it is in BoxFunc
			return it->{BoxFunc^}
	}
	assert(false)
	return null
}

