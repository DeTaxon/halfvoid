BoxReturn := class extend BoxExeObj
{
	EndLabel := BoxLabel^
	ResultCall := BoxExeObj^
	cleanupCall := BoxExeObj^
	this := !(BoxLabel^ l,BoxExeObj^ rc) -> void
	{
		EndLabel = l
		ObjType = GTypeVoid
		ResultCall = rc

		if GCVarsInUse != 0
		{
			objs := CheckExeDownList
			gcPtr := CurrentFunc->{BoxFuncBody^}.gcArrayPtr
			assert(gcPtr != null)
			getGCPtr := gcPtr.CreateCall(objs)

			objs.Push(getGCPtr)
			objs.Push(GetExeInt(0))
			objs.Push(GetExeInt(GCVarsInUse - 1))

			cleanupCall = GFuncGCSetNullArray.CreateCall(objs)
		}
	}
	PrintDefaultUse := virtual !(TIOStream^ f) -> void
	{
		ResultCall?.PrintDefaultUse(f)
		cleanupCall?.PrintDefaultUse(f)
		EndLabel.PrintGo(f)
	}
}

BoxYield := class extend BoxReturn
{
	toThis := BoxLabel^
	callSet := BoxExeObj^
	this := !(BoxLabel^ l,BoxExeObj^ rc) -> void
	{
		this."BoxReturn.this"(l,rc)

		yieldVal := CurrentFunc.PutYieldState(this&)
		yVar := CurrentFunc.GetYieldStateParam()

		objs := CheckExeDownList
		objs.Push(yVar.CreateCall())
		objs.Push(GetExeInt(yieldVal))

		callSet = CreateFuncCall(StringSpan("="),objs)
		toThis = new BoxLabel()
	}

	PrintDefaultUse := virtual !(TIOStream^ f) -> void
	{
		ResultCall?.PrintDefaultUse(f)
		callSet.PrintDefaultUse(f)
		EndLabel.PrintGo(f)
		toThis.PrintCode(f)
	}
	GetLabel := virtual !() -> BoxLabel^
	{
		return toThis
	}
}

GetCurrentFunc := !() -> BoxFunc^
{
	for it : UnitStack
	{
		if it is in BoxFunc
			return it->{BoxFunc^}
	}
	assert(false)
	return null
}

ReturnHalfState := class extend BoxExeObj
{
    isYield := bool
    callObj := BoxExeObj^
    returnObj := BoxExeObj^
	errorToken := Token^
    this := !(Token^ erToken,BoxExeObj^ toCall,bool iY) -> void
    {
		errorToken = erToken
        callObj = toCall
        isYield = iY
    }

    ResolveStep := !() -> void
    {
        if callObj != null
        {
			if callObj.GetType() != GTypeVoid //TODO Auto return type
			{
		        rRef := CurrentFunc.GetType()->{TypeFunc^}.ResultRef

				if callObj.GetType() != CurrentFunc.ResultVar.GetVarType()
				{
					if rRef
					{
						errorToken.EmitError("type not same with function, not supported for function") //TODO
					}else{
						callObj = GetExchange(callObj,CurrentFunc.ResultVar.GetVarType())
						if callObj == null
							errorToken.EmitError("can not convert type to function result")
					}
				}


				if rRef
					callObj = new UnrefFuncCall(callObj)

				tkn1 := TokenIndent(StringSpan("result"))

				resGet := TryGetExeCall(tkn1&)

				objs := CheckExeDownList
				objs.Push(resGet)
				objs.Push(callObj)
				callObj = CreateFuncCall(StringSpan("="),objs)
				assert(callObj != null)
			}
        }
     
		if isYield
		{
			returnObj = new BoxYield(CurrentFunc.GetExitLabel(),callObj)
		}else{
		    returnObj = new BoxReturn(CurrentFunc.GetExitLabel(),callObj)
        }
    }
    GetReturnObj := !() -> BoxExeObj^
    {
        return returnObj
    }
    GetSetType := !() -> Type^
    {
        if callObj == null
            return GTypeVoid
        return callObj.GetType()
    }

	PrintDefaultUse := virtual !(TIOStream^ f) -> void
    {
        returnObj.PrintDefaultUse(f)
    }
}
