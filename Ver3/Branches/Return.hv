BoxReturn := class extend BoxExeObj
{
	EndLabel := BoxLabel^
	ResultCall := BoxExeObj^
	cleanupCall := BoxExeObj^
	this := !(BoxLabel^ l,BoxExeObj^ rc) -> void
	{
		EndLabel = l
		ObjType = GTypeVoid
		ResultCall = rc

		if GCVarsInUse != 0
		{
			objs := CheckExeDownList
			gcPtr := CurrentFunc->{BoxFuncBody^}.gcArrayPtr
			assert(gcPtr != null)
			getGCPtr := gcPtr.CreateCall(objs)

			objs.Push(GetExchange2(getGCPtr,GCType.GetPoint().GetPoint(),false))
			objs.Push(GetExeInt(0))
			objs.Push(GetExeInt(GCVarsInUse - 1))

			cleanupCall = GFuncGCSetNullArray.CreateCall(objs)
		}
	}
	PrintDefaultUse := virtual !(TIOStream^ f) -> void
	{
		ResultCall?.PrintDefaultUse(f)
		cleanupCall?.PrintDefaultUse(f)
		EndLabel.PrintGo(f)
	}
}

BoxYield := class extend BoxReturn
{
	toThis := BoxLabel^
	callSet := BoxExeObj^
	this := !(BoxLabel^ l,BoxExeObj^ rc) -> void
	{
		this."BoxReturn.this"(l,rc)

		yieldVal := CurrentFunc.PutYieldState(this&)
		yVar := CurrentFunc.GetYieldStateParam()

		objs := CheckExeDownList
		objs.Push(yVar.CreateCall())
		objs.Push(GetExeInt(yieldVal))

		callSet = CreateFuncCall(StringSpan("="),objs)
		toThis = new BoxLabel()
	}

	PrintDefaultUse := virtual !(TIOStream^ f) -> void
	{
		ResultCall?.PrintDefaultUse(f)
		callSet.PrintDefaultUse(f)
		EndLabel.PrintGo(f)
		toThis.PrintCode(f)
	}
	GetLabel := virtual !() -> BoxLabel^
	{
		return toThis
	}
}

GetCurrentFunc := !() -> BoxFunc^
{
	for it : UnitStack
	{
		if it is in BoxFunc
			return it->{BoxFunc^}
	}
	assert(false)
	return null
}

ReturnHalfState := class extend BoxExeObj
{
    isYield := bool
    callObj := BoxExeObj^
    returnObj := BoxExeObj^
	errorToken := Token^
    this := !(Token^ erToken,BoxExeObj^ toCall,bool iY) -> void
    {
		errorToken = erToken
        callObj = toCall
        isYield = iY
    }

    ResolveStep := !() -> void
    {
        if callObj != null
        {
			if callObj.GetType() != GTypeVoid //TODO Auto return type
			{
		        rRef := CurrentFunc.GetType()->{TypeFunc^}.ResultRef

				callObj2 := BoxExeObj^
				resType := callObj.GetType()
				funcType := CurrentFunc.ResultVar.GetVarType()
				if rRef
					funcType = funcType.Base

				if resType != funcType
				{
					if rRef
					{
						if resType is in TypeClass and funcType is in TypeClass and TypeFight(funcType,resType) == funcType
						{
							callObj2 = GetExchange(new UnrefFuncCall(callObj),funcType.GetPoint())
						}else{
							errorToken.EmitError("result type does not compare with function result")
						}
					}else{
						newObj := GetExchange(callObj,CurrentFunc.ResultVar.GetVarType())
						if newObj == null
						{
							if callObj is BoxExeNull
							{
								newObj = GetExchange2(callObj,CurrentFunc.ResultVar.GetVarType(),false)
							}else{
								errorToken.EmitError("can not convert type to function result")
							}
						}
						callObj = newObj
					}
				}

				if callObj2 == null
				{
					if rRef
					{
						callObj2 = new UnrefFuncCall(callObj)
					}else{
						callObj2 = callObj
					}
				}

				tkn1 := TokenIndent(StringSpan("result"))

				resGet := TryGetExeCall(tkn1&)

				objs := CheckExeDownList
				objs.Push(resGet)
				objs.Push(callObj2)

				if rRef
				{
					cns := List.{BoxExeConstObj^}
					setPtrFunc := GPointStoreTemplate.GetFunc(objs,cns)
					assert(setPtrFunc != null)
					callObj = setPtrFunc.CreateCall(objs)
				}else{
					callObj = innerTryGetInfixCall(StringSpan("="),objs,errorToken)
					if callObj == null
						errorToken.EmitError("Can not return value, no \"=\" operator")
				}
			}
        }
     
		if isYield
		{
			returnObj = new BoxYield(CurrentFunc.GetExitLabel(),callObj)
		}else{
		    returnObj = new BoxReturn(CurrentFunc.GetExitLabel(),callObj)
        }
    }
    GetReturnObj := !() -> BoxExeObj^
    {
        return returnObj
    }
    GetSetType := !() -> Type^
    {
        if callObj == null
            return GTypeVoid
        return callObj.GetType()
    }

	PrintDefaultUse := virtual !(TIOStream^ f) -> void
    {
        returnObj.PrintDefaultUse(f)
    }
}
