ForSubObjects := class
{
	ValueName := StringSpan
	IndexName := StringSpan
	DownToken := Token^

	DownResult := BoxExeObj^
	ValueVar := MemVar^
	IndVar := NamedVar^
	GetCall := BoxExeObj^
	IsFinished := BoxExeObj^
	HaveValue := BoxExeObj^
	InitStep := ParamFunc^
	NextCheck := BoxLabel^
	IncFunc := BoxExeObj^

	MetaObj := BoxMetaObj^
	IsMeta := bool

	CheckRegularStep := !() -> void
	{

		dwnRes := DownResult

		objs7 := CheckExeDownList
		objs7.Push(dwnRes)
		getForCall := BoxExeObj^

		if getForCall == null
		{
			empty7 := CheckExeDownList
			cnsts6 := List.{BoxExeConstObj^}
			getForCall = innerTryGetMethodCall(StringSpan("for"),dwnRes,empty7,cnsts6)
		}
		if getForCall == null
		{
			getForCall = CreateFuncCall(StringSpan("for"),objs7)
		}

		if getForCall == null
			DownToken.EmitError("Object does not have operator for")

		dwnVar := new FuncResultParam(getForCall)
		
		cnsts := List.{BoxExeConstObj^}
		objs := CheckExeDownList

		haveValue := innerTryGetMethodCall(StringSpan("HaveValue"),dwnVar.CreateCall(),objs,cnsts)
		checkFunc := haveValue
		iFins := BoxExeObj^
		if haveValue == null
		{
			iFins = innerTryGetMethodCall(StringSpan("IsFinished"),dwnVar.CreateCall(),objs,cnsts)
			checkFunc = iFins
		}

		if checkFunc == null
			DownToken.EmitError("iteratable object does not contain IsFinished or HaveValue")
		if checkFunc.GetType() != GTypeBool
			DownToken.EmitError("IsFinished or HaveValue return non boolean type")
		
		IncFunc = innerTryGetMethodCall(StringSpan("Inc"),dwnVar.CreateCall(),objs,cnsts)
		
		mainCall := dwnVar.CreateCall()
		dwnType := mainCall.GetType()

		cls := BoxClass^
		if dwnType is in TypeClass
		{
			cls = dwnType->{TypeClass^}.ToClass
		}
		if dwnType is in TypePoint and dwnType.Base is in TypeClass
		{
			cls = dwnType.Base->{TypeClass^}.ToClass
		}
		
		if cls == null
			DownToken.EmitError("unknown iteretable result")
		
		objCall := BoxUnit^
		cls.GetMethods(StringSpan("()"),x ==> {
			if x.Size() == 1
			{
				objCall = x[0]
			}
		})

		if objCall == null
			DownToken.EmitError("iteratable object must have exacly one operator ()")
		
		if not (objCall is in BoxFunc)
			DownToken.EmitError("operator () is not a function")
		
		fncOperType := objCall->{BoxFunc^}.GetType()->{TypeFunc^}

		indVar := ParamFunc^
		if fncOperType.Params.Size() >= 3
			DownToken.EmitError("iteretable operator have too many inputs")
		if fncOperType.Params.Size() == 2
		{
			if not fncOperType.Params[1].IsRef
				DownToken.EmitError("iterateble operator () , input must be reference to a pointer")
			if not (fncOperType.Params[1].ItType is in TypePoint)
				DownToken.EmitError("iterateble operator () , input must be reference to a pointer")
			indVar = CreateVar(fncOperType.Params[1].ItType,false)
		}

		objs2 := CheckExeDownList
		objs2.Push(mainCall)
		if indVar != null
			objs2.Push(indVar.CreateCall())

		iCall := objCall->{BoxFunc^}.CreateCall(objs2)

		if iCall == null
			DownToken.EmitError("iteratable object is not callable, no () function")


		if indVar != null and IndexName.Size() != 0
		{
			IndVar = new MacroVar(IndexName,() ==> [indVar] {
				getVar := indVar.CreateCall()
				return new PtrToRefFuncCall(getVar)
			})
		}

		GetCall = iCall
		IsFinished = iFins
		HaveValue = haveValue
		InitStep = dwnVar
		ValueVar = new MemVar(StringSpan(ValueName),new FuncResultParam(iCall))
	}

	"=" := default
}
