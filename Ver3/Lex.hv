lexWordMachine := WordDetermMachine^

LoadLexMachine := !(char^ ptrToChar,int Si) -> void
{
	lexWordMachine = new WordDetermMachine
	lexWordMachine.LoadFromMap(ptrToChar,Si)
}

GetObjectsFromMemory := !(char^ fileName,char^ memPtr,int Siz) -> Token^
{
	itLine := FileLine^
	treeStart := Token^
	treeIter := Token^
	prevId := -1
	linePos := 0
	DaBuff := char[2048]
	RegExpReadText(lexWordMachine->{void^},memPtr,Siz, (a,b,c) ==>
	{
		ptr := memPtr[b]&

		tok := StringSpan(ptr,c)

		ns := Token^
		if a != 20{
			if itLine == null {
				itLine = new FileLine(fileName)
			}
		}
		if a >= 40
		{
			ns = new TokenSymbol(tok,a) 
		}
		if a == 1 {
			switch tok
			{
				case "null"
					ns = new TokenNull(tok)
				case "true"
					ns = new TokenBool(tok,true)
				case "false"
					ns = new TokenBool(tok,false)
				case "continue"
					ns = new TokenWayControl(tok)
				case "break"
					ns = new TokenWayControl(tok)
				case void
					if IsKeyword(tok)
					{
						ns = new TokenSymbol(tok,a)
					}else{
					      if prevId == 3 or prevId == 5 or prevId ==  6
					      {
							ns = new TokenSuffix(tok)
					      }else{
					    		ns = new TokenIndent(tok)
					      }
					}
			}
		}
		//if a == 2{
		//	if tok[0] == '#'
		//	{
		//		ns = new ObjCmd(GetConstString(tok))
		//	}else{
		//		ns = new ObjTemplateType(tok[1..0].Str())
		//	}
		//}
		if a == 3 {
			j := 0
			k := 1
			while tok[k] != '"'
			{
				if tok[k] == '\\'{
					k += 1
					switch tok[k]
					{
						case 't' DaBuff[j] = 9
						case 'n' DaBuff[j] = 10
						case 'x' 
							numM := 0
							switch tok[k+1]
							{
								case '0'..'9'
									numM = tok[k+1] - '0'
								case 'a'..'f'
									numM = tok[k+1] - 'a' + 10
								case 'A'..'F'
									numM = tok[k+1] - 'A' + 10
							}
							numM *= 16
							switch tok[k+2]
							{
								case '0'..'9'
									numM += tok[k+2] - '0'
								case 'a'..'f'
									numM += tok[k+2] - 'a' + 10
								case 'A'..'F'
									numM += tok[k+2] - 'A' + 10
							}
							DaBuff[j] = numM
							k += 2

						case void DaBuff[j] = tok[k]
					}
					j += 1
					k += 1
				}else{
					DaBuff[j] = tok[k]
					k += 1
					j += 1
				}	
			}
			DaBuff[j] = 0
			val := GetConstString(DaBuff)
			ns = new TokenString(val)
		}
		if a == 4 {
			newVal := int
			if tok[1] == '\\'
			{
				switch tok[2]
				{
					case 't' newVal = 9
					case 'n' newVal = 10
					case void newVal = tok[2]
				}
			}else{
				newVal = tok[1]
			}
			ns = new TokenInt(tok,newVal)
		}
		if a == 5{
			Value := int
			Value = 0
			
			k := 0
		
			while tok[k] in '0'..'9'
			{
				Value *= 10
				Value += tok[k] - '0'
				k += 1
			}
			ns = new TokenInt(tok,Value)
		}
		if a == 6{
			Value := 0.0
			k := 0
			Quant := 0.1
			SSing := 1.0

			while tok[k] != '.'
			{
				Value *= 10
				Value += tok[k] - '0' 
				k += 1 
			}
			k += 1 //.
			while tok[k] in '0'..'9'
			{
				Value += (tok[k] - '0')*Quant
				k += 1
				Quant *= 0.1
			}
			if tok[k] == 'e' 
			{
				//TODO: not now
			}
			ns = new TokenDouble(tok,Value)
		}
		if a == 7 {
			Value := int
			Value = 0
			
			k := 2
		
			while k != tok.Size()
			{
				Value *= 16
				if tok[k] in '0'..'9' Value += tok[k] - '0'
				if tok[k] in 'A'..'F' Value += tok[k] - 'A' + 10
				if tok[k] in 'a'..'f' Value += tok[k] - 'a' + 10
				k += 1
			}
			ns = new TokenInt(tok,Value)
		}
		if a == 8 {
			ns = new TokenSymbol(tok,a) 
		}
		//if a == 9{
		//	//comments
		//}
		if ns != null {
			if treeIter == null{
				treeIter = ns
				treeStart = ns
			}else{
				treeIter.Right = ns
				ns.Left = treeIter
				treeIter = ns
			}
			ns.Line = itLine
		}
		if a == 20 {
			linePos += 1
			if itLine != null{
				itLine.Line = linePos
			}
			//new line
			itLine = null
		}
		//if a == 21 {
		//	//TODO: replace
		//	// attrs
		//}
		prevId = a
	})
	UniteSkobs(treeStart)
	return treeStart
}

UniteSkobs := !(Token^ Tree) -> Object^
{
	Bag := List.{Token^}
	defer Bag.Destroy()

	iter := Tree
	
	while iter != null
	{
		tokId := iter.TokenId
		if tokId in 40..42 	Bag.PushFront(iter)

		if tokId in 43..45
		{
			itPair := char^
			switch tokId
			{
				case 43 itPair = "()"
				case 44 itPair = "{}"
				case 45 itPair = "[]"
			}

			if Bag.IsEmpty() return iter
			Old := Bag.Pop()
			if tokId - Old.TokenId != 3
			{
				//TODO error
				//Old.EmitError("incorrect pair for "sbt + Old.GetValue())
				return iter
			}

			NewObj := new TokenSymbol(StringSpan(itPair),0)
			NewObj.Line = Old.Line
			UNext(Old,NewObj,iter)

			TIter := NewObj.Down
			PopOutNode(TIter) //TODO memory
			TIter = NewObj.Down

			if TIter.Right != null{
				while TIter.Right != null TIter = TIter.Right
			}
			PopOutNode(TIter) //TODO memory

			iter = NewObj.Right
		}else{
			iter = iter.Right
		}

	}
	//for Bag^
	//{
	//	//TODO: error
	//	//it.EmitError("pair for "sbt + it.GetValue() + " not found")
	//}
	return null
}
UNext := !(Token^ where,Token^ nObj, int count) -> Token^
{
	Last := where
	for count-1 Last = Last.Right
	UNext(where,nObj,Last)
	return nObj
}
UNext := !(Token^ where,Token^ nObj, Token^ Last) -> void
{
	End := Last.Right

	if End != null {
		End.Left.Right = null
		End.Left = nObj
		nObj.Right = End
	}

	if where.Left == null{
		Upp := where.Up

		Upp.Down = nObj
		nObj.Down = where
		nObj.Up = Upp

	}else{
		Ll := where.Left

		Ll.Right = nObj
		nObj.Left = Ll
		nObj.Down = where
		nObj.Up = Ll.Up
		where.Left = null
	}

	End = where
	while End != null {
		End.Up = nObj
		End = End.Right
	}
	nObj.Line = where.Line
}
PopOutNode := !(Token^ what) -> void
{
	if what.Left != null
	{
		what.Left.Right = what.Right
		if what.Right != null	what.Right.Left = what.Left
	}else
	{
		if what.Up != null what.Up.Down = what.Right
		if what.Right != null what.Right.Left = null
	}
	what.Up = null
	what.Left = null
	what.Right = null
}

IsKeyword := !(W) -> bool
{
	switch W
	{
		case "return" return true
		case "for" return true
		case "if" return true
		case "else" return true
		case "while" return true
		case "do" return true
		case "delete" return true
		case "switch" return true
		case "case" return true
		case "class" return true
		case "extern" return true
		case "extend" return true
		case "at" return true
		case "defer" return true
		case "type" return true
		case "virtual" return true
		case "new" return true
		case "delete" return true
		case "thread_local" return true
		case "task_local" return true
		case "keep_name" return true
		case "packed_class" return true
		case "self_return" return true
		case "try" return true
		case "try_one" return true
		case "try_all" return true
		case "catch" return true
		case "throw" return true
		case "on_exception" return true
		case "yield" return true
		case "AppendClass" return true
		case "default" return true
		case "weak" return true
		case "poison" return true
		case "defer_tail" return true
		case "static" return true
		case "field" return true
	}

	return false
}
