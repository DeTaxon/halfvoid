
BoxClass := class extend BoxUnit
{
	ItId := int
	ItType := Type^
	IsPacked := bool
	Parents := HybridQueue.{BoxClass^,1}
	ItName := StringSpan

	Fields := List.{FieldParam^}
	FieldsPath := List.{FieldPath^}
	Methods := AVLMap.{StringSpan,List.{BoxFunc^}}
	ItSize := int
	ItAlign := int


	PrimeParents := HybridQueue.{Tuple.{BoxClass^,BoxClass^,int},1}


	CreateCommon := !() -> void
	{
	}
	SetName := !(StringSpan name) -> void
	{
		ItName = name
	}
	AwaitVTableStep := virtual !() -> void {}
	PrintAsType := virtual !(TIOStream^ f) -> void
	{
		PrintVTable(f)

		needComma := false
		f^ << "%Class" << ItId << " = type {"
		if FieldsPath.Size() == 0 and VTable.Size() != 0
		{
			f^ <<"i1"
		}else{
			if VTable.Size() != 0
			{
				VTableType.ItType.GetPoint().PrintType(f)
				needComma = true
			}
			for i : FieldsPath.Size()
			{
				if needComma
					f^ << ","
				needComma = true
				FieldsPath[i].Field.Value.PrintType(f)
			}
		}
		f^ << "}\n"

		if DebugMode
		{
			fieldMetas := List.{int}
			defer fieldMetas.Destroy()

			for i : FieldsPath.Size()
			{
				newId := GetNewId()
				fieldMetas.Push(newId)
				fld := FieldsPath[i].Field

				f^ << "!" << newId << " = !DIDerivedType(tag: DW_TAG_member, name: \"" << fld.Name << "\" , scope: !" << ItId
				f^ << ",flags: DIFlagPublic"
				f^ << " , baseType: !" << fld.Value.MetaId << ", size: " << fld.Value.GetSize()*8 << ", offset: " << FieldsPath[i].MemOffset*8 << ")\n"
			}

			fieldTypes := GetNewId()
			f^ << "!" << fieldTypes << " = !{"
			for it,i : fieldMetas
			{
				if i > 0
					f^ << ","
				f^ << "!" << it
			}
			f^ << "}\n"

			f^ << "!" << ItId
			f^ << "= distinct !DICompositeType(tag: DW_TAG_class_type, name: \""
			f^ << ItName
			f^ << "\", file: !" << GDebugFileId << ", line: 1, size: "<< ItSize*8 <<", flags: DIFlagTypePassByValue, elements: !" <<fieldTypes << ", identifier: \""
			f^ << ItName
			f^ << "\")\n"
		}
	}
	ParseBody := virtual !() -> void
	{
	}
	AwaitTypeState := virtual !() -> void
	{
	}
	AwaitReadyState := virtual !() -> void
	{
		
	}
	FieldsCount := !() -> int
	{
		sum := Fields.Size()
		sum += Parents[^].FieldsCount()
		return sum
	}
	InheritStep := !() -> void
	{
		assert(FieldsPath.Size() == 0)

		Parents[^].AwaitTypeState()
		ItAlign = max(ItAlign,Parents[^].ItAlign)

		posOffset := 0
		posMemOffset := 0

		if VTable.Size() != 0
		{
			posOffset += 1
			posMemOffset = 8 //TODO unconst
			ItAlign = max(ItAlign,8)
		}

		if Parents.Size() > 0
		{
			posMemOffset = Parents[0].ItSize
			posOffset += Parents[0].FieldsPath.Size()

			for i : Parents[0].FieldsPath.Size()
			{
				FieldsPath.Push(Parents[0].FieldsPath[i])
			}
		}

		if Parents.Size() >= 2
		{
			assert(false) //TODO
		}


		for fil,i : Fields
		{
			fPath := new FieldPath(ItType,fil.Value)
			fPath.Field = fil
			fPath.Index = posOffset + i

			unalign := posMemOffset % fil.Value.GetAlign()
			ItAlign = max(ItAlign,fil.Value.GetAlign())

			if unalign != 0
			{
				posMemOffset += fil.Value.GetAlign() - unalign
			}
			fPath.MemOffset = posMemOffset
			posMemOffset += fil.Value.GetSize()

			FieldsPath.Push(fPath)
		}
		ItSize = posMemOffset

		if Parents.Size() == 0
		{
			PrimeParents.Push(!{this&,this&,0})
		}else
		{
			for par : Parents
			{
				for pp : par.PrimeParents
				{
					PrimeParents.Push(!{pp.0,par,pp.2 + 1}) //todo Remove duplicates
				}
			}
		}
	}
	GetField := virtual !(StringSpan val) -> FieldPath^
	{
		AwaitTypeState()

		for it : FieldsPath
		{
			if it.Field.Name == val
				return it
		}
		return null
	}
	GetFieldByIndex := virtual !(int val) -> FieldPath^
	{
		AwaitTypeState()

		if val < 0 or val >= FieldsPath.Size()
			return null
		return FieldsPath[val]
	}
	populateMethods := !(StringSpan name, HybridQueue.{BoxUnit^,10} objs) -> void
	{
		if Methods.Contain(name)
		{
			for fnc : Methods[name]
			{
				objs.Push(fnc)
			}
		}
		Parents[^].populateMethods(name,objs)
	}
	GetMethods := !(StringSpan name, !(HybridQueue.{BoxUnit^,10})& -> bool cb) -> void
	{
		objs := HybridQueue.{BoxUnit^,10}
		populateMethods(name,objs)

		if objs.Size() != 0
			cb(objs)
	}
}
TypeClass := class extend Type
{
	ToClass := BoxClass^

	this := !(BoxClass^ ths) -> void
	{
		ToClass = ths
		MetaId = ths.ItId
	}
	PrintType := virtual !(TIOStream^ f) -> void
	{
		f^ << "%Class" << MetaId
	}
	PrintDebugName := virtual !(TIOStream^ f) -> void
	{
		f^ << ToClass.ItName
	}
	GetSize := virtual !() -> int
	{
		ToClass.AwaitTypeState()
		minSize := ToClass.ItSize
		unalign := minSize % ToClass.ItAlign
		if unalign != 0
			minSize += ToClass.ItAlign - unalign
		return minSize
	}
	GetAlign := virtual !() -> int
	{
		ToClass.AwaitTypeState()
		return ToClass.ItAlign
	}
}


FieldParam := class extend BoxUnit
{
	Name := StringSpan
	Value := Type^
	this := !(StringSpan name, Type^ val) -> void
	{
		Name = name
		Value = val
	}
}
FieldPath := class extend BoxFuncCommon
{
	Field := FieldParam^
	Index := int
	MemOffset := int

	this := !(Type^ baseClass, Type^ res) -> void
	{
		SetType(GetFuncType(1,baseClass&,null,res,true,false))
	}
	IsMem := virtual !() -> bool
	{
		return true
	}
	PrintCode := virtual !(TIOStream^ f) -> void
	{

	}
	PrintResultObj := virtual !(TIOStream^ f, int resId, int debId) -> void
	{
		f^ << "%T" << resId 
	}
	PrintDebugMeta := virtual !(TIOStream^ f) -> void
	{
	}
	PrintFuncCall := virtual !(TIOStream^ f,int resId,int debId,ExeDownList lst) -> void
	{
		tp := lst[0].GetType()
		lst[0].PrintPointPre(f)
		f^ << "%T" << resId << " = getelementptr "
		tp.PrintType(f)
		f^ << ","
		tp.PrintType(f)
		f^ << "* "
		lst[0].PrintPointUse(f)
		f^ << " , i32 0, i32 " << Index //TODO virtual
		if DebugMode
			f^ << ", !dbg !" << GDebugLineCallId
		f^ << "\n"
	}
}
