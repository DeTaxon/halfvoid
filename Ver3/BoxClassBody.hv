
TryParseClass := !(Token^ itm) -> BoxClass^
{
	if itm == null or itm.Down == null or itm.Down.GetValue() != "class"
		return null

	parents := HybridQueue.{Token^,2}

	isPacked := bool
	//TODO: extends

	iter := itm.Down.Right

	if iter.GetValue() == "extend"
	{
		iter = iter.Right
		parents.Push(iter)
		iter = iter.Right

		while iter.GetValue() == ","
		{
			iter = iter.Right
			parents.Push(iter)
			iter = iter.Right
		}
		assert(iter.GetValue() == "{}")
	}
	bdy := iter

	if bdy == null
		return null
	
	return new BoxClassBody(isPacked,parents,bdy)
}


BoxClassBody := class extend BoxClass
{
	Body := Token^
	ParentTokens := HybridQueue.{Token^,5}

	VTableState := THatch
	FieldsState := THatch

	this := !(bool isPacked,HybridQueue.{Token^,2} parents,Token^ bdy) -> void
	{
		ItName = "anon" //todo
		ItId = GetNewId()
		ItType = new TypeClass(this&)
		
		ParentTokens.Push(parents[^])

		IsPacked = isPacked
		Body = bdy
		CurrentFile.AllClasses.Push(this&)


		GClassesInProgress.Push(this&)
		cls := this&
		itFile := CurrentFile
		TSpawnTask(() ==> [cls,itFile] { //todo pass CurrentFile directly?
			CurrentFile = itFile
			cls.ParseBody()	
		})
	}
	AwaitTypeState := virtual !() -> void
	{
		FieldsState.Emit()
	}
	AwaitReadyState := virtual !() -> void
	{
		AwaitTypeState()
	}
	ParseBody := virtual !() -> void
	{
		GParsedAllFiles.Await()
		SyntaxCompress(Body,LexHVFileRoot)

		for i : ParentTokens.Size()
		{
			inhType := ParseType(ParentTokens[i])
			assert(inhType != null) //TODO
			assert(inhType is TypeClass) //TODO
			Parents.Push(inhType->{TypeClass^}.ToClass)
		}

		CurrentScope = this&

		funcs := List.{Tuple.{StringSpan,BoxFunc^}}

		iter := Body.Down

		while iter != null
		{
			if iter.Down?.Right?.GetValue() == ":="
			{
				assert(iter.Down is TokenIndent) //TODO
				name := iter.Down->{TokenIndent^}.Value

				itm := iter.Down.Right.Right

				asType := ParseType(itm)
				if asType != null
				{
					newField := new FieldParam(name,asType)
					Fields.Push(newField)
				}else
				{
					asFunc := TryParseFunction(itm)
					if asFunc != null
					{
						if asFunc is in BoxFunc
						{
							f := asFunc->{BoxFunc^}
							funcs.Emplace(name,f)
							f.SetName(name)
							f.Work()
						}else{
							assert(false) //template
						}
					}else
					{
						assert(false)
					}
				}
			}
			iter = iter.Right
		}

		if Parents.Size() != 0
		{
			Parents[0].AwaitVTableStep()
			for it,i : Parents[0].VTable
			{
				VTable.Push(it)
			}
		}

		for f : funcs
		{
			if f.1 is BoxFuncBody and f.1->{BoxFuncBody^}.Attrs.IsVirtual
			{
				vFunc := new VTableFunc(f.0,f.1)

				found := false
				for it : VTable
				{
					if it.IsEq(vFunc)
					{
						it = vFunc
						found = true
						break
					}
				}

				if not found
					VTable.Push(vFunc)
				Methods[f.0] .Push(f.1)
				f.1.ParseBody()
			}else
			{
				Methods[f.0] .Push(f.1)
			}
		}
		CreateVTable()
		VTableState.Emit()

		InheritStep()
		FieldsState.Emit()

	}
	GetField := virtual !(StringSpan val) -> FieldPath^
	{
		AwaitTypeState()

		for it : FieldsPath
		{
			if it.Field.Name == val
				return it
		}
	}
	AwaitVTableStep := virtual !() -> void { VTableState.Await() }
}
