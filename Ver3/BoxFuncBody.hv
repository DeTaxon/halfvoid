
BoxFuncBody := class extend BoxFuncCommon
{
	headerHatch := THatch

	Attrs := FuncAttributes

	Name := StringSpan
	OutputName := StringSpan

	inps1 := Token^
	resTyp := Token^
	bdy := Token^

	funcLine := BoxExeLine^

	//this := !(FuncAttributes atrs,Token^ brackets1,Token^ brackets2, Token^ resToken,Token^ bodyIn) -> void
	//{
	//	assert(brackets2 == null)//not implemented
	//	Attrs = atrs
	//	inps1 = brackets1
	//	resTyp = resToken
	//	bdy = bodyIn

	//}
	this := !(TypeFunc^ tp, FuncAttributes atrs, HybridQueue.{StringSpan,10} names, Token^ bodyIn) -> void
	{
		SetType(tp)
		Attrs = atrs
		bdy = bodyIn

		for par,i : tp.Params //TODO min(Params.Size(),names.Size())
		{
			parObj := new FuncInputParam(this&,names[i],par.ItType,par.IsRef,i)
			vr := new MemVar(names[i],parObj)
			Params.Push(vr)
		}
		if tp.ResultType != GTypeVoid
		{
			resSpn := StringSpan("result")
			rFnc := new FuncLocalParam(resSpn,tp.ResultType)
			ResultVar = new MemVar(resSpn,rFnc)
		}
		if DebugMode
		{
			funcLine = new BoxExeLine() //TODO debug only ExeLine version
			funcLine.ItToken = bdy
		}
	}

	GetType := !() -> Type^
	{
		ItTypeHatch.Await()
		return ItType
	}

	StartedParse := bool
	ParseBody := virtual !() -> void
	{
		if StartedParse
			return void
		StartedParse = true
		GFuncsInProgress.Push(this&)
		cls := this&
		TSpawnTask(() ==> [cls] {
			cls.WorkBody()
		})
	}
	SetName := virtual !(StringSpan nm) -> void
	{
		Name = nm
		if CurrentFile != null
		{
			CurrentFile.AllFunctions.Push(this&)
		}else{
			assert(false)
		}

		if CurrentCodeSpace != null
		{
			//assert(not CurrentCodeSpace.Functions[Name].Contain()) TODO
			CurrentCodeSpace.Functions[Name].Push(this&)
		}
	}
	
	//ParseHeader := !() -> void
	//{
	//	SyntaxCompress(inps1,LexHVInputVars)

	//	k := 0
	//	names := StringSpan[40]
	//	args := Type^[40] //TODO: infinite args?
	//	refs := bool[40]
	//	isVargs := false

	//	if CurrentScope is in BoxClass //TODO not static,
	//	{
	//		cls := CurrentScope->{BoxClass^}
	//		args[0] = cls.ItType
	//		names[0] = "this"
	//		refs[0] = true
	//		Attrs.IsMethod = true
	//		k += 1
	//	}

	//	objs := HybridQueue.{Token^,6}
	//	defer objs.Destroy()

	//	itr := inps1.Down

	//	checkObjs := () ==> {

	//		if objs.Size() == 2
	//		{
	//			assert(objs[1] is TokenIndent) //TODO EmitError
	//			
	//			args[k] = ParseType(objs[0])
	//			assert(args[k] != null) //TODO EmitError
	//			refs[k] = false
	//			names[k] = objs[1]->{TokenIndent^}.Value


	//			if IsComplexType(args[k])
	//				refs[k] = true

	//			assert(args[k] != null) //TODO error
	//			k += 1
	//		}else{
	//			assert(false)
	//		}
	//		objs.Clear()
	//	}

	//	while itr != null
	//	{
	//		if itr.GetValue() == ","
	//		{
	//			checkObjs()
	//		}else
	//		{
	//			objs.Push(itr)
	//		}
	//		itr = itr.Right
	//	}
	//	if objs.Size() != 0
	//		checkObjs()
	//	outType := ParseType(resTyp)
	//	resRef := false
	//	//TODO ref check


	//	fType := GetFuncType(k,args[0]&,refs[0]&,outType,resRef,isVargs)
	//	SetType(fType)
	//	

	//	for par,i : fType.Params //TODO min(Params.Size(),names.Size())
	//	{
	//		parObj := new FuncInputParam(this&,names[i],par.ItType,par.IsRef,i)
	//		vr := new MemVar(names[i],parObj)
	//		Params.PushFront(vr)
	//	}
	//	if outType != GTypeVoid
	//	{
	//		resSpn := StringSpan("result")
	//		rFnc := new FuncLocalParam(resSpn,outType)
	//		ResultVar = new MemVar(resSpn,rFnc)
	//	}
	//}

	Params := HybridQueue.{MemVar^,8}
	ResultVar := MemVar^

	body := BoxBlock^
	readyState := THatch
	WorkBody := virtual !() -> void
	{
		assert(UnitStack.Size() == 0)
		defer UnitStack.Destroy()

		UnitStack.PushFront(this&)
		defer readyState.Emit()

		OutputName = GetFuncMangle(Name)
		
		CurrentScope = this&

		for par : Params
		{
			UnitStack.PushFront(par)
		}
		if ResultVar != null
			UnitStack.Push(ResultVar)
		
		body = new BoxBlock(bdy)
		body.Work()
	}
	WaitReadyState := virtual !() -> void
	{
		readyState.Await()
	}
	PrintName := virtual !(TIOStream^ f) -> void
	{
		f^ << "@" << OutputName
	}

	PrintCode := virtual !(TIOStream^ f) -> void
	{
		if body == null
			return void
		GDebugFuncId = 0

		if DebugMode
		{
			GDebugFuncId = GetNewId()
			GDebugLineCallId = funcLine.MetaId
		}
		oldScope := GDebugScopeId
		defer GDebugScopeId = oldScope
		GDebugScopeId = GDebugFuncId

		f^ << "define "
		PrintResultType(f)
		f^ << " @" << OutputName << "("
		PrintInputTypes(f)
		f^ << ")"
		if DebugMode
			f^ << " !dbg !" << GDebugFuncId
		f^ << "\n"
		f^ << "{\n"


		rTyp := ItType.ResultType

		Params[^].Value->{FuncInputParam^}.PrintCode(f)
		if ResultVar != null
			ResultVar.PrintCode(f)
		
		body.PrintCode(f)

		if rTyp == GTypeVoid
		{
			f^ << "ret void"
			if DebugMode
				f^ << " , !dbg !" << GDebugLineCallId
			f^ << "\n"
		}else{
			if ResultVar != null
			{
				tmpList := CheckExeDownList
				cl := BoxFuncCall(ResultVar.Value,tmpList)

				cl.PrintPre(f)
				f^ << "ret "
				cl.GetType().PrintType(f)
				f^ << " "
				cl.PrintUse(f)
				if DebugMode
					f^ << " , !dbg !" << GDebugLineCallId
				f^ <<"\n"
			}
		}
			

		f^ << "}\n"

		if DebugMode
		{
			funcLine.PrintDebugMeta(f)
			body.PrintDebugMeta(f)
			Params[^].PrintDebugMeta(f)
			ResultVar?.PrintDebugMeta(f)
		}

		if DebugMode
		{
			f^ << "!" << GDebugFuncId << " = distinct !DISubprogram(name:\""
			PrintName(f)
			f^ << "\","
			f^ << "linkageName:\""
			PrintName(f)
			f^ << "\","
			f^ << "scope: !" << GDebugFileId << " , file: !" << GDebugFileId
			f^ << ",type: !" << GetType().MetaId
			if bdy.Line != null
			{
				f^ << ", line:" << bdy.Line.Line
				f^ << ", scopeLine:" << bdy.Line.Line
			}
			f^ << ", unit: !" << cuId
			f^ << ", flags: DIFlagPrototyped"
			f^ << ", spFlags: DISPFlagDefinition"
			//if tmplId != -1
			//	f << ", templateParams:!"<<tmplId
			f^ << ")\n"
		}
	}
}
