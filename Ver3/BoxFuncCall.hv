globalIdIter := 0
GetNewId := !() -> int
{
	globalIdIter += 1
	return globalIdIter
}

BoxFuncCall := class extend BoxExeObj
{
	callObj := BoxFunc^
	downs := ExeDownList
	resId := int
	this := !(BoxFunc^ fnc, CheckExeDownList objs) -> void
	{
		callObj = fnc

		if callObj is BoxFuncBody
			callObj->{BoxFuncBody^}.ParseBody()

		downs.Push(objs[^])
		resId = GetNewId()

		for par,i : fnc.GetType()->{TypeFunc^}.Params
		{
			if par.IsRef
			{
				downs[i].NotifyMemUse()
			}
		}

		for par,i : fnc.GetType()->{TypeFunc^}.Params
		{
			assert( i < downs.Size())
			if downs[i].GetType() != par.ItType
			{
				newObj := GetExchange(downs[i],par.ItType)
				assert(newObj != null)

				while newObj.GetType() != par.ItType
				{
					newObj = GetExchange(newObj,par.ItType) //TODO limit to some value
				}
				downs[i] = newObj
			}
		}
	}
	NotifyMemUse := virtual !() -> void
	{
		callObj.NotifyMemUse()
	}
	GetType := virtual !() -> Type^
	{
		return callObj.GetType()->{TypeFunc^}.ResultType
	}

	IsMem := virtual !() -> bool
	{
		return callObj.IsMem()
	}
	PrintFuncUse := !(TIOStream^ f) -> void
	{
		callObj.PrintFuncCall(f,resId,0,downs)
	}
	PrintPointPre := virtual !(TIOStream^ f) -> void
	{
		PrintFuncUse(f)
	}
	PrintPointUse := virtual !(TIOStream^ f) -> void
	{
		callObj.PrintResultObj(f,resId,-1)
	}
	PrintPre := virtual !(TIOStream^ f) -> void
	{
		if IsMem()
		{
			rType := GetType()

			PrintPointPre(f)
			f^ << "%TUnref" << resId << " = load "
			rType.PrintType(f)
			f^ << ","
			rType.PrintType(f)
			f^ << "* "
			PrintPointUse(f)
			if DebugMode
				f^ << ", !dgb !" << GDebugLineCallId
			f^ << "\n"
		}else{
			PrintFuncUse(f)
		}
	}
	PrintUse := virtual !(TIOStream^ f) -> void
	{
		if IsMem()
		{
			f^ << "%TUnref" << resId
		}else{
			callObj.PrintResultObj(f,resId,-1)
		}
	}
}
