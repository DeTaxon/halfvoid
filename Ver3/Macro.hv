CheckForCycleMacro := !(Token^ itm) -> void
{
	innerCheckForCycleMacro(itm)
}

innerCheckForCycleMacro := !(Token^ itm) -> void
{

	if MacroCycleRemade.Size() != 0
		return void

	if itm == null
		return void

	if itm.GetValue() == "{}"
		return void


	iter := itm.Down

	while iter != null
	{
		innerCheckForCycleMacro(iter)
		iter = iter.Right
	}
	
	if itm.Down?.Right?.GetValue() == "[]" and itm.Down.Right.Down.GetValue() == "^"
	{
		MacroCycleRemade.Emplace(itm,GetCycleVarName(),StringSpan(""))
	}
	return void
}

TryGetMacroCall := !(Token^ itm) -> BoxExeObj^
{
	if MacroCycleRemade[^].0 == itm
	{
		//TODO:
		return GetExeInt(10)
	}
	return null
}

GetCallWithMacro := !(Token^ itm) -> BoxUnit^
{

	if MacroCycleRemade.Size() == 0
	{
		CheckForCycleMacro(itm)
		Res := BoxUnit^
		if MacroCycleRemade.Size() != 0
		{
			Res = GetMacroCycledObj(itm,0) //todo VERY STUPID RECURCION CALL
		}else{
			Res = TryGetExeCall(itm)
		}

		MacroCycleRemade.Clear()

		return Res
	}else{
		return TryGetExeCall(itm)
	}

}
GetMacroCycledObj := !(Token^ itm, int i) -> BoxUnit^
{
	forItems := HybridQueue.{ForSubObjects,5}

	el := ForSubObjects

	el.DownToken = MacroCycleRemade[i].0.Down
	el.ValueName = GetCycleVarName()

	forItems.Push(el)

	return GetForParsed(itm,forItems)
}

MacroCycleRemade := List.{Tuple.{Token^,StringSpan,StringSpan}}

GetCycleVarName := !() -> StringSpan
{
	buff := char[255]
	sprintf(buff[0]&,"ItVar%i",GetNewId())
	result = GetConstString(buff[0]&)
}
