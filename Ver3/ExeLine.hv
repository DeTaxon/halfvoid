BoxExeLine := class extend BoxUnit
{
	
	Down := BoxExeObj^
	exitLabel := BoxLabel^
	GetLabel := !() -> BoxLabel^
	{
		if exitLabel == null
			exitLabel = new BoxLabel()
		return exitLabel
	}

	DoLine := !(Token^ itm) -> void
	{
		UnitStack.PushFront(this&)
		defer UnitStack.Pop()

		Down = TryGetExeCall(itm)
		if Down != null
			return void


		assert(false)
	}
	PrintCode := virtual !(TIOStream^ f) -> void
	{
		Down.PrintDefaultUse(f)
	}

}

ExeDownList := type HybridQueue.{BoxExeObj^,8}
CheckExeDownList := type HybridQueue.{BoxExeObj^,20}

BoxExeObj := class extend BoxUnit
{
	ObjType := Type^

	GetType := virtual !() -> Type^
	{
		return ObjType
	}
	IsMem := virtual !() -> bool
	{
		return false
	}
	PrintDefaultUse := virtual !(TIOStream^ f) -> void
	{
		if IsMem()
		{
			PrintPointPre(f)
		}else{
			PrintPre(f)
		}
	}
	PrintPointPre := virtual !(TIOStream^ f) -> void
	{
	}
	PrintPointUse := virtual !(TIOStream^ f) -> void
	{
	}
	PrintPre := virtual !(TIOStream^ f) -> void
	{
	}
	PrintUse := virtual !(TIOStream^ f) -> void
	{
	}
}

TryGetExeCall := !(Token^ itm) -> BoxExeObj^
{
	if itm == null
		return null

	isFuncCall := TryCheckRegularFuncCall(itm)
	if isFuncCall != null
		return isFuncCall
	
	isOperCall := TryCheckMathOperatorCall(itm)
	if isOperCall != null
		return isOperCall
	
	prm := TryExePrime(itm)
	if prm != null
		return prm

	isParamCall := TryCheckGetParam(itm)
	if isParamCall
		return isParamCall

	return null

}



TryCheckRegularFuncCall := !(Token^ itm) -> BoxExeObj^
{
	if itm.Down == null
		return null
	if itm.Down?.Right.GetValue() != "()"
		return null
	if itm.Down.Right.Right != null
		return null

	Objs := HybridQueue.{BoxExeObj^,20}

	itr := itm.Down.Right.Down

	while itr != null
	{
		if itr.GetValue() == "," //TODO maybe 
		{
		}else{
			obj := TryGetExeCall(itr)
			assert(obj != null)
			Objs.Push(obj)
		}
		itr = itr.Right
	}

	if itm.Down is TokenIndent
	{
		asInd := itm.Down->{TokenIndent^}
		return CreateFuncCall(asInd.Value,Objs)
	}else{
		assert(false)
	}

}

CreateFuncCall := !(StringSpan name, CheckExeDownList Objs) -> BoxFuncCall^
{
	callItem := BoxUnit^
	GetItemGlobal(name, x ==>{
		priorityes := HybridQueue.{int,13}
		defer priorityes.Destroy()

		for h : x
		{
			if h is in BoxFunc
			{
				fnc := h->{BoxFunc^}
				cmpRes := CmpFuncPriority(fnc.GetType(),Objs)
				priorityes.Push(cmpRes)
			}else{
				assert(false)
			}
		}

		bestI := 0
		for i : x.Size()
		{
			if priorityes[i] < priorityes[bestI]
				bestI = i
		}
		if priorityes[bestI] == 255
			return false
		callItem = x[bestI]
		return true
	})
	assert(callItem != null)
	if callItem == null
		return null
	if callItem is in BoxFunc
	{
		return new BoxFuncCall(callItem->{BoxFunc^},Objs)
	}
}

CmpFuncPriority := !(TypeFunc^ fncType, HybridQueue.{BoxExeObj^,20} objs) -> int
{
	worstCase := 0

	minArgs :=fncType.Params.Size()
	maxArgs :=fncType.Params.Size()

	if fncType.IsVargs
		maxArgs = 20000000 //TODO INT_MAX

	if objs.Size() > maxArgs or objs.Size() < minArgs
		return 255

	count := min(fncType.Params.Size(),objs.Size())

	for i : count
	{
		worstCase = max(worstCase,TypePriorCmp(fncType.Params[i].ItType,objs[i].GetType()) )
		if worstCase == 255
			return 255
	}
	//TODO, mst 255
	return worstCase
}
TypePriorCmp := !(Type^ frm, Type^ to) -> int
{
	if frm == to
		return 0
	
	if frm is TypePoint and to == GTypeVoidP
		return 1 //TODO TypeArr

	if frm is TypeStandard and to is TypeStandard
	{
		f1 := frm->{TypeStandard^}
		t1 := to->{TypeStandard^}

		if IsInt(f1) and IsInt(t1)
		{
			if f1.GetSize() > t1.GetSize()
				return 2
			return 1
		}
	}

	return 255
}

TypePriorityTable := AVLMap.{Type^,AVLMap.{Type^,int}}




