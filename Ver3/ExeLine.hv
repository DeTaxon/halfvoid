BoxExeLine := class extend BoxExeLineSimple
{
	exitLabel := BoxLabel^

	this := !() -> void
	{
		if DebugMode
			MetaId = GetNewId()
	}
	GetLabel := !() -> BoxLabel^
	{
		if exitLabel == null
			exitLabel = new BoxLabel()
		return exitLabel
	}

	DoLine := !(Token^ itm) -> void
	{
		UnitStack.PushFront(this&)
		defer UnitStack.Pop()
	
		ItToken = itm
		Down = TryGetExeCall(itm)
		if Down != null
			return void
		ItToken.Print(0)
		assert(false)
	}
}
BoxExeLineSimple := class extend BoxUnit
{
	MetaId := int
	ItToken := Token^
	Down := BoxUnit^

	this := !(Token^ itm,BoxUnit^ newObj) -> void
	{
		if DebugMode
			MetaId = GetNewId()
		ItToken = itm
		Down = newObj
	}
	PrintCode := virtual !(TIOStream^ f) -> void
	{
		oldLine := GDebugLineCallId
		defer GDebugLineCallId = oldLine
		GDebugLineCallId = MetaId
		
		if Down is in BoxExeObj
		{
			Down->{BoxExeObj^}.PrintDefaultUse(f)
		}else{
			Down.PrintCode(f)
		}
	}
	PrintDebugMeta := virtual !(TIOStream^ f) -> void
	{
		assert(ItToken != null and ItToken.Line != null)
		Down?.PrintDebugMeta(f)
		f^ << "!" << MetaId << " = !DILocation(line:" << ItToken.Line.Line << ",column:1, scope:!" << GDebugScopeId << ")\n"
	}
}

ExeDownList := type HybridQueue.{BoxExeObj^,8}
CheckExeDownList := type HybridQueue.{BoxExeObj^,20}

BoxExeObj := class extend BoxUnit
{
	ObjType := Type^

	GetType := virtual !() -> Type^
	{
		return ObjType
	}
	IsMem := virtual !() -> bool
	{
		return false
	}
	PrintDefaultUse := virtual !(TIOStream^ f) -> void
	{
		if IsMem()
		{
			PrintPointPre(f)
		}else{
			PrintPre(f)
		}
	}
	PrintPointPre := virtual !(TIOStream^ f) -> void
	{
	}
	PrintPointUse := virtual !(TIOStream^ f) -> void
	{
	}
	PrintPre := virtual !(TIOStream^ f) -> void
	{
	}
	PrintUse := virtual !(TIOStream^ f) -> void
	{
	}

}

BoxExeConstObj := class extend BoxExeObj
{
	IsConst := virtual true
	PrintConst := virtual !(TIOStream^ f) -> void {}
}

TryGetExeCall := !(Token^ itm) -> BoxExeObj^
{
	if itm == null
		return null

	return TryGetNewDeleteOperator(itm)?
	return TryGetBoolOrNone(itm)?
	return TryGetMetaCall(itm)?
	return TryCheckRegularFuncCall(itm)?
	return TryGetFieldCall(itm)?
	return TryCheckMethodCall(itm)?
	return TryGetPrefixOperator(itm)?
	return TryGetPostfixOperator(itm)?
	
	isOperCall := TryCheckMathOperatorCall(itm)
	if isOperCall != null
		return isOperCall
	
	prm := TryExePrime(itm)
	if prm != null
		return prm

	isParamCall := TryCheckGetParam(itm)
	if isParamCall != null
		return isParamCall
	
	unrefCall := TryGetUnrefObj(itm)
	if unrefCall != null
		return unrefCall
	return TryGetPtrObj(itm)?

	return null

}


CheckFuncCallBrackets := !(Token^ itm, CheckExeDownList Objs) -> void
{
	itr := itm.Down

	while itr != null
	{
		if itr.GetValue() == "," //TODO maybe 
		{
		}else{
			if itr.Down?.Right?.GetValue() == "..."
			{
				funcObj := BoxFuncBody^
				for it : UnitStack
				{
					if it is BoxFuncBody
					{
						funcObj = it->{BoxFuncBody^}
						break
					}
				}
				assert(funcObj != null) //TODO
				assert(funcObj.VariadicName.Size() != 0)

				stackSize := UnitStack.Size()

				for i : funcObj.Params.Size()
				{
					if i < funcObj.NamedParametersCount
						continue

					tmpVar := new MemVar(funcObj.VariadicName,funcObj.Params[i].Value)
					UnitStack.PushFront(tmpVar)

					obj := TryGetExeCall(itr.Down)
					assert(obj != null)
					Objs.Push(obj)

					while UnitStack.Size() > stackSize
						UnitStack.Pop()
					
				}
			}else{
				obj := TryGetExeCall(itr)
				assert(obj != null)
				Objs.Push(obj)
			}
		}
		itr = itr.Right
	}
}
CheckFuncCallConsts := !(Token^ itm, List.{BoxExeConstObj^} consts) -> void
{
	iter := itm.Down

	while iter != null
	{
		if iter.GetValue() == ","
		{
		}else{
			tp := ParseType(iter)
			if tp != null
			{
				consts.Push(GetConstType(tp))
			}else{
				cns := TryGetExeCall(iter)
				if cns != null
				{
					assert(cns is in BoxExeConstObj)
					consts.Push(cns->{BoxExeConstObj^})
				}else{
					assert(false)
				}
			}
		}
		iter = iter.Right
	}
}


GetBestFunc := !(HybridQueue.{BoxUnit^,10} x,CheckExeDownList Objs,List.{BoxExeConstObj^} consts) -> BoxUnit^
{
	priorityes := HybridQueue.{int,13}
	defer priorityes.Destroy()

	for h : x
	{
		if h is in BoxFunc
		{
			fnc := h->{BoxFunc^}
			cmpRes := CmpFuncPriority(fnc.GetType()->{TypeFunc^},Objs)
			priorityes.Push(cmpRes)
		}else if h is in BoxFuncTemplate{
			tmpl := h->{BoxFuncTemplate^}
			cmpRes := tmpl.GetPriority(Objs,consts)
			priorityes.Push(cmpRes)
		}else{
			priorityes.Push(CmpNoExchange)
			assert(false)
		}
	}

	bestI := 0
	for i : x.Size()
	{
		if priorityes[i] < priorityes[bestI]
			bestI = i
	}
	if priorityes[bestI] == CmpNoExchange
		return null
	return x[bestI]
}

CreateFuncCall := !(StringSpan name, CheckExeDownList Objs,List.{BoxExeConstObj^} consts) -> BoxFuncCall^
{
	callItem := BoxUnit^
	GetItemGlobal(name, x ==>{
		callItem = GetBestFunc(x,Objs,consts)
		if callItem == null
			return false
		return true
	})
	if callItem == null
		return null
	if callItem is in BoxFuncTemplate
	{
		callItem = callItem->{BoxFuncTemplate^}.GetFunc(Objs,consts)
	}
	if callItem is in BoxFunc
	{
		return new BoxFuncCall(callItem->{BoxFunc^},Objs)
	}
}

CmpNoExchange := 999000

CmpFuncPriority := !(TypeFunc^ fncType, CheckExeDownList objs) -> int
{
	worstCase := 0

	minArgs :=fncType.Params.Size()
	maxArgs :=fncType.Params.Size()

	if fncType.IsVargs
		maxArgs = 20000000 //TODO INT_MAX

	if objs.Size() > maxArgs or objs.Size() < minArgs
		return CmpNoExchange

	count := min(fncType.Params.Size(),objs.Size())

	for i : count
	{
		worstCase = max(worstCase,TypePriorCmp(objs[i].GetType(),fncType.Params[i].ItType,objs[i].IsMem()))
		if worstCase == CmpNoExchange
			return CmpNoExchange
	}
	return worstCase
}
TypePriorCmp := !(Type^ frm, Type^ to, bool isMem) -> int
{
	if frm == to
		return 0

	if frm is TypePoint and frm.Base is TypeClass and to is TypeClass
	{
		if TypeFight(frm.Base,to) == to
			return 1000 //todo rethink
	}

	if isMem //!!!!IMPORTANT PART
	{
		if frm is TypeClass and to is TypeClass
		{
			res := TypeFight(frm,to)
			if res == to
				return 1000
		}
		return CmpNoExchange
	}

	if frm is TypePoint and to is TypePoint
	{
		if to == GTypeVoidP
			return 1000
		if frm.Base is TypeClass and to.Base is TypeClass
		{
			fgh := TypeFight(frm.Base,to.Base)
			if fgh == to.Base
				return 1000
		}
	}

	if frm is TypeStandard and to is TypeStandard
	{
		f1 := frm->{TypeStandard^}
		t1 := to->{TypeStandard^}

		if IsInt(f1) and IsInt(t1)
		{
			if f1.GetSize() > t1.GetSize()
			{
				return 2000 + (100 - t1.GetSize())
			}
			return 1000 + (100 - t1.GetSize())
		}
		if IsFloat(f1) and IsFloat(t1)
		{
			if f1.GetSize() > t1.GetSize()
			{
				return 2000 + (100 - t1.GetSize())
			}
			return 1000 + (100 - t1.GetSize())
		}
		if IsInt(f1) and IsFloat(t1)
		{
			return 1000 + (100 - t1.GetSize())
		}
		if IsFloat(f1) and IsInt(t1)
		{
			return 2000 + (100 - t1.GetSize()) //TODO warning, but not here
		}
	}
	if frm is TypePoint and to == GTypeVoidP
	{
		return 1000
	}

	return CmpNoExchange
}
TypeFight := !(Type^ a, Type^ b) -> Type^
{
	if a == b
		return a

	if a is TypeClass and b is TypeClass
	{
		ac := a->{TypeClass^}.ToClass
		bc := b->{TypeClass^}.ToClass

		for ap : ac.PrimeParents
		{
			for bp : bc.PrimeParents
			{
				if ap.0 == bp.0
				{
					if ap.2 == bp.2
					{
						assert(a != b)
						return TypeFight(ap.1.ItType,bp.1.ItType)
					}else{
						if ap.2 > bp.2
						{
							return TypeFight(ap.1.ItType,b)
						}else{
							return TypeFight(a,bp.1.ItType)
						}
					}
					

				}
			}
		}

	}
	return null
}

TypePriorityTable := AVLMap.{Type^,AVLMap.{Type^,int}}




