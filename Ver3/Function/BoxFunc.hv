BoxFunc := class extend BoxExeConstObj
{
	ItTypeHatch := THatch

	GetType := virtual !() -> Type^
	{
		ItTypeHatch.Await()
		return ObjType
	}
	SetType := !(TypeFunc^ tp) -> void
	{
		ObjType = tp
		ItTypeHatch.Emit()
	}
	IsMem := virtual !() -> bool
	{
		return GetType()->{TypeFunc^}.ResultRef
	}
	WorkBody := virtual !() -> void
	{
	}
	SetName := virtual !(StringSpan nm) -> void
	{
	}
	WaitReadyState := virtual !() -> void
	{
	}
	PrintCode := virtual !(TIOStream^ f) -> void
	{
	}
	GetExitLabel := virtual !() -> BoxLabel^
	{
		assert(false)
	}
	PrintResultType := virtual !(TIOStream^ f) -> void
	{
		fTyp := GetType()->{TypeFunc^}
		if fTyp.ResultType.IsComplexReturn()
		{
			GTypeVoid.PrintType(f)
		}else{
			fTyp.ResultType.PrintType(f) //TODO return class
		}
	}
	ParseBody := virtual !() -> void
	{
	}
	PrintUse := virtual !(TIOStream^ f) -> void
	{
		PrintName(f)
	}
	PrintInputTypes := virtual !(TIOStream^ f) -> void
	{
		fTyp := GetType()->{TypeFunc^}
		needComma := false

		if fTyp.ResultType.IsComplexReturn()
		{
			fTyp.ResultType.PrintType(f)
			f^ << "* %result" 
			needComma = true
		}

		for par,i : fTyp.Params
		{
			if needComma
				f^ << ","
			needComma = true

			par.ItType.PrintType(f)
			if par.IsRef
				f^ << "*"
			f^ << " %par" << i
		}
		if GetType()->{TypeFunc^}.IsVargs
		{
			if needComma
				f^ << ","
			f^ << "..."
		}
	}
	PrintName := virtual !(TIOStream^ f) -> void
	{
	}
	PrintResultObj := virtual !(TIOStream^ f, int resId, int debId) -> void
	{
	}
	PrintFuncCall := virtual !(TIOStream^ f,int resId,int debId,ExeDownList lst) -> void
	{
	}
}

BoxFuncCommon := class extend BoxFunc
{
	PrintResultObj := virtual !(TIOStream^ f, int resId, int debId) -> void
	{
		fTyp := GetType()->{TypeFunc^}
		if fTyp.ResultType != GTypeVoid
		{
			f^ << "%T" << resId
		}
	}
	PrintFuncCall := virtual !(TIOStream^ f,int resId,int debId,ExeDownList lst) -> void
	{
		PrintFuncCallCommon(f,this&,resId,lst)
	}
}

PrintFuncCallResultCommon := !(TIOStream^ f,TypeFunc^ fTyp,int resId) -> void
{
	if fTyp.ResultType != GTypeVoid
	{
		f^ << "%T" << resId
	}
}
PrintFuncCallCommon := !(TIOStream^ f,BoxExeObj^ fncObj,int resId,ExeDownList lst) -> void
{
	itType := TypeFunc^
	if fncObj is in BoxFunc
	{
		itType = fncObj.GetType()->{TypeFunc^}
	}else{
		tmpType := fncObj.GetType()
		assert(tmpType is in TypePoint and tmpType.Base is TypeFunc)
		itType = tmpType.Base->{TypeFunc^}
	}

	sType := itType
	itType = NormalizeFuncType(itType)

	for itm,i : lst
	{
		if itType.Params.Size() > i and itType.Params[i].IsRef
		{
			itm.PrintPointPre(f)
		}else{
			itm.PrintPre(f)
		}
	}
	fncObj.PrintPre(f)


	if itType.ResultType != GTypeVoid
	{
		f^ << "%T" << resId << " = "
	}

	f^ << "call "
	if itType.IsVargs
	{
		itType.PrintType(f)
	}else{
		itType.ResultType.PrintType(f)
	}
	fncObj.PrintUse(f)

	f^ << "("
	
	needComma := false

	for dwn,i : lst
	{
		if needComma
			f^ << ","
		needComma = true
		
		if itType.Params.Size() > i and itType.Params[i].IsRef
		{
			dwn.GetType().PrintType(f)
			f^ << "* "
			dwn.PrintPointUse(f)
		}else{
			dwn.GetType().PrintType(f)
			f^ << " "
			dwn.PrintUse(f)
		}
	}

	f^ << ")"
	if DebugMode
		f^ << ", !dbg !" << GDebugLineCallId
	f^ << "\n"
}

NormalizeFuncType := !(TypeFunc^ inp) -> TypeFunc^
{
	if inp.ResultType.IsComplexReturn()
	{
	}else{
		return inp
	}

	if inp.ResultRef
		return inp
	
	k := 0
	typs := Type^[100]
	bls := bool[100]

	typs[0] = inp.ResultType
	bls[0] = true
	k += 1

	for i : inp.Params.Size()
	{
		typs[k] = inp.Params[i].ItType
		bls[k] = inp.Params[i].IsRef
		k += 1
	}
	return GetFuncType(k,typs[0]&,bls[0]&,GTypeVoid,false,inp.IsVargs)
}
