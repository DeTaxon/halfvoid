AppendClass BoxFuncBody
{
	Yields := List.{BoxYield^}
	YieldStart := BoxLabel^
	YieldStateInt := ParamFunc^
	//YieldTupleVar := ParamFunc^
	YieldFinilize := BoxExeObj^

	gcVars := List.{FuncGCLocalParam^}
	regularVars := List.{ParamFunc^}
    
	Params := HybridQueue.{MemVar^,8}
	ResultVar := MemVar^

	PutYieldState := !(BoxYield^ yld) -> int
	{
		if YieldStart == null
			YieldStart = new BoxLabel()

		res := Yields.Size() + 1
		Yields.Push(yld)
		return res
	}
	IsGenerator := !() -> bool
	{
		return Yields.Size() != 0
	}
	GetYieldStateParam := !() -> ParamFunc^
	{
		if YieldStateInt == null
		{
			assert(CurrentFunc == this&)

			Objs := CheckExeDownList
			asRawPar := new FuncInputParam(GTypeVoidP,false,StringSpan("%par0")) //TODO: way too bad
			Objs.Push(asRawPar.CreateCall())

			yGet := TemplateInternalGetYieldState.CreateCall(Objs)
			YieldStateInt = new FuncResultParam(yGet)
			asRawPar.PopulateCalls()
		}
		return YieldStateInt
	}
	GetYieldTuple := !() -> BoxClass^
	{
		tps := List.{Type^}

		if not IsGenerator()
			return GetTuple(tps)
		
		for it,i : regularVars
		{
			tps.Push(it.GetVarType())
		}
		tpl := GetTuple(tps)
		tps.Destroy()
		return tpl
	}
	YieldWork := !() -> void
	{
		for it : regularVars
			it.NotifyCaptureUse()
			
		if Yields.Size() == 0
			return void
		
		
		yTuple := GetCaptureTuple()
		
		asRawPar := new FuncInputParam(GTypeVoidP,false,StringSpan("%par0")) //TODO: way too bad

		Objs := CheckExeDownList
		Objs.Push(asRawPar.CreateCall())
		cnsts := List.{BoxExeConstObj^}
		cnsts.Push(GetConstType(yTuple.ItType))

		getVars := TemplateInternalGetYieldVars.GetFunc(Objs,cnsts)
		assert(getVars != null)
		CapturedVarsTuple = new FuncResultParam(new PtrToRefFuncCall(getVars.CreateCall(Objs)))
		asRawPar.PopulateCalls()


		finObjs := CheckExeDownList
		finObjs.Push(YieldStateInt.CreateCall())
		finObjs.Push(GetExeInt(-1))
		YieldFinilize = CreateFuncCall(StringSpan("="),finObjs)
	}
	PrintYieldCodeParams := !(TIOStream^ f) -> void
	{
		if YieldStateInt == null
			return void

		YieldStateInt.PrintCode(f)
	}
	PrintYieldCodeParamsGC := !(TIOStream^ f) -> void
	{
		if YieldStateInt == null
			return void

	}
	PrintYieldCodeGo := !(TIOStream^ f) -> void
	{
		if YieldStateInt == null
			return void

		cl := BoxFuncCall(YieldStateInt) //todo??
		cl.PrintPre(f)

		f^ << "switch i32 "
		cl.PrintUse(f)
		f^ << ", label "
		YieldStart.PrintLabel(f)
		f^ << "["
		for it,i : Yields
		{
			c:= i + 1
			f^ << "i32 " << c << ", label " 
			it.GetLabel().PrintLabel(f)
			f^ << "\n"
		}
		//f << "i32 " << (SLambdaFinishYieldValue - 1) << ", label %QuitFunc\n" TODO: error function
		f^ << "]"
		if DebugMode
			f^ << ", !dbg !" << GDebugLineCallId
		"\n"

		YieldStart?.PrintCode(f)
	}

	PrintYieldCreateVar := virtual !(TIOStream^ f) -> void
	{
		if gcVarsCount == 0
			return void
			
		gcArrayVar.PrintCode(f)
	}

	YieldPrintFinilize := !(TIOStream^ f) -> void
	{
		if YieldStateInt == null
			return void
		assert(YieldFinilize != null)
		YieldFinilize.PrintDefaultUse(f)
	}
}
