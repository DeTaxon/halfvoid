AppendClass BoxFuncBody
{

	ParentFunc := BoxFuncBody^
	ThisCaptureTupleType := Type^
	CaptureGetCall := BoxExeObj^

	CapturedVars := List.{ParamFunc^}
	CapturedVarsTuple := ParamFunc^
	CapturedVarsGets := List.{ParamFunc^}

	WorkBodyCaptures := !() -> void
	{
		if CapturedVars.Size() == 0 //TODO case for non captured lambdas
			return void
		
		tplClass := GetCaptureTuple()
		CapturedVarsTuple = new FuncLocalParam(tplClass.ItType)
		
		for  it,i : CapturedVars
		{
			indCall := tplClass.GetFieldByIndex(i)
			dat := CheckExeDownList
			varCall := new BoxFuncCall(CapturedVarsTuple,dat)
			dat2 := CheckExeDownList
			dat2.Push(varCall)
			cl := new BoxFuncCall(indCall,dat2)
			dat.Clear()
			dat2.Clear()

			it.exeObj = cl
			it->SetType(FuncResultParam)
		}

		for it, i : CapturedVarsGets
		{
			emp := CheckExeDownList
			getVar := new BoxFuncCall(CapturedVarsTuple,emp)
			c1 := new UnrefFuncCall(getVar)
			it.exeObj = GetExchange(c1,it.GetType()->{TypeFunc^}.ResultType)
		}
	}
	CreateGetCaptureCall := !() -> void
	{
		empty := CheckExeDownList
		objs3 := CheckExeDownList
		objs3.Push(new BoxFuncCall(Params[0].Value,empty))
		cnsts := List.{BoxExeConstObj^}
		cnsts.Push(GetConstType(ThisCaptureTupleType))
		lGCall := TemplateInternalGetCaptures.GetFunc(objs3,cnsts)
		assert(lGCall != null)
		cnsts.Destroy()

		CaptureGetCall = new BoxFuncCall(lGCall,objs3)
	}

	GetCaptureTuple := !() -> BoxClass^
	{
		tps := List.{Type^}
		tps.Push(CapturedVars[^].GetType()->{TypeFunc^}.ResultType)
		tplClass := GetTuple(tps)
		tps.Destroy()
		
		return tplClass
	}

	Yields := List.{BoxYield^}
	YieldStart := BoxLabel^
	YieldStateInt := ParamFunc^
	YieldTupleVar := ParamFunc^

	gcVars := List.{FuncGCLocalParam^}
	regularVars := List.{ParamFunc^}

	PutYieldState := !(BoxYield^ yld) -> int
	{
		if YieldStart == null
			YieldStart = new BoxLabel()

		res := Yields.Size() + 1
		Yields.Push(yld)
		return res
	}
	IsGenerator := !() -> bool
	{
		return Yields.Size() != 0
	}
	GetYieldStateParam := !() -> ParamFunc^
	{
		if YieldStateInt == null
		{
			assert(CurrentFunc == this&)

			empt := CheckExeDownList
			Objs := CheckExeDownList
			Objs.Push(new BoxFuncCall(Params[0].Value,empt))

			yGet := new BoxFuncCall(TemplateInternalGetYieldState,Objs)

			YieldStateInt = new FuncResultParam(yGet)
		}
		return YieldStateInt
	}
	GetYieldTuple := !() -> BoxClass^
	{
		tps := List.{Type^}

		if not IsGenerator()
			return GetTuple(tps)
		
		for it,i : regularVars
		{
			tps.Push(it.GetVarType())
		}
		tpl := GetTuple(tps)
		tps.Destroy()
		return tpl
	}
	YieldWork := !() -> void
	{
		if Yields.Size() == 0
			return void
		yTuple := GetYieldTuple()

		Objs := CheckExeDownList
		Objs.Push(new BoxFuncCall(Params[0].Value))

		cnsts := List.{BoxExeConstObj^}
		cnsts.Push(GetConstType(yTuple.ItType))

		getVars := TemplateInternalGetYieldVars.GetFunc(Objs,cnsts)
		assert(getVars != null)
		YieldTupleVar = new FuncResultParam(new BoxFuncCall(getVars,Objs))

		for it,i : regularVars
		{
			fCall := yTuple.GetFieldByIndex(i)
			assert(fCall != null)
			objs2 := CheckExeDownList
			objs2.Push(new BoxFuncCall(YieldTupleVar))
			it.exeObj = new BoxFuncCall(fCall,objs2)
			it->SetType(FuncResultParamInGenerator)
		}

		for it,i : gcVars
		{
			it->SetType(FuncGCLocalParamInYield)
		}
	}
	PrintYieldCodeParams := !(TIOStream^ f) -> void
	{
		if YieldStateInt == null
			return void

		YieldTupleVar?.PrintCode(f)
		regularVars[^]->{FuncResultParamInGenerator^}.PrintAtStart(f)

		YieldStateInt.PrintCode(f)
	}
	PrintYieldCodeParamsGC := !(TIOStream^ f) -> void
	{
		if YieldStateInt == null
			return void

		gcVars[^]->{FuncGCLocalParamInYield^}.PrintGetGCVar(f)
	}
	PrintYieldCodeGo := !(TIOStream^ f) -> void
	{
		if YieldStateInt == null
			return void

		cl := BoxFuncCall(YieldStateInt)
		cl.PrintPre(f)

		f^ << "switch i32 "
		cl.PrintUse(f)
		f^ << ", label "
		YieldStart.PrintLabel(f)
		f^ << "["
		for it,i : Yields
		{
			c:= i + 1
			f^ << "i32 " << c << ", label " 
			it.GetLabel().PrintLabel(f)
			f^ << "\n"
		}
		//f << "i32 " << (SLambdaFinishYieldValue - 1) << ", label %QuitFunc\n" TODO: error function
		f^ << "]"
		if DebugMode
			f^ << ", !dbg !" << GDebugLineCallId
		"\n"

		YieldStart?.PrintCode(f)
	}
}