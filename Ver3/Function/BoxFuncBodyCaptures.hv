AppendClass BoxFuncBody
{
	CaptureUsed := bool

	ParentFunc := BoxFuncBody^
	ThisCaptureTupleType := Type^
	CaptureGetCall := BoxExeObj^

	CapturedVars := List.{ParamFunc^}
	CapturedVarsTuple := ParamFunc^
	CapturedVarsGets := List.{MacroParam^}
	CapturedVarsCleanup := BoxExeObj^

	CapturedBySomeVars := AVLMap.{StringSpan,Tuple.{NamedVar^,MemVar^,BoxExeObj^}} //By ref,value

	WorkBodyCaptures := !() -> void
	{
		if CapturedVars.Size() == 0 //TODO case for non captured lambdas
			return void
		
		containGC := false
		for it : CapturedVars
		{
			typ := it.GetVarType()
			if IsGCPtr(typ)
			{
				containGC = true
				break
			}
		}

		if CapturedVarsTuple == null
		{
			tplClass := GetCaptureTuple()
			CapturedVarsTuple = new FuncLocalParam(tplClass.ItType)
		}

		for it, i : CapturedVarsGets
		{
			it.PopulateCalls2(() ==>
			{
				getVar := CapturedVarsTuple.CreateCall()
				c1 := new UnrefFuncCall(getVar)
				return GetExchange(c1,it.GetVarType())
			})
			//getVar := CapturedVarsTuple.CreateCall()
			//c1 := new UnrefFuncCall(getVar)
			//it.exeObj = GetExchange(c1,it.GetType()->{TypeFunc^}.ResultType)
		}
		if containGC
		{
			InternalsHatch.Await()

			objs5 := CheckExeDownList
			objs5.Push(CapturedVarsTuple.CreateCall())
			cnsts := List.{BoxExeConstObj^}
			cleanFunc := GCleanGCClass.GetFunc(objs5,cnsts)
			assert(cleanFunc != null)
			CapturedVarsCleanup = cleanFunc.CreateCall(objs5)
		}
	}
	CreateGetCaptureCall := !() -> void
	{
		asRawPar := new FuncInputParam(GTypeVoidP,false,StringSpan("%par0")) //TODO: way too bad

		CaptureGetCall = innerGetCaptureCall(asRawPar)
		getCaptureInLeafs = innerGetCaptureCall(Params[0].Value)
		asRawPar.PopulateCalls()
	}

	innerGetCaptureCall := !(ParamFunc^ val) -> BoxExeObj^
	{
		objs3 := CheckExeDownList
		objs3.Push(val.CreateCall())
		cnsts := List.{BoxExeConstObj^}
		cnsts.Push(GetConstType(ThisCaptureTupleType))
		lGCall := TemplateInternalGetCaptures.GetFunc(objs3,cnsts)
		assert(lGCall != null)
		cnsts.Destroy()
		
		return lGCall.CreateCall(objs3)
	}

	GetCaptureTuple := !() -> BoxClass^
	{
		tps := List.{Type^}
		tps.Push(CapturedVars[^].GetType()->{TypeFunc^}.ResultType)
		tplClass := GetTuple(tps)
		tps.Destroy()
		
		return tplClass
	}

	getCaptureInLeafs := BoxExeObj^
	inChain := bool
	NotifyChainCapture := !() -> void
	{
		assert(Attrs.IsLambda)

		if inChain
			return void

		Params[0].Value.NotifyCaptureUse()
		inChain = true
	}

	PrintStackData := virtual !(TIOStream^ f) -> void
	{
		CapturedVarsTuple?.PrintCode(f)
		PrintYieldCodeParams(f)
		PrintCaptureUsage(f,true)
	}
	PrintCaptureUsage := !(TIOStream^ f,bool isFirstCall) -> void
	{
		if ParentFunc == null
			return void
		
		getThisCapture := CaptureGetCall
		if not isFirstCall
			getThisCapture = getCaptureInLeafs
		if getThisCapture == null
			return void //todo, too lazy way to check if lambda captured some variables
		//if not isFirstCall
		//	return void

		assert(ParentFunc.CapturedVarsTuple.GetVarType() is TypeClass)

		getThisCapture.PrintPre(f)
		subType := getThisCapture.GetType()
		ParentFunc.CapturedVarsTuple.PrintResultObj(f,0,0)
		f^ << " = bitcast "
		subType.PrintType(f)
		f^ << " "
		getThisCapture.PrintUse(f)
		f^ << " to "
		ParentFunc.CapturedVarsTuple.GetVarType().PrintType(f)
		f^ << "*"
		if DebugMode
			f^ << " , !dbg !" << GDebugLineCallId
		f^ <<"\n"
		


		ParentFunc?.PrintCaptureUsage(f,false)
	}
	EnterScope := !(!()&->void cb) -> void
	{
		oldFunc := CurrentFunc
		CurrentFunc = this&
		cb()
		CurrentFunc = oldFunc
	}
}
