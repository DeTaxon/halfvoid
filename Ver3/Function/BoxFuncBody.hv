
BoxFuncBody := class extend BoxFuncCommon
{
	headerHatch := THatch

	Attrs := FuncAttributes

	Name := StringSpan
	OutputName := StringSpan

	inps1 := Token^
	resTyp := Token^
	bdy := Token^

	funcLine := BoxExeLine^

	Constants := List.{BoxUnit^}
	ConstVars := List.{BoxUnit^}

	NamedParametersCount := int
	VariadicName := StringSpan

	ExitLabel := BoxLabel^

	gcVarsCount := int
	gcArrayVar := ParamFunc^
	gcArrayPtr := ParamFunc^

	InputVarNames := List.{StringSpan}

	ParentScope := BoxUnit^
	GetParentScope := virtual !() -> BoxUnit^
	{
		return ParentScope
	}

	NotifyGCUsed := !() -> void 
	{
		gcVarsCount = max(gcVarsCount,GCVarsInUse)

		if gcArrayPtr == null
			gcArrayPtr = new FuncInputParam(GCType.GetPoint().GetPoint(),false,StringSpan("%GCArrayPtr"))
	}

	this := !(TypeFunc^ tp, FuncAttributes atrs, HybridQueue.{StringSpan,10} names, Token^ bodyIn) -> void
	{
		Name = "anon"
		SetType(tp)
		Attrs = atrs
		bdy = bodyIn

		if not Attrs.IsAutoResult
		{
		//printf("hey %i\n",Attrs.IsAutoResult)
			ResultTypeHatch.Emit()
		}

		NamedParametersCount = names.Size()
		InputVarNames.Push(names[^])

		if DebugMode
		{
			funcLine = new BoxExeLine() //TODO debug only ExeLine version
			funcLine.ItToken = bdy
			assert(funcLine.ItToken.Line != null)
		}
		ExitLabel = new BoxLabel() 
	}

	ResultTypeHatch := THatch
	GetType := virtual !() -> Type^
	{
		ItTypeHatch.Await()
		ResultTypeHatch.Await()
		return ObjType
	}

	StartedParse := bool
	StartedParseForced := bool
	ParseBody := virtual !() -> void
	{
		if StartedParse
			return void
		StartedParse = true
		GFuncsInProgress.Push(this&)
		cls := this&
		TSpawnTask(() ==> [cls] {
			cls.ParseBodyForced()
		})
	}
	ParseBodyForced := virtual !() -> void
	{
		if StartedParseForced
			return void
		StartedParseForced = true
		this.WorkBody()
	}
	SetName := virtual !(StringSpan nm) -> void
	{
		Name = nm

		if CurrentCodeSpace != null
		{
			//assert(not CurrentCodeSpace.Functions[Name].Contain()) TODO
			CurrentCodeSpace.Functions[Name].Push(this&)
		}
	}
	SetPrintName := virtual !(StringSpan nm) -> void
	{
		Name = nm
	}
	ForceOutputName := virtual !(StringSpan nm) -> void {
		OutputName = nm
	}
	GetExitLabel := virtual !() -> BoxLabel^
	{
		return ExitLabel
	}

	body := BoxBlock^
	readyState := THatch
	WorkBody := virtual !() -> void
	{
		oldVarsCount := GCVarsInUse
		GCVarsInUse = 0

		oldFunc := CurrentFunc //todo defer  PushStack(CurrentFunc,this&)
		ParentFunc = oldFunc
		CurrentFunc = this&
		
		AllFunctions.Push(this&)

		stackSize := UnitStack.Size()

		if stackSize == 0 //TODO better way of readding constants
			ScopePutConstants()

		UnitStack.PushFront(this&)

		tp := ObjType ->{TypeFunc^}

		for par,i : tp.Params //TODO min(Params.Size(),names.Size())
		{
			name := StringSpan("")
			if i < InputVarNames.Size()
				name = InputVarNames[i]
			parObj := new FuncInputParam(par.ItType,par.IsRef,GetParSpan(i))
			vr := new MemVar(name,parObj)
			Params.Push(vr)
		}
		if not Attrs.IsAutoResult
			CreateResultVar()

		UnitStack.PushFront(ConstVars[^])

		OutputName = GetFuncMangle(Name)
		
		CurrentScope = this&

		for par : Params
		{
			UnitStack.PushFront(par)
		}
		
		if ResultVar != null
			UnitStack.PushFront(ResultVar)
		
		body = new BoxBlock(bdy)
		body.Work()

		if Attrs.IsAutoResult
			CheckReturnStep()

		if gcVarsCount != 0
		{
			x := GTypeVoidP.GetArray(gcVarsCount)
			gcArrayVar = new FuncLocalParam(x)
			regularVars.Push(gcArrayVar)
			//gcArrayVar = body.CreateVar(GTypeVoidP.GetArray(gcVarsCount),false) //TODO
		}
		WorkBodyCaptures()
		YieldWork()
		
		while UnitStack.Size() > stackSize
		{
			UnitStack.Pop()
		}
		CurrentFunc = oldFunc
		GCVarsInUse = oldVarsCount

		ResultTypeHatch.Emit()
		readyState.Emit()
	}
	WaitReadyState := virtual !() -> void
	{
		readyState.Await()
	}
	PrintName := virtual !(TIOStream^ f) -> void
	{
		f^ << "@" << OutputName
	}

	PrintCode := virtual !(TIOStream^ f) -> void
	{
		if body == null
			return void
		GDebugFuncId = 0
		CurrentFunc = this&

		if DebugMode
		{
			GDebugFuncId = GetNewId()
			GDebugLineCallId = funcLine.MetaId
		}
		oldScope := GDebugScopeId
		defer GDebugScopeId = oldScope
		GDebugScopeId = GDebugFuncId

		f^ << "define "
		PrintResultType(f)
		f^ << " @" << OutputName << "("
		PrintInputTypes(f)
		f^ << ")"
		if DebugMode
			f^ << " !dbg !" << GDebugFuncId
		f^ << "\n"
		f^ << "{\n"

		if ParentFunc != null
		{
			if CaptureGetCall != null
			{
				CaptureGetCall?.PrintDefaultUse(f)
				ParentFunc.CapturedVarsTuple.PrintResultObj(f,0,0)
				f^ << " = getelementptr "
				ThisCaptureTupleType.PrintType(f)
				f^ << " , "
				ThisCaptureTupleType.PrintType(f)
				f^ << "* "
				CaptureGetCall.PrintUse(f)
				f^ << ", i32 0"
				if DebugMode
					f^ << " , !dbg !" << GDebugLineCallId
				f^ <<"\n"
				ParentFunc.CapturedVars[^].PrintCode(f)
			}
		}

		PrintYieldCodeParams(f)

		if gcVarsCount != 0
		{
			gcArrayVar.PrintCode(f)

			tp := GTypeVoidP.GetArray(gcVarsCount)
			f^ << "%GCArrayPre = getelementptr "
			tp.PrintType(f)
			f^ << " , "
			tp.PrintType(f)
			f^ << "* "
			gcArrayVar.PrintResultObj(f,0,0)
			f^ << " , i32 0, i32 0"
			if DebugMode
				f^ << " , !dbg !" << GDebugLineCallId
			f^ <<"\n"

			f^ << "%GCArrayPtr = bitcast i8** %GCArrayPre to "
			GCType.PrintType(f)
			f^ << "**"
			if DebugMode
				f^ << " , !dbg !" << GDebugLineCallId
			f^ <<"\n"
		}
		PrintYieldCodeParamsGC(f)
		PrintYieldCodeGo(f)

		rTyp := GetType()->{TypeFunc^}.ResultType

		CapturedVarsTuple?.PrintCode(f)
		CapturedVarsGets[^].PrintCode(f)
		Params[^].PrintCode(f)
		ResultVar?.PrintCode(f)
		
		body.PrintCode(f)

		YieldPrintFinilize(f)

		ExitLabel.PrintCode(f)

		if rTyp == GTypeVoid or rTyp.IsComplexReturn()
		{
			f^ << "ret void"
			if DebugMode
				f^ << " , !dbg !" << GDebugLineCallId
			f^ << "\n"
		}else{
			if ResultVar != null
			{
				tmpList := CheckExeDownList
				cl := BoxFuncCall(ResultVar.Value,tmpList)

				cl.PrintPre(f)
				f^ << "ret "
				cl.GetType().PrintType(f)
				f^ << " "
				cl.PrintUse(f)
				if DebugMode
					f^ << " , !dbg !" << GDebugLineCallId
				f^ <<"\n"
			}
		}
			

		f^ << "}\n"

		if DebugMode
		{
			oldFileId := GDebugFileId //todo fix FileId

			if bdy?.Line?.File != null
			{
				GDebugFileId = bdy.Line.File.fileId
			}

			funcLine.PrintDebugMeta(f)
			body.PrintDebugMeta(f)
			Params[^].PrintDebugMeta(f)
			ResultVar?.PrintDebugMeta(f)

			f^ << "!" << GDebugFuncId << " = distinct !DISubprogram(name:\""
			PrintName(f)
			f^ << "\","
			f^ << "linkageName:\""
			PrintName(f)
			f^ << "\","
			f^ << "scope: !" << GDebugFileId << " , file: !" << GDebugFileId
			f^ << ",type: !" << GetType().MetaId
			if bdy.Line != null
			{
				f^ << ", line:" << bdy.Line.Line
				f^ << ", scopeLine:" << bdy.Line.Line
			}
			f^ << ", unit: !" << cuId
			f^ << ", flags: DIFlagPrototyped"
			f^ << ", spFlags: DISPFlagDefinition"
			//if tmplId != -1
			//	f << ", templateParams:!"<<tmplId
			f^ << ")\n"

			GDebugFileId = oldFileId
		}
	}
}

GetParSpan := !(int i) -> StringSpan
{
	buff := char[100]
	sprintf(buff[0]&,"%%par%i",i)
	result = GetConstString(buff[0]&)
}
