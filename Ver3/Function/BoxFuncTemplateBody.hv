FuncTemplateInput := class
{
	Name := StringSpan
	ItType := Type^
	IsRef := bool
	ItToken := Token^
	IsTType := bool

	this := !(StringSpan nm, Type^ typ, bool ir, Token^ tk) -> void
	{
		Name = nm
		ItType = typ
		IsRef = ir
		ItToken = tk
		if tk != null
			IsTType = ContainTemplateObj(tk)
	}
}

FuncTemplateConstant := class
{
	ItToken := Token^
	Value := BoxUnit^

	this := !(Token^ tok, BoxUnit^ val) -> void
	{
		ItToken = tok
		Value = val
	}
}

FunctionHeaderInfo := class
{
	Types := HybridQueue.{FuncTemplateInput,10}
	ResultType := FuncTemplateInput
	IsVargs := bool
}

BoxFuncTemplateBody := class extend BoxFuncTemplate
{
	Attrs := FuncAttributes

	inps1 := Token^
	resTyp := Token^
	bdy := Token^
	cns := Token^

	Name := StringSpan

	//Types := HybridQueue.{FuncTemplateInput,10}
	//ResultType := FuncTemplateInput
	//IsVargs := bool

	hData := FunctionHeaderInfo

	IsVariadic := bool
	VariadicName := StringSpan

	Constants := List.{FuncTemplateConstant}

	this := !(FuncAttributes atrs,Token^ brackets1,Token^ brackets2,Token^ constToken, Token^ resToken,Token^ bodyIn) -> void
	{
		assert(brackets2 == null)//not implemented
		Attrs = atrs
		inps1 = brackets1
		resTyp = resToken
		cns = constToken
		bdy = bodyIn
		ParseHeader()
	}
	SetName := virtual !(StringSpan name) -> void
	{
		Name = name
		if CurrentCodeSpace != null
		{
			CurrentCodeSpace.Templates[Name].Push(this&)
		}
	}
	ParseHeader := virtual !() -> void
	{
		SyntaxCompress(inps1,LexHVInputVars)
		
		if CurrentScope is in BoxClass //TODO not static,
		{
			cls := CurrentScope->{BoxClass^}
			hData.Types.Emplace(StringSpan("this"),cls.ItType,true,null)
			Attrs.IsMethod = true
		}

		bag := HybridQueue.{Token^,10}
		defer bag.Destroy()

		iter := inps1.Down

		if resTyp != null
		{
			hData.ResultType.ItType = ParseType(resTyp)
			hData.ResultType.ItToken = resTyp
		}
		checkBag := () ==> {
			if bag.Size() == 1
			{
				assert(bag[0] is TokenIndent)
				hData.Types.Emplace(bag[0]->{TokenIndent^}.Value,null,false,null)
			}else if bag.Size() >= 2 {
				if bag[1].GetValue() == "..."
				{
					assert(bag[0] is TokenIndent) //TODO
					IsVariadic = true
					VariadicName = bag[0]->{TokenIndent^}.Value
				}else{
					isRef := false
					indItm := bag[1]
					if indItm.GetValue() == "&"
					{
						isRef = true
						indItm = bag[2]
						assert(bag.Size() >= 3) //TODO
					}
					assert(indItm is TokenIndent) //TODO
					typ := ParseType(bag[0])
					name := indItm->{TokenIndent^}.Value
					if typ != null and IsComplexType(typ)
						isRef = true

					hData.Types.Emplace(name,typ,isRef,bag[0])
				}
			}else{
				assert(false)
			}
		}
		while iter != null
		{
			if iter.GetValue() == ","
			{
				checkBag()
				bag.Clear()
			}else{
				bag.Push(iter)
			}
			iter = iter.Right
		}
		if bag.Size() != 0
			checkBag()

		if cns != null
		{
			iter = cns.Down
			while iter != null
			{
				if iter.GetValue() != ","
				{
					cItm := TryGetExeCall(iter)
					Constants.Emplace(iter,cItm)
				}
				iter = iter.Right
			}
		}
	}
	ToFuncType := virtual !(CheckExeDownList objs,List.{BoxExeConstObj^} consts) -> TypeFunc^
	{
		minArgs := hData.Types.Size()
		maxArgs := hData.Types.Size()
		
		if IsVariadic
			maxArgs = 2000000 //INT_MAX
		
		if objs.Size() < minArgs or objs.Size() > maxArgs
			return null
		if consts.Size() != Constants.Size()
			return null

		fInTypes := Type^[100]
		isRefs := bool[100]

		datas := HybridQueue.{Tuple.{Type^,bool},10}

		for i : objs.Size()
		{
			datas.Emplace(objs[i].GetType(),objs[i].IsMem())
		}
		resConsts := AVLMap.{StringSpan,BoxUnit^}
		defer resConsts.Destroy()
		return checkTypes(datas,consts,resConsts)
	}
	
	CreateFunc := virtual !(TypeFunc^ tp, List.{BoxExeConstObj^} consts) -> BoxFunc^
	{
		datas := HybridQueue.{Tuple.{Type^,bool},10}

		for i : tp.Params.Size()
		{
			datas.Emplace(tp.Params[i].ItType,tp.Params[i].IsRef)
		}
		resConsts := AVLMap.{StringSpan,BoxUnit^}
		defer resConsts.Destroy()
		checkTypes(datas,consts,resConsts)


		names := HybridQueue.{StringSpan,10}
		names.Push(hData.Types[^].Name)
		newFunc := new BoxFuncBody(tp,Attrs,names,bdy)
		newFunc.VariadicName = VariadicName

		for it : resConsts
		{
			newFunc.ConstVars.Push(it)
		}

		return newFunc
	}
	checkTypes := !(HybridQueue.{Tuple.{Type^,bool},10} objs, List.{BoxExeConstObj^} consts, AVLMap.{StringSpan,BoxUnit^} resCnsts) -> TypeFunc^
	{

		fTyps := Type^[100]
		iRef := bool[100]

		for i : consts.Size()
		{
			if Constants[i].Value == null
			{
				assert(Constants[i].ItToken is TokenTemplateType)
				tmpl := Constants[i].ItToken->{TokenTemplateType^}
				name := tmpl.Value[1..0]
				if consts[i] is ConstType
				{
					resCnsts[name] = new TypeVar(name,consts[i]->{ConstType^}.Value)
				}else{
					resCnsts[name] = new ConstVar(name,consts[i])
				}
			}else{
				assert(false)
			}
		}

		for i : objs.Size()
		{
			if i >= hData.Types.Size()
			{
				assert(IsVariadic)
				fTyps[i] = objs[i].0
			}else{
				if hData.Types[i].ItToken != null
				{
					fTyps[i] = checkType(objs[i].0,hData.Types[i].ItToken,resCnsts)
				}
			}
		}


		for i : objs.Size()
		{
			if fTyps[i] == null
				return null
			if IsComplexType(fTyps[i])
				iRef[i] = true
		}
		resTypeT := hData.ResultType.ItType
		//if resTypeT == null
			resTypeT = checkType(null,hData.ResultType.ItToken,resCnsts)
		assert(resTypeT != null)
		return GetFuncType(objs.Size(),fTyps[0]&,iRef[0]&,resTypeT,hData.ResultType.IsRef,hData.IsVargs)
	}
	checkType := !(Type^ tp,Token^ tk, AVLMap.{StringSpan,BoxUnit^} resCnsts) -> Type^
	{
		if tk is TokenTemplateType
		{
			nm := tk->{TokenTemplateType^}.Value[1..0]
			//TODO: resConsts.Push()
			assert(tp != null)
			if resCnsts.Contain(nm)
			{
				if resCnsts[nm] is TypeVar
				{
					vr := resCnsts[nm]->{TypeVar^}
					if vr.Value != tp
					{
						assert(false)
					}
				}
			}else{
				resCnsts[nm] = new TypeVar(nm,tp)
			}
			return tp
		}
		if tk is TokenIndent
		{
			dwnTp := ParseType(tk)
			if dwnTp == null
			{
				name := tk->{TokenIndent^}.Value
				if resCnsts.Contain(name)
				{
					itm2 := resCnsts[name]
					if itm2 is TypeVar
					{
						dwnTp = itm2->{TypeVar^}.Value
					}
				}
			}
			if dwnTp == null
				return null
			if tp != null and tp != dwnTp
				return null
			return dwnTp
		}
		if tk.Down?.Right?.GetValue() == "^"
		{
			nxtType := Type^
			if tp != null
			{
				if not (tp is in TypePoint)
					return null
				nxtType = tp.Base
			}
			resTyp2 := checkType(nxtType,tk.Down,resCnsts)
			if resTyp2 == null
				return null
			return resTyp2.GetPoint()
		}
		assert(false)
		return null
	}

	IsOneFunc := virtual !() -> bool
	{
		if IsVariadic
			return false
		for it : hData.Types
		{
			if it.ItType == null
				return false
		}
		if hData.ResultType.ItType == null //todo? functions with auto return type
			return false
		if Constants[^].Value == null
			return false
		return true
	}
	GetOneFunc := virtual !() -> BoxFunc^
	{
		fTyp := Type^[100]
		isRef := bool[100]
		for it,i : hData.Types
		{
			fTyp[i] = it.ItType
			isRef[i] = it.IsRef
		}

		resFuncTyp := GetFuncType(hData.Types.Size(),fTyp[0]&,isRef[0]&,hData.ResultType.ItType,hData.ResultType.IsRef,hData.IsVargs)

		names := HybridQueue.{StringSpan,10}
		names.Push(hData.Types[^].Name)
		return new BoxFuncBody(resFuncTyp,Attrs,names,bdy)
	}

}
