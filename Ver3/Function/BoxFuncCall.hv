globalIdIter := 0
GetNewId := !() -> int
{
	globalIdIter += 1
	return globalIdIter
}

BoxFuncCall := class extend BoxExeObj
{
	callObj := BoxFunc^
	downs := ExeDownList
	resId := int
	this := !(BoxFunc^ fnc, CheckExeDownList objs) -> void
	{
		callObj = fnc

		if callObj is BoxFuncBody
			callObj->{BoxFuncBody^}.ParseBody()

		CheckInputs(fnc.GetType()->{TypeFunc^},objs)
	}
	CheckInputs := !(TypeFunc^ fType, CheckExeDownList objs) -> void
	{
		itType := NormalizeFuncType(fType)

		if fType.ResultType.IsComplexReturn() and not fType.ResultRef
		{
			resVar := CreateVar(fType.ResultType,false)
			emptyDwn := CheckExeDownList
			downs.Push(new BoxFuncCall(resVar,emptyDwn))

			this&->SetType(BoxFuncComplexCall)
		}

		downs.Push(objs[^])
		resId = GetNewId()

		for par,i : itType.Params
		{
			if par.IsRef
			{
				downs[i].NotifyMemUse()
			}
		}

		for par,i : itType.Params
		{
			assert( i < downs.Size())
			if downs[i].GetType() != par.ItType
			{
				newObj := GetExchange(downs[i],par.ItType)
				if newObj == null
				{
					tmpl := TEchoStream
					tmpl << "Could not exchange type from "
					downs[i].GetType().PrintDebugName(tmpl&)
					tmpl << " to "
					par.ItType.PrintDebugName(tmpl&)
					printf("%s\n",tmpl.Str()) //TODO
					throw new Exception(tmpl.Str())
				}
				assert(newObj != null)

				while newObj.GetType() != par.ItType
				{
					newObj = GetExchange(newObj,par.ItType) //TODO limit to some value
					assert(newObj != null)
				}
				downs[i] = newObj
			}
		}
	}
	NotifyMemUse := virtual !() -> void
	{
		callObj.NotifyMemUse()
	}
	GetType := virtual !() -> Type^
	{
		return callObj.GetType()->{TypeFunc^}.ResultType
	}

	IsMem := virtual !() -> bool
	{
		return callObj.IsMem()
	}
	PrintFuncUse := virtual !(TIOStream^ f) -> void
	{
		callObj.PrintFuncCall(f,resId,0,downs)
	}
	PrintFuncResult := virtual !(TIOStream^ f) -> void
	{
		callObj.PrintResultObj(f,resId,-1)
	}
	PrintPointPre := virtual !(TIOStream^ f) -> void
	{
		PrintFuncUse(f)
	}
	PrintPointUse := virtual !(TIOStream^ f) -> void
	{
		PrintFuncResult(f)
	}
	PrintPre := virtual !(TIOStream^ f) -> void //TODO remove copy of code
	{
		if IsMem()
		{
			rType := GetType()

			PrintPointPre(f)
			f^ << "%TUnref" << resId << " = load "
			rType.PrintType(f)
			f^ << ","
			rType.PrintType(f)
			f^ << "* "
			PrintPointUse(f)
			if DebugMode
				f^ << ", !dgb !" << GDebugLineCallId
			f^ << "\n"
		}else{
			PrintFuncUse(f)
		}
	}
	PrintUse := virtual !(TIOStream^ f) -> void
	{
		if IsMem()
		{
			f^ << "%TUnref" << resId
		}else{
			PrintFuncResult(f)
		}
	}
}
BoxFuncComplexCall := class extend BoxFuncCall
{
	IsMem := virtual !() -> bool
	{
		return true //TODO if return ref
	}
	PrintPointUse := virtual !(TIOStream^ f) -> void
	{
		downs[0].PrintPointUse(f)
	}
}
BoxFuncPointerCall := class extend BoxFuncCall
{
	ItPtrFunc := BoxExeObj^
	this := !(BoxExeObj^ ptrVal, CheckExeDownList objs) -> void
	{
		ItPtrFunc = ptrVal
		CheckInputs(ptrVal.GetType().Base->{TypeFunc^},objs)
	}
	GetType := virtual !() -> Type^
	{
		ft := ItPtrFunc.GetType().Base->{TypeFunc^}
		return ft.ResultType
	}
	PrintFuncUse := virtual !(TIOStream^ f) -> void
	{
		PrintFuncCallCommon(f,ItPtrFunc,resId,downs)
	}
	PrintFuncResult := virtual !(TIOStream^ f) -> void
	{
		PrintFuncCallResultCommon(f,ItPtrFunc.GetType().Base->{TypeFunc^},resId)
	}
	NotifyMemUse := virtual !() -> void
	{
	}
	IsMem := virtual !() -> bool
	{
		return false //TODO if return ref
	}
}
