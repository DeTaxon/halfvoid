globalIdIter := 0
GetNewId := !() -> int
{
	globalIdIter += 1
	return globalIdIter
}

BoxFuncCall := class extend BoxExeObj
{
	callObj := BoxFunc^
	downs := ExeDownList
	resId := int

	ResultVar := ParamFunc^
	ExtraWork := List.{BoxExeObj^}

	this := !(BoxFunc^ fnc) -> void
	{
		callObj = fnc
		assert(callObj != null)

		if callObj is BoxFuncBody
			callObj->{BoxFuncBody^}.ParseBody()

		empty := CheckExeDownList
		CheckInputs(fnc.GetType()->{TypeFunc^},fnc,empty)
	}
	this := !(BoxFunc^ fnc, CheckExeDownList objs) -> void
	{
		callObj = fnc
		assert(callObj != null)

		if callObj is BoxFuncBody
			callObj->{BoxFuncBody^}.ParseBody()

		CheckInputs(fnc.GetType()->{TypeFunc^},fnc,objs)
	}
	CheckInputs := !(TypeFunc^ fType,BoxFunc^ fnc, CheckExeDownList objs) -> void
	{
		itType := NormalizeFuncType(fType)

		if fType.ResultType.IsComplexReturn() and not fType.ResultRef
		{
			ResultVar = CreateVar(fType.ResultType,false)
			downs.Push(new BoxFuncCall(ResultVar))

			if this& is BoxFuncCall
			{
				this&->SetType(BoxFuncComplexCall)
			}else if this& is BoxFuncPointerCall {
				this&->SetType(BoxFuncPointerComplexCall)
			}else{
				assert(false)
			}
		}

		downs.Push(objs[^])
		resId = GetNewId()

		for par,i : itType.Params
		{
			if i >= downs.Size()
				break
			if par.IsRef
			{
				downs[i].NotifyMemUse()
			}
		}

		for par,i : itType.Params
		{
			if i >= downs.Size()
			{
				assert(fnc != null)
				defToken := fnc.GetDefaultToken(i)
				assert(defToken != null) //todo, emit error

				if defToken.GetValue() == "static"
				{
					assert(par.IsRef)
					glVar := CreateGlobalVar(StringSpan("anon"),par.ItType,false)
					varCall := new BoxFuncCall(glVar)
					downs.Push(varCall)
					defToken = defToken.Right
				}else{
					newCall := TryGetExeCall(defToken)
					assert(newCall != null) //todo, emit error
					downs.Push(newCall)
				}
				
				continue
			}
			if downs[i].GetType() != par.ItType
			{
				newObj := GetExchange(downs[i],par.ItType)
				if newObj == null
				{
					tmpl := TEchoStream
					tmpl << "Could not exchange type from "
					downs[i].GetType().PrintDebugName(tmpl&)
					tmpl << " to "
					par.ItType.PrintDebugName(tmpl&)
					printf("%s\n",tmpl.Str()) //TODO
					throw new Exception(tmpl.Str())
				}
				assert(newObj != null)

				while newObj.GetType() != par.ItType
				{
					newObj = GetExchange(newObj,par.ItType) //TODO limit to some value
					assert(newObj != null)
				}
				downs[i] = newObj
			}
		}
		if downs.Size() > itType.Params.Size()
		{
			assert(fType.IsVargs)

			for i : downs.Size()
			{
				if i < fType.Params.Size()
					continue
				if downs[i].GetType() == GTypeFloat
				{
					downs[i] = GetExchange(downs[i],GTypeDouble)
				}
			}
		}

		if ResultVar != null and fType.ResultType is TypeClass
		{
			ModifyStackAllocatedVar(ResultVar,ExtraWork)
		}
	}
	NotifyMemUse := virtual !() -> void
	{
		callObj.NotifyMemUse()
	}
	GetType := virtual !() -> Type^
	{
		assert(callObj != null)
		return callObj.GetType()->{TypeFunc^}.ResultType
	}

	IsMem := virtual !() -> bool
	{
		return callObj.IsMem()
	}

	PassedFuncCall := !(TIOStream^ f, int passedId)  -> void
	{
		callObj.PrintFuncCall(f,passedId,0,downs)
	}
	PassedFuncResult := !(TIOStream^ f, int passedId)  -> void
	{
		callObj.PrintResultObj(f,passedId,-1)
	}

	PrintFuncUse := virtual !(TIOStream^ f) -> void
	{
		callObj.PrintFuncCall(f,resId,0,downs)
		ExtraWork[^].PrintDefaultUse(f)
	}
	PrintFuncResult := virtual !(TIOStream^ f) -> void
	{
		callObj.PrintResultObj(f,resId,-1)
	}
	PrintPointPre := virtual !(TIOStream^ f) -> void
	{
		PrintFuncUse(f)
	}
	PrintPointUse := virtual !(TIOStream^ f) -> void
	{
		PrintFuncResult(f)
	}
	PrintPre := virtual !(TIOStream^ f) -> void //TODO remove copy of code
	{
		if IsMem()
		{
			PrintUnrefObj(f,resId,this&)
		}else{
			PrintFuncUse(f)
		}
	}
	PrintUse := virtual !(TIOStream^ f) -> void
	{
		if IsMem()
		{
			f^ << "%TUnref" << resId
		}else{
			PrintFuncResult(f)
		}
	}
}
BoxFuncComplexCall := class extend BoxFuncCall
{
	IsMem := virtual !() -> bool
	{
		return true //TODO if return ref
	}
	PrintPointUse := virtual !(TIOStream^ f) -> void
	{
		downs[0].PrintPointUse(f)
	}
}
BoxFuncPointerCall := class extend BoxFuncCall
{
	ItPtrFunc := BoxExeObj^
	this := !(BoxExeObj^ ptrVal, CheckExeDownList objs) -> void
	{
		ItPtrFunc = ptrVal
		CheckInputs(ptrVal.GetType().Base->{TypeFunc^},null,objs)
	}
	GetType := virtual !() -> Type^
	{
		ft := ItPtrFunc.GetType().Base->{TypeFunc^}
		return ft.ResultType
	}
	PrintFuncUse := virtual !(TIOStream^ f) -> void
	{
		PrintFuncCallCommon(f,ItPtrFunc,resId,downs)
	}
	PrintFuncResult := virtual !(TIOStream^ f) -> void
	{
		PrintFuncCallResultCommon(f,ItPtrFunc.GetType().Base->{TypeFunc^},resId)
	}
	NotifyMemUse := virtual !() -> void
	{
	}
	IsMem := virtual !() -> bool
	{
		return false //TODO if return ref
	}
}
BoxFuncPointerComplexCall := class extend BoxFuncPointerCall
{
	IsMem := virtual !() -> bool
	{
		return true //TODO if return ref
	}
	PrintPointUse := virtual !(TIOStream^ f) -> void
	{
		downs[0].PrintPointUse(f)
	}
}
