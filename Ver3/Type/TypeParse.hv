GetTypeFromIndent := !(Token^ obj,AVLMap.{StringSpan,BoxUnit^}^ resCnsts) -> Type^
{
	assert(obj is TokenIndent)

	asIndent := obj->{TokenIndent^}
	name := asIndent.Value

	if resCnsts?.Contain(name)
	{
		itm := resCnsts^[name]
		if itm is TypeVar
		{
			vr := itm->{TypeVar^}
			return vr.Value
		}
		if itm is ConstType
		{
			vr := itm->{ConstType^}
			return vr.Value
		}
	}

	for defs : DefsTable
	{
		if defs == null
			break
		if defs.ItName == asIndent.Value
			return defs.ItType
	}
	checkRes := TypeGetGlobalByIndent(name)
	if checkRes == null
		return null

	if  checkRes is TypeVar
	{
		return checkRes->{TypeVar^}.Value
	}
	if checkRes is in GlobalVar
		return null
	if checkRes is ConstType
		return checkRes->{ConstType^}.Value
	if checkRes is in BoxFunc
		return null
	if checkRes is in BoxFuncTemplate
		return null
	if checkRes is BoxExeInt
		return null
	if checkRes is TypedefTemplateVar
	{
		tmplVar := checkRes->{TypedefTemplateVar^}
		cnsts6 := List.{BoxExeConstObj^}
		return tmplVar.Value.GetType(cnsts6)
	}
	if checkRes is TaskLocalVarDelayed
		return null
	if checkRes is TemplateTypeVar
	{
		obj.EmitError("Got object, but dont know what it is, software error")
		assert(false)
		return null
	}
	if checkRes != null
	{
		printf("hmm %s\n",name)
		obj.EmitError("Got object, but dont know what it is, software error")
	}
	assert(checkRes == null)
	return null
}

ParseType := !(Token^ obj) -> Type^
{
	if obj == null
		return null

	someMap := AVLMap.{StringSpan,BoxUnit^}
	defer someMap.Destroy()
	return CheckTemplateType(null,obj,someMap)

	//if obj.Down?.Right?.Right?.GetValue() == "{}"
	//	and obj.Down.Right.GetValue() == "."
	//	and obj.Down is TokenIndent
	//{
	//	name := obj.Down->{TokenIndent^}.Value
	//	cnsts := List.{BoxExeConstObj^}
	//	CheckFuncCallConsts(obj.Down.Right.Right,cnsts)

	//	checkRes := TypeGetGlobalByIndent(name)
	//	if checkRes != null and checkRes is TemplateTypeVar
	//	{
	//		asClass := checkRes->{TemplateTypeVar^}.Value.GetClass(cnsts)
	//		return asClass.ItType
	//	}
	//	return null
	//}
	//if obj is TokenIndent
	//{
	//	return 
	//}
	//if obj.GetValue() == "~d"
	//{
	//	if obj.Down.GetValue() == "!" and obj.Down.Right.Right.GetValue() == "^"
	//	{
	//		k := 0
	//		types := Type^[100]
	//		isRef := bool[100]
	//		isVargs := false

	//		iter := obj.Down.Right.Down
	//		while iter != null
	//		{
	//			if iter.GetValue() != ","
	//			{
	//				if iter.GetValue() == "..."
	//				{
	//					isVargs = true
	//				}else{
	//					types[k] = ParseType(iter)
	//					if types[k] == null
	//						return null
	//					//isRef[k] = IsComplexType(types[k])
	//					k += 1
	//				}
	//			}
	//			iter = iter.Right
	//		}
	//		ptrVal := 0
	//		ptrMod := obj.Down.Right.Right
	//		while ptrMod.GetValue() == "^"
	//		{
	//			ptrVal += 1
	//			ptrMod = ptrMod.Right
	//		}
	//		if ptrMod.GetValue() != "->"
	//			return null
	//		if ptrMod.Right == null
	//			return null
	//		resType := ParseType(ptrMod.Right)
	//		if resType == null
	//			return null

	//		fType := GetFuncType(k,types[0]&,isRef[0]&,resType,false,isVargs)->{Type^}
	//		if fType == null
	//			return null
	//		for ptrVal
	//			fType = fType.GetPoint()
	//		return fType
	//	}
	//	if obj.Down.Right?.GetValue() == "^"
	//	{
	//		dTyp := ParseType(obj.Down)
	//		if dTyp != null
	//			return dTyp.GetPoint()
	//	}
	//}
}

TypeGetGlobalByIndent := !(StringSpan name) -> BoxUnit^
{
		for it : UnitStack
		{
			if it is TypeVar
			{
				tv := it->{TypeVar^}
				if tv.Name == name
					return it
			}
			if it is ConstVar
			{
				tv := it->{ConstVar^}
				if tv.Name == name
					return it
			}
		}
		for spc : CodeSpaces
		{
			if spc.Globals.Contain(name)
			{
				for glb : spc.Globals[name]
				{
					return glb
				}
			}
			for lb : spc.Modules
			{
				return lb.GetItem(name)?
			}
		}
}
