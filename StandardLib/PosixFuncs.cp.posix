
O_RDONLY := 0
O_WRONLY := 1
O_RDWR := 2

O_APPEND := 1024
O_CREAT := 64
O_EXCL := 128
O_TRUNC := 512
O_TMPFILE := 4259840

PROT_READ := 1
PROT_WRITE := 2
PROT_NONE := 0

MAP_SHARED := 1
MAP_PRIVATE := 2
MAP_ANON := 32

sem_t := class
{
	sAlign := s64
	sFields := char[24]
}

posixGetFileSize := !(int fd,u64^ size) -> bool
{
	dataD := char[144]
	val := fstat(fd,dataD->{char^})
	if val == -1 return false
	asNeed1 := dataD->{char^}[48]&
	asNeed2 := asNeed1->{u64^}
	size^ = asNeed2^
	return true
}

getErrnoInit := bool
initedErrno := bool
getErrnoFunc := !()^->int^
GetErrno := !() -> int
{
	return getErrnoFunc()^
}
TryInitErrno := !() -> bool
{
	if getErrnoInit
		return initedErrno
	try
	{
		lib := Library("libc.so.6")
		getErrnoFunc = lib.Get("__errno_location")->{!()^->int^}
		initedErrno = true
	}catch(IException^ e)
	{
		printf("test %s\n",e.Msg())
	}
	return initedErrno
}

OpenLib := !(char^ fileName) ->void^
{
	return dlopen(fileName,2)
}
LoadFuncLib := !(void^ libId, char^ funcName) -> void^
{
	return dlsym(libId,funcName)
}
CloseLib := !(void^ libId) -> void
{
	dlclose(libId)
}

TSleep := !(double timeSleep) -> void
{
	if CurrentTaskBox != null
	{
		CurrentTaskBox.ASleep(timeSleep)
		return void
	}
	tmStruct := u64[2]
	tmStruct[0] = timeSleep->{int}
	timeSleep -= tmStruct[0]->{int}
	tmStruct[1] = (timeSleep*1000000000.0)->{int}
	if tmStruct[1] >= 999999999
		tmStruct[1] = 999999999
	nanosleep(tmStruct[0]&,null)
}
TGetSteadyTime := !() -> double
{
	times := u64[2]
	clock_gettime(1,times[0]&)
	resTime := times[0]->{double}
	return resTime + times[1]*0.001*0.001*0.001
}

TCreateDir := !(char^ pth) -> void
{
	if mkdir(pth,511) != 0
		throw new Exception("Can not create directory")
}

c_long := type s64
