
ConvertThreadToFiber := !(void^ fbr) -> void^ declare
SwitchToFiber := !(void^ fbr) -> void declare 
CreateFiber := !(size_t stackSize,!(void^)^->void fiberFunc,void^ fiberValue) -> void^ declare
DeleteFiber := !(void^ fbr) -> void declare

CreateEventA := !(void^ security,int manualReset,int bInitState,char^ pName) -> void^ declare
SetEvent := !(void^ evnt) -> int declare
ResetEvent := !(void^ evnt) -> int declare
WaitForMultipleObjects := !(u32 nCount,void^ handlers,int waitAll,u32 millicenodsTimeout) -> int declare
WAIT_OBJECT_0 := 0
WAIT_ABANDONED_0 := 0x80
WAIT_TIMEOUT := 0x102
//wait failed 0xfffffff

FILE_ACTION_ADDED := 1
FILE_ACTION_REMOVED := 2
FILE_ACTION_MODIFIED := 3
FILE_ACTION_RENAMED_OLD_NAME := 4
FILE_ACTION_RENAMED_NEW_NAME := 5

FILE_NOTIFY_CHANGE_FILE_NAME := 0x1
FILE_NOTIFY_CHANGE_LAST_ACCESS := 0x20
FILE_NOTIFY_CHANGE_CREATE := 0x40

FILE_NOTIFY_INFORMATION := class
{
	NextEntryOffset := int
	Action := int
	FileNameLength := int
	//FileName := char[FileNameLength]
}

FILE_ACTION_ADDED := 1
FILE_ACTION_REMOVED := 2
FILE_ACTION_MODIFIED := 3

GetOverlappedResult := !(void^ hndl,void^ over,int^ red,int wait) -> int declare

monitorStruct := class
{
	hndl := void^
	buffer := int[1024]
	lap := OVERLAPPED
	recursive := int
	modes := int

	callb := MonitorCallback
}

AppendClass TaskData
{
	fiber := void^
}

AppendClass TaskBox
{
	startContext := void^
	eventHandle := void^
	winPollArr := RawArray.{void^}

	osInit := !() -> void
	{
		startContext = ConvertThreadToFiber(null)

		winPollArr."this"()
		winPollArr.Reserve(10)

		eventHandle = CreateEventA(null,0,0,null->{u8^})
		winPollArr.Create() = eventHandle
		//pollData.Create().0 = 1
	}
	initedM := bool
	monitorEv := void^
	monNr := 0

	monObjects := AVLSet.{monitorStruct^}
	initMonitor := !() -> void
	{
		if initedM return void
		initedM = true

		monitorEv = CreateEventA(null,0,0,null->{u8^})
		monNr = winPollArr.Size()
		winPollArr.Create() = monitorEv
	}
	addMonitor := !(char^ pathName,MonitorCallback callb,int modes,bool isRec) -> void^
	{
		initMonitor()
		
		strc := new monitorStruct
		strc.lap.event = monitorEv
		strc.callb = callb.Capture()
		strc.recursive = isRec ?: 1 : 0

		strc.modes = 0
		if (modes and_b M_CREATED) != 0 strc.modes = strc.modes or_b FILE_NOTIFY_CHANGE_CREATE
		if (modes and_b M_CHANGED) != 0 strc.modes = strc.modes or_b FILE_NOTIFY_CHANGE_LAST_ACCESS
		if (modes and_b M_CREATED) != 0 strc.modes = strc.modes or_b FILE_NOTIFY_CHANGE_FILE_NAME

		strc.hndl = CreateFileW(Utf8ToUtf16(pathName),GENERIC_READ ,FILE_SHARE_READ or_b FILE_SHARE_WRITE or_b FILE_SHARE_DELETE, null,OPEN_EXISTING
		,FILE_FLAG_BACKUP_SEMANTICS or_b FILE_FLAG_OVERLAPPED,null)
		monObjects.Insert(strc)
		doMonitor(strc)

		return strc
	}
	checkMonitor := !() -> void
	{
		for it : monObjects
		{
			red := 0
			if GetOverlappedResult(it.hndl,it.lap&,red&,0)
			{
				flInf := it.buffer[0]&->{FILE_NOTIFY_INFORMATION^}
				while true
				{
					fName := flInf->{u8^}[FILE_NOTIFY_INFORMATION->TypeSize]&->{u16^}
					flName :=  Utf16ToUtf8(fName,flInf.FileNameLength div 2)
					itLambd := it.callb
					itLambd(""sbt + flName,flInf.Action)
					if flInf.NextEntryOffset == 0
						break
					flInf = flInf->{u8^}[flInf.NextEntryOffset]&->{FILE_NOTIFY_INFORMATION^}
				}
				doMonitor(it)
			}
		}
	}
	waitOnMonitor := !() -> bool
	{
		return monObjects.Size() != 0
	}
	doMonitor := !(monitorStruct^ strc) -> void
	{
		//ZeroMem(strc.lap)
		strc.lap.internal = 0
		strc.lap.offset = 0
		strc.lap.event = monitorEv
		res := ReadDirectoryChangesW(strc.hndl,strc.buffer[0]&,strc.buffer->len*4,strc.recursive
		,strc.modes,null,strc.lap&,null)
	}
	notifyMain := !() -> void
	{
		SetEvent(eventHandle)
	}
	osCreateTask := !(TaskData^ startTask) -> void
	{
	      startTask.fiber = CreateFiber(stackSize->{s64},ucontextStartTask,null)
	}
	taskWaitSleep := !(double sleepTime) -> void
	{
		res := WaitForMultipleObjects(winPollArr.Size(),winPollArr.Data(),0,(sleepTime*1000)->{int})
		if res in 0..64
		{
			if res == monNr
			{
				ResetEvent(monitorEv)
				checkMonitor()
			}
		}
	}
	osSwitchToMain := !() -> void
	{
		SwitchToFiber(startContext)
	}
	osDoTask := !(TaskData^ toRun) -> void
	{
		SwitchToFiber(toRun.fiber)
	}
}
