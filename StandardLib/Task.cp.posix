
getcontext := !(void^ a) -> int declare
setcontext := !(void^ a) -> int declare
makecontext := !(void^ a,!()^->void  b,int argc,...) -> int declare
swapcontext := !(void^ begin, void^ end) -> int declare

eventfd := !(u64 initVal,int flags) -> int declare

inotify_init := !() -> int declare
inotify_add_watch := !(int fd,char^ pat,int mask) -> int declare

pollfd := class 
{
	fd := int
	events := u16
	revents := u16
}
poll := !(void^ pols, int count,int timeout) -> int declare

IN_CHANGE := 2
IN_CLOSE_WRITE := 8
IN_CREATE := 256 
IN_DELETE := 512

inotify_event := class
{
	wd := int
	mask := u32
	cookie := u32
	len := u32
	name := u8[1]
}

AppendClass TaskBox
{
	eventFd := int
	posixPollArr := RawArray.{pollfd}

	pollData := RawArray.{Tuple.{int}}

	startContext := u8[1024]

	osInit := !() -> void
	{
		pollData."this"()
		pollData.Reserve(10)

		posixPollArr."this"()
		posixPollArr.Reserve(10)

		eventFd = eventfd(0,0)
		setPollFd := ref posixPollArr.Create()
		setPollFd.fd = eventFd
		setPollFd.events = 0x01
		pollData.Create().0 = 1
	}
	initedMonitor := bool
	monitorBuffer := u8[]
	monitorFd := int
	monitorWds := AVLMap.{int,Tuple.{MonitorCallback,char^,int}}
	initMonitor := !() -> void
	{
		initedMonitor = true
		pollData.Create().0 = 2

		monitorBuffer = new u8[4096]
		monitorFd = inotify_init()
		setData := ref posixPollArr.Create()
		setData.fd = monitorFd
		setData.events = 0x01
		newPoll := ref pollData.Create()
		newPoll.0 = 2
	}
	checkMonitor := !() -> void
	{
		readRes := read(monitorFd,monitorBuffer->{void^},4096)
		if readRes > 0
		{
			asStruct := monitorBuffer->{inotify_event^}
			if monitorWds.Contain(asStruct.wd)
			{
				nowMon := ref monitorWds[asStruct.wd]
				itLambd := nowMon.0
				newName := (""sbt + nowMon.1 + "/" + asStruct.name[0]&)->{char^}
				if (asStruct.mask and_b nowMon.2 ) != 0
				{
					newMode := 0
					if (asStruct.mask and_b IN_CHANGE) != 0 newMode += M_CHANGED
					if (asStruct.mask and_b IN_CREATE) != 0 newMode += M_CREATED
					if (asStruct.mask and_b IN_DELETE) != 0 newMode += M_DELETED
					itLambd(newName,newMode)
				}
			}
		}
	}
	addMonitor := !(char^ pathName,MonitorCallback callb,int modes,bool isRec) -> void
	{
		if not initedMonitor 
			initMonitor()

		pathAdd := List.{char^}() ; $temp $keep


		watchMode := 0
		if modes and_b M_CHANGED watchMode += IN_CHANGE
		if modes and_b M_CREATED watchMode += IN_CREATE
		if modes and_b M_DELETED watchMode += IN_DELETE

		pathAdd << pathName

		while pathAdd.Size() != 0
		{	
			nowPath := pathAdd.Pop()

			wd := inotify_add_watch(monitorFd,nowPath,watchMode)
			if wd >= 0
			{
				setWds := ref monitorWds[wd]
				setWds.0 = callb
				setWds.1 = StrCopy(nowPath)
				setWds.2 = watchMode
				if isRec
				{
					for subFolder : Path(nowPath)
					{
						if not subFolder.IsFolder() 
							continue
						strBld := ""sbt + nowPath + "/" + subFolder.Name()
						str := strBld.Str() ; $temp
						pathAdd << str
					}
				}
			}
		}
	}
	notifyMain := !() -> void
	{
		toWrite := u64
		toWrite = 1
		write(eventFd,toWrite&,8)
	}
	osCreateTask := !(TaskData^ startTask) -> void
	{
		getcontext(startTask.uContext[0]&)
		startTask.stackPtr = malloc(stackSize)
		startTask.uContext[24]&->{u64^}^ = 0
		startTask.uContext[8]&->{void^^}^ = null
		startTask.uContext[16]&->{void^^}^ = startTask.stackPtr
		startTask.uContext[32]&->{u64^}^ = stackSize
		makecontext(startTask.uContext&,ucontextStartTask,0)
	}
	taskWaitSleep := !(double sleepTime) -> void
	{
		poll(posixPollArr.Data(),posixPollArr.Size(),(sleepTime*1000)->{int})
		for itFd,i : posixPollArr, extra : pollData
		{
			if itFd.revents != 0
			{
				switch extra.0
				{
					case 1
						toRd := u64
						read(eventFd,toRd&,8)
					case 2
						checkMonitor()
				}
			}
		}
	}
	osSwitchToMain := !() -> void
	{
		swapcontext(CurrentTask.uContext&,startContext)
	}
	osDoTask := !(TaskData^ toRun) -> void
	{
		swapcontext(startContext&,toRun.uContext&)
	}
}
