
clA := class
{
	x := int
	y := char
}
clB := class extend clA
{
	z := char
}

VirtClass := class
{
	x := virtual !() -> int
	{
		return 17
	}
}
subVirtClass := class
{
	y := VirtClass
	z := VirtClass[4]
}
subVirtClassInh := class extend subVirtClass
{
	w := VirtClass
}

globalVClass := VirtClass
globalVClass2 := VirtClass[2]
globalVClass3 := subVirtClass
globalVClass4 := subVirtClassInh


NonVirtualClass := class
{
	x := int
	Res := !() -> int
	{
		return x
	}
	Res2 := !(int someVal) -> int
	{
		assert(someVal == 9973)
		return x
	}
}
SomeVirtualClass := class extend NonVirtualClass
{
	Test := virtual !() -> void
	{
		x = 16
		assert(Res() == x)
		assert(Res2(9973) == x)
	}
}

MixinObject1 := class
{
	x := int
	Contain := poison !(!(int)&-> bool l) -> bool
	{
		if l(this[^])
			return true
		return false
	}
}
EmptyMixin := class
{
	Hi := !() -> void
	{
		printf("Hi\n")
	}
}
MixinObject2 := class
{
	y := int
	GetY := !() -> int
	{
		return y
	}
	Test := poison !() -> void
	{
		printf("hello\n")
	}
}

TestClass := class extend MixinObject1 , EmptyMixin, MixinObject2
{
	z := int
	"~For" := !() -> !()&->int
	{
		return () ==>
		{
			for it : ![1,12,100,-3,16]
				yield it			
		}
	}
	ReGetY := !() -> int
	{
		return GetY()
	}
}


packedClass1 := packed_class
{
	x := int
	y := u8
	z := int
}
TestClassParams := !() -> void
{
	assert(packedClass1->TypeSize == 9)

	bugTest1 := SomeVirtualClass
	bugTest1.Test()
	assert(bugTest1.Res() == bugTest1.x)
	assert(bugTest1.Res2(9973) == bugTest1.x)
	
	globalVClass.x()
	globalVClass2[0].x()
	globalVClass3.y.x()
	globalVClass3.z[1].x()
	globalVClass4.z[3].x()



	assert(clB->TypeSize == 12)

	obj := clB

	for it,ind : obj->Fields
	{
		offset := it&->{void^}->{size_t} - obj&->{void^}->{size_t}
		switch ind
		{
			case "x" assert(offset == 0)
			case "y" assert(offset == 4)
			case "z" assert(offset == 8)
		}
	} 
	assert(subVirtClassInh->TypeSize == 48)

	c := TestClass
	c.x = 3
	c.y = 4
	c.z = 5
	offset_x := c.x&->{void^}->{size_t} - c&->{void^}->{size_t}
	assert(offset_x == 0)
	offset_y := c.y&->{void^}->{size_t} - c&->{void^}->{size_t}
	assert(offset_y == 4)
	offset_z := c.z&->{void^}->{size_t} - c&->{void^}->{size_t}
	assert(offset_z == 8)
	
	sum := 0
	for it,ind : c->Fields
	{
		sum += it
	}
	assert(sum == 12)
	
	assert(c.ReGetY() == c.y)
	assert(c.GetY() == c.y)

}
