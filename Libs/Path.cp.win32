DirectoryIterator2 := class
{
	hndl := void^
	nowEntry := WIN32_FIND_DATAW
	nowPath := Path
	buff := char^
	offst := char^
	isItEnd := bool
	leftToSet := int
	this := !(char^ tu, bool isWildcard) -> void
	{
		buff = new char[1024] ; $temp
		strL := strlen(tu)

		buff[u] = tu[^u]
		buff[strL] = 0

		if isWildcard
		{
			while strL >= 0 and not buff[strL] in "/\\"
				strL--
			strL++
			offst = buff[strL]&
			leftToSet =  1024 - strL - 1
			
		}else{
			if buff[strL-1] == '/'
			{
				buff[strL] = '*'
				buff[strL+1] = 0
				offst = buff[strL]&
				leftToSet = 1024 - strL - 2
			}else{
				buff[strL] = '/'
				buff[strL+1] = '*'
				buff[strL+2] = 0
				offst = buff[strL+1]&
				leftToSet = 1024 - strL - 3
			}
		}

		hndl = FindFirstFileW(Utf8ToUtf16(buff),nowEntry&)
		if hndl&->{u64^}^ == not_b 0U
		{
			throw new Exception(199,"folder not found")
		}
		putNameToBuff()
		while (offst == "." or offst == "..") and not isItEnd
			Inc()
		nowPath.itStr = buff
	}
	putNameToBuff := !() -> void
	{
		setted := WideCharToMultiByte(CP_UTF8,WC_COMPOSITECHECK,nowEntry.cFileName,-1,offst,leftToSet,null,null)
		offst[setted] = 0
	}
	"^" := !() -> ref Path
	{
		return nowPath
	}
	Inc := !() -> void
	{
		isItEnd = not FindNextFileW(hndl,nowEntry&)
		if not isItEnd
		{
			putNameToBuff()
		}else{
			FindClose(hndl)
		}
	}
	IsEnd := !() -> bool
	{
		return isItEnd
	}
}


Path := class
{
	itStr := string
	this := !() -> void
	{
		itStr = null
	}
	this := !(string st) -> void
	{
		itStr = st
	}
	this := !(Path st) -> void
	{
		itStr = st.itStr
	}
	Get := !() -> char^
	{
		return itStr
	}
	"==" := !(Path pt2) -> bool
	{
		idX := GetId()
		idY := pt2.GetId()
		if idX == 0 return false
		return idX == idY
	}
	IsExist := !() -> bool
	{
		return GetId() != 0
	}

	FullPath := !() -> Path
	{
		asW := Utf8ToUtf16(itStr)
		preRetW := new u16[MAX_PATH] ; $temp
		retSize := GetFullPathNameW(asW,MAX_PATH,preRetW,null)
		preRetW[retSize] = 0
		return Path(Utf16ToUtf8(preRetW))
	}
	"~For" := !() -> DirectoryIterator2
	{
		return DirectoryIterator2(itStr,false)
	}
	IsFolder := !() -> bool
	{
		asW := Utf8ToUtf16(itStr)
		return (GetFileAttributesW(asW) and_b FILE_ATTRIBUTE_DIRECTORY) != 0
	}
	"=" := !(Path pt) -> void
	{
		itStr = pt.itStr
	}
	"=" := !(string pt) -> void
	{
		itStr = pt
	}
	"/=" := !(string str) -> void
	{
		itStr = itStr + "/" + str
	}
	"/" := !(string pt2) -> Path
	{
		ToRet.itStr = this.itStr + "/" + pt2
	}
	"/" := !(Path pt2) -> Path
	{
		return Path(itStr + "/" + pt2.itStr)
	}
	Ext := !() -> StringSpan
	{
		size := StrSize(itStr)
		pos := size - 1
		if size == 0 return StringSpan("",0)

		while pos >= 0 and itStr[pos] != '.' {
			if itStr[pos] in "/\\"  return StringSpan("",0)
			pos--
		}
		if pos < 0 return StringSpan("",0)

		return StringSpan(itStr[pos]&, size - pos)
	}
	GetId := !() -> u64
	{
		itAsW := Utf8ToUtf16(itStr)
		hndl := CreateFileW(itAsW,0,FILE_SHARE_READ or_b FILE_SHARE_WRITE or_b FILE_SHARE_DELETE,null,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,null)
		if hndl&->{u64^}^ == not_b 0U
			return 0
		flInf := BY_HANDLE_FILE_INFORMATION
		GetFileInformationByHandle(hndl,flInf&)
		preRes := u64
		preRes = flInf.nFileIndexHigh
		preRes = preRes << 32
		preRes = flInf.nFileIndexLow
		return preRes
	}
	Name := !() -> StringSpan
	{
		size := StrSize(itStr)
		pos := size - 1
		if size == 0 return StringSpan("",0)

		while pos >= 0 {
			if itStr[pos] in "/\\"  break
			pos--
		}
		if pos < 0 return StringSpan("",0)
		if size - pos == 1 return StringSpan("",0)

		return StringSpan(itStr[pos + 1]&, size - pos - 1)
	}
	Size := !() -> u64
	{
		itAsW := Utf8ToUtf16(itStr)
		hndl := CreateFileW(itAsW,0,FILE_SHARE_READ or_b FILE_SHARE_WRITE or_b FILE_SHARE_DELETE,null,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,null)
		if hndl&->{u64^}^ == not_b 0U
			return 0
		flInf := BY_HANDLE_FILE_INFORMATION
		GetFileInformationByHandle(hndl,flInf&)
		preRes := u64
		preRes = flInf.nFileSizeHigh
		preRes = preRes << 32
		preRes = flInf.nFileSizeLow
		return preRes
	}
	FolderName := !() -> string
	{
		size := StrSize(itStr)
		pos := size - 1
		if size == 0 return ""

		while pos >= 0 {
			if itStr[pos] in "/\\"  break
			pos--
		}
		if pos < 0 return ""
		if size - pos == 1 return ""
		pos++
		newStr :=  malloc(pos + 1)->{char^}

		for i : pos newStr[i] = itStr[i]
		newStr[pos] = 0

		return newStr
	}
	JustName := !() -> StringSpan
	{
		itName := this.Name()
		if itName == "" return StringSpan("",0)
		
		itSize := itName.Size()
		pos := itSize - 1

		while pos >= 0 and itName[pos] != '.' pos--

		if pos < 0 return itName
		return StringSpan(itName.Get(),pos)
	}
}
