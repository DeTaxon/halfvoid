
GetDirectoryName := !(void^ dirFd) -> char^
{
	itAsChar := dirFd->{char^}
	return itAsChar[19]&
}
//st_mode 24 size = 144

DirectoryIterator2 := class
{
	dirFd := void^
	nowEntry := void^
	nowPath := Path
	buff := char^
	addToBuff := int
	wildCard := char^
	this := !(char^ tu, bool isWildcard) -> void
	{
		wildCard = null
		buff = new char[1024] ; $temp
		strL := strlen(tu)

		buff[u] = tu[^u]
		buff[strL] = 0

		dirL := strL - 1

		while dirL >= 0
		{
			if buff[dirL] in "/\\"
				break
			dirL--
		}
		dirL++
		if isWildcard
		{
			wildCard = new char[strL - dirL] ; $temp
			for i,j : dirL..(strL-1)
			{
				wildCard[j] = buff[i]
				buff[i] = 0
			}
			addToBuff = dirL
			if dirL == 0
			{
				buff[0] = '.'
				buff[1] = '/'
				buff[2] = 0
				addToBuff = 2
			}

			wildCard[strL - dirL] = 0
		}else{
			if not buff[strL - 1] in "/\\"
			{
				buff[strL] = '/'
				buff[strL + 1] = 0
				addToBuff = strL + 1
			}else
			{
				addToBuff = strL
			}
		}

		dirFd = opendir(buff)
		if dirFd == null
		{
			throw new Exception(199,"folder not found")
		}
		Inc()
		nowPath.itStr = buff
	}
	"^" := !() -> ref Path
	{
		return nowPath
	}
	Inc := !() -> void
	{
		nowEntry = readdir(dirFd)
		while nowEntry != null
		{
			newName := GetDirectoryName(nowEntry)

			if wildCard != null and not IsInWildcard(newName)
			{
				nowEntry = readdir(dirFd)
				continue
			}
			if newName == "." or newName == ".."
			{
				nowEntry = readdir(dirFd)
				continue
			}

			preSet := this.addToBuff
			for c : newName
			{
				buff[preSet] = c
				preSet++
			}
			buff[preSet] = 0

			break

		}
	}
	IsInWildcard := !(char^ str) -> bool
	{
		return CmpNameAndWildcard(str,wildCard[0]&)
	}
	IsEnd := !() -> bool
	{
		return nowEntry == null
	}
}


Path := class
{
	itStr := string
	this := !() -> void
	{
		itStr = null
	}
	this := !(string st) -> void
	{
		itStr = st
	}
	this := !(Path st) -> void
	{
		itStr = st.itStr
	}
	Get := !() -> char^
	{
		return itStr
	}
	GetId := !() -> u64
	{
		st1 := char[144]
		if stat(itStr,st1[0]&) != 0
			return 0
		return st1[8]&->{u64^}^
	}
	"==" := !(Path pt2) -> bool
	{
		idA := GetId()
		idB := pt2.GetId()
		if idA == 0 or idB == 0 return false
		return idA == idB
	}
	IsExist := !() -> bool
	{
		return GetId() != 0
	}

	FullPath := !() -> Path
	{
		newLine := realpath(itStr,null->{char^})
		if newLine == null return Path("")
		stSize := StrSize(newLine)
		preRet := new char[stSize+1] ; $temp
		memcpy(preRet->{char^},newLine,stSize)
		preRet[stSize] = 0
		free(newLine)
		return Path(preRet)
	}
	"~For" := !() -> DirectoryIterator2
	{
		return DirectoryIterator2(itStr,false)
	}
	IsFolder := !() -> bool
	{
		st1 := char[144]
		if stat(itStr,st1[0]&) != 0
			return false
		itflg := st1[24]&->{s32^}^
		return ((itflg and_b 16384) != 0)
	}
	"=" := !(Path pt) -> void
	{
		itStr = pt.itStr
	}
	"=" := !(string pt) -> void
	{
		itStr = pt
	}
	"/=" := !(string str) -> void
	{
		itStr = itStr + "/" + str
	}
	"/" := !(string pt2) -> Path
	{
		ToRet.itStr = this.itStr + "/" + pt2
	}
	"/" := !(Path pt2) -> Path
	{
		return Path(itStr + "/" + pt2.itStr)
	}
	Ext := !() -> StringSpan
	{
		size := StrSize(itStr)
		pos := size - 1
		if size == 0 return StringSpan("",0)

		while pos >= 0 and itStr[pos] != '.' {
			if itStr[pos] in "/\\"  return StringSpan("",0)
			pos--
		}
		if pos < 0 return StringSpan("",0)

		return StringSpan(itStr[pos]&, size - pos)
	}
	Name := !() -> StringSpan
	{
		size := StrSize(itStr)
		pos := size - 1
		if size == 0 return StringSpan("",0)

		while pos >= 0 {
			if itStr[pos] in "/\\"  break
			pos--
		}
		if pos < 0 return StringSpan("",0)
		if size - pos == 1 return StringSpan("",0)

		return StringSpan(itStr[pos + 1]&, size - pos - 1)
	}
	Size := !() -> u64
	{
		st1 := char[144]
		if stat(itStr,st1[0]&) != 0
			return 0
		return st1[48]&->{u64^}^
	}
	FolderName := !() -> string
	{
		size := StrSize(itStr)
		pos := size - 1
		if size == 0 return ""

		while pos >= 0 {
			if itStr[pos] in "/\\"  break
			pos--
		}
		if pos < 0 return ""
		if size - pos == 1 return ""
		pos++
		newStr :=  malloc(pos + 1)->{char^}

		for i : pos newStr[i] = itStr[i]
		newStr[pos] = 0

		return newStr
	}
	JustName := !() -> StringSpan
	{
		itName := this.Name()
		if itName == "" return StringSpan("",0)
		
		itSize := itName.Size()
		pos := itSize - 1

		while pos >= 0 and itName[pos] != '.' pos--

		if pos < 0 return itName
		return StringSpan(itName.Get(),pos)
	}
}
