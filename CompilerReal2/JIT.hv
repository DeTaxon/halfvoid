
jitMode := false

internalMemset := BoxFunc^

passJITFuncs := AVLMap.{char^,Tuple.{Type^,MemParam^}}

JITPreInit := !() -> void
{
	if not jitMode
		return void

	addJITFunction("TSleep",TSleep->{void^},![GTypeDouble],GTypeVoid)
	addJITFunction("TExpectWorkers",TExpectWorkers->{void^},![GTypeInt],GTypeVoid)

	addJITFunction("TPauseTask",TPauseTask->{void^},![GTypeInt.GetPoint()],GTypeVoid)
	addJITFunction("TResumeTask",TResumeTask->{void^},![GTypeInt],GTypeVoid)
	addJITFunction("TExpectWorkers",TExpectWorkers->{void^},![GTypeInt],GTypeVoid)


	lType := GetFuncType(![GTypeVoidP],GTypeVoid).GetLambda()
	addJITFunction("TSpawnTask",TSpawnTask->{void^},![lType],GTypeVoid)
	addJITFunction("TAwaitWork",TAwaitWork->{void^},![lType],GTypeVoid)

	if $posix
	{
		addJITFunction("stat",stat->{void^},![GTypeChar.GetPoint(),GTypeVoidP],GTypeInt)
		addJITFunction("lstat",lstat->{void^},![GTypeChar.GetPoint(),GTypeVoidP],GTypeInt)
		addJITFunction("fstat",fstat->{void^},![GTypeInt,GTypeChar.GetPoint()],GTypeInt)
	}
}

addJITFunction := !(char^ name ,void^ fPoint, Type^[@ArrSize] inps,Type^ outType) -> void
{
	sleepType := GetFuncType(inps,outType)
	sleepTypePtr := sleepType.GetPoint()
	sleepPar := new GlobalParam(sleepTypePtr,new ObjPointer(fPoint->{void^},sleepTypePtr))
	passJITFuncs[name] = !{sleepType,sleepPar}
}

JITInit := !() -> void
{
	box := new FuncInputBox ; $temp
	box.itPars.Emplace(GTypeVoidP,false)
	box.itPars.Emplace(GTypeSizeT,false)

	internalMemset = FindFunc("internalGCMemClear",null,box^,false)
	assert(internalMemset != null)

	if not jitMode
		return void

	rp := GetItem("gRepo",null)
	if rp?.Down != null
	{
		rp.Down.Down = new ObjPointer(gRepo,rp.GetType())
		rp.Down.Down.Up = rp.Down
	}

	tb := GetItem("CurrentTaskBox",null)
	if tb?.Down != null
	{
		tb.Down.Down = new ObjPointer(CurrentTaskBox,tb.GetType())
		tb.Down.Down.Up = tb.Down
	}

}
JITPrint := !(TIOStream f) -> void
{
	if not jitMode
		return void
	for it : passJITFuncs
	{
		it.1.PrintGlobal(f)
	}
}
