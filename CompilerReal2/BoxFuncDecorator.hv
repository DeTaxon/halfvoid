AppendClass BoxFunc
{
	decoratorName := char^
	decoratorFunc := BoxFunc^
	decoratorHaveFunc := bool


	wrappedSearched := bool
	wrappedFunc := BoxFunc^
	GetWrappedFunc := virtual !() -> BoxFunc^
	{
		if wrappedSearched
			return wrappedFunc
		wrappedSearched = true
		wrappedFunc = this&
		ParseBlock()
		
		if Up? is ObjParam
		{
			iter := Up.Left
			while iter != null
			{
				if not iter.IsCmdMod()
					break
				if iter is ObjTemplateType
				{
					dcName := iter->{ObjTemplateType^}.MyStr
					wrappedFunc = wrappedFunc.SearchGetDecorator(dcName)

					if wrappedFunc == null
						EmitError("Decorator <"sbt + dcName + "> not found")
					wrappedFunc.ParseBlock() //TODO move to FuncCall?
				}
				iter = iter.Left
			}
		}

		return wrappedFunc
	}

	GetDecorator := !() -> BoxFunc^
	{
		if decoratorName == null
			return null


		if decoratorFunc == null
			SearchDecorator(decoratorName)
		return decoratorFunc
	}
	SearchDecorator := !(char^ name) -> void
	{
		decoratorFunc = SearchGetDecorator(name)

		if decoratorFunc == null
			EmitError("Decorator <"sbt + name + "> not found")
	}
	SearchGetDecorator := !(char^ name) -> BoxFunc^
	{
		assert(MyFuncType != null)

		fncName := ("@"sbt + name + " func")->{char^}
		
		//itBox := new FuncInputBox() ; $temp
		//itBox.itPars.Emplace(MyFuncType.GetPoint(),false)
		//for c : MyFuncType.ParsCount
		//{
		//	itBox.itPars.Emplace(
		//		MyFuncType.Pars[c],
		//		MyFuncType.ParsIsRef[c]
		//		)
		//}

		//dFunc := FindFunc(fncName,this&,itBox^,false)

		//if dFunc != null
		//{
		//	decoratorFunc = dFunc
		//	decoratorHaveFunc = true
		//	return void
		//}

		itBox2 := new FuncInputBox() ; $temp
		itBox2.itConsts.Push(new ObjFuncPointer(this&)) ; $temp
		for c : MyFuncType.ParsCount
		{
			itBox2.itPars.Emplace(
				MyFuncType.Pars[c],
				MyFuncType.ParsIsRef[c]
				)
		}
		dFunc := FindFunc(fncName,this&,itBox2^,false)

		if dFunc != null
		{
			return dFunc
		}
		return null

	}
}
