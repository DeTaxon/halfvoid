
NaturalCall := class extend SomeFuncCall
{
	gcObjId := int

	this := !(BoxFunc^ func, Object^ Pars) -> void 
	{
		if Pars != null
		{
			Line = Pars.Line
		}
		if func.IsPassAttrs and Pars != null
		{
			inhAttrs = Pars.inhAttrs
		}
		Down = Pars
		
		RetId = GetNewId()
		ToCall = func
		ToCall.ParseBlock()
		FType = ToCall.MyFuncType
		if Pars != null Pars.SetUp(this&)
		if Pars != null TrimCommas(Down.Up)
		ExchangeParams()
		WorkBag.Push(this&,State_MiddleGetUse)
	}
	
	PrintPreFuncName := virtual !(TIOStream f) -> void
	{

	}
	PrintFuncName := virtual !(TIOStream f) -> void
	{
		if ToCall != null
		f << "@" << ToCall.OutputName
	}

	PrintParamPres := virtual !(TIOStream f) -> void
	{
		RefsArr := FType.ParsIsRef
		for iter,i : Down
		{
			if RefsArr[i] iter.PrintPointPre(f)
			else iter.PrintPre(f)
		}
	}
	PrintParamUses := virtual !(TIOStream f) -> void
	{
		iter := Down
		RefsArr := FType.ParsIsRef

		i := 0
		if gotAlloc and not IsConstr
		{
			f << ToCall.MyFuncType.RetType.GetName() << "* "
			f << TName
			if iter != null f << " , "
			//i += 1
		}
		while iter != null
		{
			if i > 0  f << " , "
			if RefsArr[i] iter.PrintPointUse(f)
				else iter.PrintUse(f)
			iter = iter.Right
			i += 1
		}
	}

	UseCall := virtual !(TIOStream f) -> void
	{
		PrintPreFuncName(f)
		PrintParamPres(f)

		UseCallInner(f,ToCall,true)
	}
	UseCallInner := virtual !(TIOStream f,BoxFunc^ callFunc,bool printPres) -> void
	{

		if (FType.RetType != GTypeVoid and (not gotAlloc) and TName != null) or callFunc.IsRetRef
		{
			f << TName <<" = "	
		}
		f << "call "
		//callFunc.MyFuncType.PrintType(f)
		base := callFunc.MyFuncType
		base2 := base->{Type^}
		f << base2.GetName()
		f << "@" << callFunc.OutputName
		f << "("
		PrintParamUses(f)
		f << ")"
		if DebugMode {
			newId := CreateDebugCall(this&) 
			if newId != -1{
				f << ", !dbg !" << newId
			}
		}
		if Line != null
		{
			f << "; Line: " << Line.LinePos << " File: " << Line.inFile.itStr 

		}
		f << "\n"
		if gcObjId > 0 and printPres
		{
			tn := FType.RetType.GetName() 
			f << "store " << tn << TName << " , "
			f << tn << "* %T" << gcObjId << "\n"
		}
	}
	Print := virtual !(int s) -> void {
		for s printf("->")
		printf("item: %s %s\n",GetValue(),ToCall.FuncName)
		End := this.Down
		while End != null
		{
			End.Print(s+1)
			End = End.Right
		}
	}
	DoTheWork := virtual !(int pri) -> void
	{
		if pri == State_MiddleGetUse
		{
			CheckReturn()
			if IsGCAnyPtr(FType.RetType) and not FType.RetRef
			{
				gcObjId = GetAlloc(this&,FType.RetType)
				assert(gcObjId > 0)
				GCMakeAware(this&,gcObjId)
			}
		}
	}

}

NaturalCallWithDefer := class extend NaturalCall
{
	deferCall := BoxFuncBody^

	allocHoldValues := int[32] //TODO dynamic size

	this := !(BoxFunc^ func, Object^ Pars,BoxFuncBody^ defTail) -> void 
	{
		deferCall = defTail
		this."NaturalCall.this"(func,Pars)
	}
	DoTheWork := virtual !(int pri) -> void
	{
		this."NaturalCall.DoTheWork"(pri)
		if pri == State_MiddleGetUse
		{
			fnc := GetBoxFuncContainer(this&)
			if fnc != null
			{
				fnc.DoDefer()
			}
		}
	}
	UseCall := virtual !(TIOStream f) -> void
	{
		PrintPreFuncName(f)
		PrintParamPres(f)

		for it,i : Down
		{
			if i >= deferCall.MyFuncType.ParsCount
				break
		}

		UseCallInner(f,ToCall,true)
	}
	GetDeferUsage := virtual !() -> int
	{
		return 1
	}
	GetDeferUsageVerticalSize := virtual !() -> int
	{
		return 1 //TODO recursive collect down
	}
	PrintDeferUse := virtual !(TIOStream f, BoxFuncContainer^ bd,BoxBlock^ blk, int depth,int^ labelIter) -> void
	{
		curId := labelIter^
		labelIter^ -= 1
		f << "br label %DeferLabel" << curId << "\n"
		f << "DeferLabel" << curId << ":\n"
		
		UseCallInner(f,deferCall,false) //TODO expect to not have same input count variables
	}
	
	PrintDeferInBlock := virtual !(TIOStream f, int itId,int^ labelSetIter) -> void
	{
		f << "store i8 " << labelSetIter^ << " , i8* %DeferStack" << itId << "\n"
		labelSetIter^ += 1
	}
}
