ConstItem := class extend Object
{
	Name := string
	this := !(string name, Object^ toCp) -> void
	{
		Name = name
		Down = toCp.Clone()
		Down.Up = this&
	}
	GetValue := virtual !() -> string
	{
		return "(const)"
	}
}

TryCompute := !(Object^ ob) -> Object^
{
	return TryCompute(ob,null)
}
TryCompute := !(Object^ ob,Queue.{ObjConstHolder^}^ values) -> Object^
{
	if ob == null return null

	if ob.IsConst return ob

	if ob is ObjIndent
	{
		asN := ob->{ObjIndent^}
		it := Object^()
		if values != null
		{
			for cmpVal : values^
			{
				if cmpVal.ItName == asN.MyStr
				{
					it = cmpVal
					break
				}
			}
		}
		if it == null
			it = GetItem(asN.MyStr,ob)

		if it == null and asN.MyStr[0] == '$' 
		{
			inAtt := GlobalAttributes.TryFind(asN.MyStr[1..0].StrTmp())
			if inAtt != null return inAtt^
			return GBoolFalse //new ObjBool(false) 
		}
		if it == null 
		{
			if it == null
				return null
		}
		if it is ObjConstHolder
			return it.Down
		if it is ConstItem
		{
			return it.Down
		}
		if it.IsConst return it
	}
	if ob.Down?.Right? is ObjSuffix
	{
		itItm := ob.Down
		asSuf := ob.Down.Right->{ObjSuffix^}
		if asSuf.MyStr == "f" and (itItm is ObjInt or itItm is ObjDouble)
		{
			newItm := new ObjDouble(0.0) ; $temp 
			newItm.ResultType = GTypeFloat
			if itItm isObjInt
			{
				newItm.MyDouble = itItm->{ObjInt^}.MyInt
			}else{
				newItm.MyDouble = itItm->{ObjDouble^}.MyDouble
			}
			return newItm
		}
	}
	if ob.Down?.Right?.GetValue() == "->"
	{
		dV := TryCompute(ob.Down,values)
		if dV == null return null

		if ob.Down.Right.Right? is ObjIndent
		{
			metaStr := ob.Down.Right.Right->{ObjIndent^}.MyStr
			if dV is ObjType
			{
				asType := dV->{ObjType^}.MyType
				switch metaStr
				{
					case "ResultType"
						if (asType is TypePoint or asType is TypeFuncLambda) and asType.Base is TypeFunc
							return new ObjType(asType.Base->{TypeFunc^}.RetType) ; $temp
				}
			}
			if metaStr == "Type"
			{
				if dV.GetType() != null
					return new ObjType(dV.GetType()) ; $temp
			}
			if metaStr == "Group"
			{
				if dV is ObjType
				{
					tp := dV->{ObjType^}.MyType
					if tp is TypeStandart
						return new ObjStr("prime") ; $temp
					if tp is TypePoint
						return new ObjStr("pointer") ; $temp
					if tp is TypeFunc
						return new ObjStr("func") ; $temp
					if tp is TypeArr
						return new ObjStr("array") ; $temp
					if tp is TypeFuncLambda
						return new ObjStr("lambda") ; $temp
					if tp is TypeFatArr
						return new ObjStr("vector") ; $temp //TODO change name
					assert(false)
				}
			}
		}
	}

	if ob is ObjData and ob.Down.GetValue() == "!" and ob.Down.Right.GetValue() == "[]"
	{
		SyntaxCompress(ob.Down.Right,PriorityData)
		iterR := ob.Down.Right.Down
		typ := Type^()
		Sutf := Queue.{Object^}() ; $temp
		
		while iterR != null
		{
			if iterR.GetValue() != ","
			{
				if iterR.Right != null and iterR.Right.GetValue() == ".."
				{
					if iterR.Right.Right != null and iterR.Right.Right.IsConst
						and iterR.GetType() == GTypeInt and iterR.Right.Right.GetType() == GTypeInt
					{
						start := iterR->{ObjInt^}.MyInt
						end := iterR.Right.Right->{ObjInt^}.MyInt

						if start > end return null

						for i : start..end Sutf.Push(new ObjInt(i)) ; $temp

						iterR = iterR.Right.Right

						if typ == null typ = GTypeInt
						typ = TypeFight(typ,GTypeInt)
						if typ == null return null
					}else{
						return null
					}
				}else{
					itm := TryCompute(iterR)
					if itm == null 
					{
						if iterR.GetType() == GTypeRange
						{
							if iterR.Down.GetType() != GTypeInt return null
							if iterR.Down.Right.GetType() != GTypeInt return null

							start := iterR.Down->{ObjInt^}.MyInt
							end := iterR.Down.Right.Right->{ObjInt^}.MyInt

							if start > end return null

							for i : start..end Sutf.Push(new ObjInt(i)) ; $temp

							if typ == null typ = GTypeInt
							typ = TypeFight(typ,GTypeInt)
							if typ == null return null
						}else{
							return null
						}
					}else{
						Sutf.Push(itm)
						if typ == null typ = itm.GetType()
						typ = TypeFight(typ,itm.GetType())
						if typ == null return null
					}
				}
			}
			iterR = iterR.Right
		}
		if typ == null or Sutf.Size() == 0 return null
		if typ == GTypeRange typ = GTypeInt
		if typ is TypeArr and typ.Base == GTypeChar typ = GTypeString
		preRet := new ObjArray(typ.GetArray(Sutf.Size()),Sutf.ToArray()) ; $temp
		preRet.Line = ob.Down.Line
		return preRet
	}

	return null
}
