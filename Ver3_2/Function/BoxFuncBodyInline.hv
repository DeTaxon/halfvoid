
FuncInlineWrapper := class extend BoxExeObj
{
	body := BoxBlock^

	vars := HybridQueue.{FuncResultParam2^,5}
	nameVars := HybridQueue.{MemVar^,5}

	groupVars := VarGroup^

	thisReturns := ReturnsHolder
	resultCall := BoxExeObj^
	classUnroll := ClassUnroll

	bodyToken := Token^

	this := !(BoxFuncBody^ fnc,CheckExeDownList itms) -> void
	{
		bodyToken = fnc.bdy
		CurrentFunc.inlineFunctions.Push(this&)

		stackSize := UnitStack.Size()

		UnitStack.PushFront(fnc.ConstVars[^])

		assert(itms.Size() >= fnc.InputVarNames.Size())

		oldReturns := CurrentReturns
		CurrentReturns = thisReturns&


		vSize := fnc.InputVarNames.Size()
		fTyp := fnc.GetType()->{TypeFunc^}

		thisReturns.IsAutoResult = fnc.Attrs.IsAutoResult
		thisReturns.ResultRef = fTyp.ResultRef
		thisReturns.ResultType = fTyp.ResultType

		if not thisReturns.IsAutoResult
		{
			rFnc := new FuncLocalParam(thisReturns.ResultType)
			thisReturns.ResultVar = new MemVar(StringSpan("result"),rFnc)
			CurrentFunc.regularVars.Push(rFnc)
			UnitStack.PushFront(thisReturns.ResultVar)
		}

		assert(fTyp.Params.Size() == itms.Size())

		for i : itms.Size()
		{
			vr := FuncResultParam2^

			if (not fTyp.Params[i].IsRef) and itms[i].IsMem()
			{
				vr = new FuncResultParam2(new StripMem(itms[i]))
			}else{
				vr = new FuncResultParam2(itms[i])
			}


			vars.Push(vr)
			CurrentFunc.FunctionResultVars.Push(vr)

			if i >= vSize
			{
				if groupVars == null
				{
					groupVars = new VarGroup
					groupVars.Name = fnc.VariadicName
				}
				groupVars.Vars.Push(vr)
			}else{
				nVr := new MemVar(fnc.InputVarNames[i],vr)
				nameVars.Push(nVr)
				UnitStack.PushFront(nVr)
			}

		}
		if groupVars != null
			UnitStack.PushFront(groupVars)

		if fnc.Attrs.IsMethod
		{
			classUnroll.MethodObj = vars[0]
			classUnroll.BaseClass = fTyp.Params[0].ItType->{TypeClass^}.ToClass
			assert(classUnroll.BaseClass is in BoxClass)
			UnitStack.PushFront(classUnroll&)
		}

		body = new BoxBlock

		CurrentReturns.ExitLabel = body.GetQuitLabel()

		body."this"(fnc.bdy)
		body.Work()

		ObjType = thisReturns.ResultType

		if ObjType != GTypeVoid
		{
			resultCall = thisReturns.ResultVar.Value.CreateCall()
		}else{
			assert(false)
		}

		if thisReturns.IsAutoResult
		{
			thisReturns.CheckReturnStep(fnc.ObjType->{TypeFunc^}) //TODO?

			rFnc := new FuncLocalParam(thisReturns.ResultType)
			thisReturns.ResultVar = new MemVar(StringSpan("result"),rFnc)
			CurrentFunc.regularVars.Push(rFnc)
			UnitStack.PushFront(thisReturns.ResultVar)

			thisReturns.ResolveReturnVars()
		}

		while stackSize > UnitStack.Size()
			UnitStack.Pop()
		CurrentReturns = oldReturns
	}
	IsMem := virtual !() -> bool
	{
		return thisReturns.ResultRef
	}
	PrintPointPre := virtual !(Stream^ f) -> void
	{
		for it : vars
		{
			it.PrintCode(f)
		}
		body.PrintCode(f)
		resultCall?.PrintPointPre(f)
	}
	PrintPre := virtual !(Stream^ f) -> void
	{
		for it : vars
		{
			it.PrintCode(f)
		}
		body.PrintCode(f)
		resultCall?.PrintPre(f)
	}
	PrintPointUse := virtual !(Stream^ f) -> void
	{
		resultCall.PrintPointUse(f)
	}
	PrintUse := virtual !(Stream^ f) -> void
	{
		resultCall.PrintUse(f)
	}
	PrintDebugMeta := virtual !(Stream^ f) -> void
	{

		oldId := GDebugFileId
		if bodyToken?.Line?.File != null
		{
			GDebugFileId = bodyToken.Line.File.fileId
		}
		//for it : vars
		//{
		//	it.PrintDebugMeta(f)
		//}
		body.PrintDebugMeta(f)

		GDebugFileId = oldId
	}
}
