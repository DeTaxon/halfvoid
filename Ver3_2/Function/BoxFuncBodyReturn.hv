AppendClass BoxFuncBody
{
	returnHolder := ReturnsHolder

	CheckReturnStep := !() -> void
	{
		assert(Attrs.IsAutoResult)

		resType := GTypeNone

		for it : returnHolder.Returns
		{
			st := it.GetSetType()

			if resType == GTypeNone
			{
				resType = st
			}else{
				if resType == GTypeVoid
				{
					resType = st
				}else{
					resType = TypeFight(resType,st)
				}
			}

			if resType == null
				it.errorToken.EmitError("can not create type that satisfy all return objects")
		}

		if resType != GTypeNone
		{
			ObjType = FuncTypeSetResult(ObjType->{TypeFunc^},resType,false)
		}

		ResultTypeHatch.Emit()

		CreateResultVar()
		if ResultVar != null
			UnitStack.PushFront(ResultVar)
	}
	ResolveReturnVars := !() -> void
	{
		returnHolder.Returns[^].ResolveStep()
	}
	CreateResultVar := !() -> void
	{
		assert(ResultVar == null)

		tp := ObjType->{TypeFunc^}
		
		if tp.ResultType != GTypeVoid
		{
			resSpn := StringSpan("result")
			if tp.ResultType.IsComplexReturn() and not tp.ResultRef
			{
				rv := new FuncInputParam(tp.ResultType,true,StringSpan("%result"))
				ResultVar = new MemVar(resSpn,rv)
			}else{
				rFuncType := tp.ResultType
				if tp.ResultRef
					rFuncType = rFuncType.GetPoint()
				rFnc := new FuncLocalParam(rFuncType)
				//regularVars.Push(rFnc)
				ResultVar = new MemVar(resSpn,rFnc)
			}
		}else
		{
			resSpn := StringSpan("result")
			resVoid := new FuncLocalVoidParam()
			ResultVar = new MemVar(resSpn,resVoid)
		}
	}
}
ReturnsHolder := class extend BoxUnit
{
	IsAutoResult := bool
	ResultRef := bool
	ResultType := Type^
	ResultVar := MemVar^
	Returns := HybridQueue.{ReturnHalfState^,4}

	ReturnBlock := BoxBlock^
	ExitLabel := BoxLabel^
}
