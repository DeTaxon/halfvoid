AppendClass BoxFuncBody
{
	returnHolder := ReturnsHolder
	inlineFunctions := List.{FuncInlineWrapper^}

	CheckReturnStep := !() -> void
	{
		assert(Attrs.IsAutoResult)

		ObjType = returnHolder.CheckReturnStep(ObjType->{TypeFunc^})

		ResultTypeHatch.Emit()
	}
	ResolveReturnVars := !() -> void
	{
		returnHolder.ResolveReturnVars()
	}
	CreateResultVar := !() -> void
	{
		assert(ResultVar == null)

		tp := ObjType->{TypeFunc^}
		
		if tp.ResultType != GTypeVoid
		{
			resSpn := StringSpan("result")
			if tp.ResultType.IsComplexReturn() and not tp.ResultRef
			{
				rv := new FuncInputParam(tp.ResultType,true,StringSpan("%result"))
				ResultVar = new MemVar(resSpn,rv)
			}else{
				rFuncType := tp.ResultType
				if tp.ResultRef
					rFuncType = rFuncType.GetPoint()
				rFnc := new FuncLocalParam(rFuncType)
				//regularVars.Push(rFnc)
				ResultVar = new MemVar(resSpn,rFnc)
			}
		}else
		{
			resSpn := StringSpan("result")
			resVoid := new FuncLocalVoidParam()
			ResultVar = new MemVar(resSpn,resVoid)
		}
	}
}
ReturnsHolder := class extend BoxUnit
{
	IsAutoResult := bool
	ResultRef := bool
	ResultType := Type^
	ResultVar := MemVar^
	Returns := HybridQueue.{ReturnHalfState^,4}

	ReturnBlock := BoxBlock^
	ExitLabel := BoxLabel^

	CheckReturnStep := !(TypeFunc^ fncType) -> TypeFunc^
	{
		resType := GTypeNone

		for it : Returns
		{
			st := it.GetSetType()

			if resType == GTypeNone
			{
				resType = st
			}else{
				if resType == GTypeVoid
				{
					resType = st
				}else{
					resType = TypeFight(resType,st)
				}
			}

			if resType == null
				it.errorToken.EmitError("can not create type that satisfy all return objects")
		}
	
		result = fncType
		if resType != GTypeNone
		{
			result = FuncTypeSetResult(fncType,resType,false)
		}
		ResultType = resType
	}
	ResolveReturnVars := !() -> void
	{
		Returns[^].ResolveStep()
	}
}
