TryGetTrinary := !(Token^ itm) -> BoxExeObj^
{
	if itm?.Down?.Right?.GetValue() == "?:"
	{
	}else{
		return null
	}

	itr := itm.Down
	ifRes := TryGetExeCall(itr)

	if ifRes == null
		return null
	if ifRes.GetType() != GTypeBool
		itr.EmitError("Check statement of ?: must be bool")
	
	itr = itr.Right.Right

	onTrue := TryGetExeCall(itr)
	if onTrue == null
		return null

	itr = itr.Right.Right
	onFalse := TryGetExeCall(itr)
	if onFalse == null
		return null

	
	resTyp := TypeFight(onTrue.GetType(),onFalse.GetType())
	if resTyp == null
		itm.EmitError("Can not get type that sattisfy both of results of ?:")
	
	if resTyp != onTrue.GetType()
		onTrue = GetExchange(onTrue,resTyp)
	
	if resTyp != onFalse.GetType()
		onFalse = GetExchange(onFalse,resTyp)

	if onTrue.IsMem() and onFalse.IsMem()
	{
		return new TrinaryOperMem(ifRes,onTrue,onFalse)
	}else{
		return new TrinaryOper(ifRes,onTrue,onFalse)
	}

	return null
}
TrinaryOper := class extend BoxExeObj
{
	ifStatement := BoxExeObj^
	onTrue := BoxExeObj^
	onFalse := BoxExeObj^
	
	trueLabel := BoxLabel^
	trueExitLabel := BoxLabel^
	falseLabel := BoxLabel^
	falseExitLabel := BoxLabel^
	endLabel := BoxLabel^

	ItId := int
	this := !(BoxExeObj^ fRes,BoxExeObj^ nTrue,BoxExeObj^ nFalse ) -> void
	{
		ifStatement = fRes
		onTrue = nTrue
		onFalse = nFalse

		trueLabel = new BoxLabel()
		trueExitLabel = new BoxLabel()
		falseLabel = new BoxLabel()
		falseExitLabel = new BoxLabel()
		endLabel = new BoxLabel()

		ItId = GetNewId()

		ObjType = onTrue.GetType()
	}
	IsMem := virtual !() -> bool
	{
		return false
	}
	PrintPre := virtual !(Stream^ f) -> void
	{
		tp := onTrue.GetType()

		ifStatement.PrintPre(f)
		PrintBranch(f,ifStatement,trueLabel,falseLabel)

		trueLabel.PrintCode(f)
		onTrue.PrintPre(f)
		trueExitLabel.PrintCode(f)
		endLabel.PrintGo(f)

		falseLabel.PrintCode(f)
		onFalse.PrintPre(f)
		falseExitLabel.PrintCode(f)
		endLabel.PrintGo(f)

		endLabel.PrintLabelCreate(f)

		f^ << "%T" << ItId << " = phi "
		tp.PrintType(f)

		f^ << " ["
		onTrue.PrintUse(f)
		f^ << ","
		trueExitLabel.PrintLabel(f)
		f^ << "]"

		f^ << ","

		f^ << " ["
		onFalse.PrintUse(f)
		f^ << ","
		falseExitLabel.PrintLabel(f)
		f^ << "]"

		if DebugMode
			f^ << " , !dbg !" << GDebugLineCallId
		f^ << "\n"

	}
	PrintUse := virtual !(Stream^ f) -> void
	{
		f^ << "%T" << ItId
	}
}
TrinaryOperMem := class extend BoxExeObj
{
	ifStatement := BoxExeObj^
	onTrue := BoxExeObj^
	onFalse := BoxExeObj^
	
	trueLabel := BoxLabel^
	trueExitLabel := BoxLabel^
	falseLabel := BoxLabel^
	falseExitLabel := BoxLabel^
	endLabel := BoxLabel^

	ItId := int
	this := !(BoxExeObj^ fRes,BoxExeObj^ nTrue,BoxExeObj^ nFalse ) -> void
	{
		ifStatement = fRes
		onTrue = nTrue
		onFalse = nFalse

		trueLabel = new BoxLabel()
		trueExitLabel = new BoxLabel()
		falseLabel = new BoxLabel()
		falseExitLabel = new BoxLabel()
		endLabel = new BoxLabel()

		ItId = GetNewId()

		ObjType = onTrue.GetType()
	}
	IsMem := virtual !() -> bool
	{
		return true
	}
	PrintPointPre := virtual !(Stream^ f) -> void
	{
		tp := onTrue.GetType()

		ifStatement.PrintPre(f)
		PrintBranch(f,ifStatement,trueLabel,falseLabel)

		trueLabel.PrintCode(f)
		onTrue.PrintPointPre(f)
		trueExitLabel.PrintCode(f)
		endLabel.PrintGo(f)

		falseLabel.PrintCode(f)
		onFalse.PrintPointPre(f)
		falseExitLabel.PrintCode(f)
		endLabel.PrintGo(f)

		endLabel.PrintLabelCreate(f)

		f^ << "%T" << ItId << " = phi "
		tp.PrintType(f)
		f^ << "*"

		f^ << " ["
		onTrue.PrintPointUse(f)
		f^ << ","
		trueExitLabel.PrintLabel(f)
		f^ << "]"

		f^ << ","

		f^ << " ["
		onFalse.PrintPointUse(f)
		f^ << ","
		falseExitLabel.PrintLabel(f)
		f^ << "]"

		if DebugMode
			f^ << " , !dbg !" << GDebugLineCallId
		f^ << "\n"

	}
	PrintPointUse := virtual !(Stream^ f) -> void
	{
		f^ << "%T" << ItId
	}

	PrintPre := virtual !(Stream^ f) -> void
	{
		PrintUnrefObj(f,ItId,this&)
	}
	PrintUse := virtual !(Stream^ f) -> void
	{
		f^ << "%TUnref" << ItId
	}
}
