TryGetContinueBreak := !(Token^ itm) -> BoxExeObj^
{
    if itm.GetValue() == "continue"
    {
        return new BoxContinue(itm)
    }
    if itm.GetValue() == "break"
    {
        return new BoxBreak(itm)
    }
    return null
}

BoxContinue := class extend BoxExeObj
{
    goLabel := BoxLabel^
    exitCall := BoxExeObj^
    this := !(Token^ itm) -> void
    {
        for it : UnitStack
        {
            if it is in BoxBlockContinue
            {
                block := it->{BoxBlock^}
                goLabel = block.GetQuitLabel()
                exitCall = block.CreateGCClear()
                break
            }
        }
		if goLabel == null
			itm.EmitError("continue operator used without cycle")
    }
    PrintDefaultUse := virtual !(Stream^ f) -> void
    {
        exitCall?.PrintDefaultUse(f)
        goLabel.PrintGo(f)
    }
}

BoxBreak := class extend BoxExeObj
{
    goLabel := BoxLabel^
    exitCall := BoxExeObj^
    this := !(Token^ itm) -> void
    {
        for it : UnitStack
        {
            if it is in BoxBlockBreak
            {
                block := it->{BoxBlock^}
                goLabel = block.GetQuitLabel()
                exitCall = block.CreateGCClear()
                break
            }
        }
		if goLabel == null
			itm.EmitError("break operator used without cycle")
    }
    PrintDefaultUse := virtual !(Stream^ f) -> void
    {
        exitCall?.PrintDefaultUse(f)
        goLabel.PrintGo(f)
    }
}
