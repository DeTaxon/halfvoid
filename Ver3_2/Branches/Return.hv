BoxReturn := class extend BoxExeObj
{
	EndLabel := BoxLabel^
	ResultCall := BoxExeObj^
	cleanupCall := BoxExeObj^
	this := !(BoxLabel^ l,BoxExeObj^ rc) -> void
	{
		EndLabel = l
		ObjType = GTypeVoid
		ResultCall = rc

		if GCVarsInUse != 0
		{
			objs := CheckExeDownList
			gcPtr := CurrentFunc->{BoxFuncBody^}.gcArrayPtr
			assert(gcPtr != null)
			getGCPtr := gcPtr.CreateCall(objs)

			objs.Push(GetExchange2(getGCPtr,GCType.GetPoint().GetPoint(),false))
			objs.Push(GetExeInt(0))
			objs.Push(GetExeInt(GCVarsInUse - 1))

			cleanupCall = GFuncGCSetNullArray.CreateCall(objs)
		}
	}
	PrintDefaultUse := virtual !(Stream^ f) -> void
	{
		ResultCall?.PrintDefaultUse(f)
		cleanupCall?.PrintDefaultUse(f)
		EndLabel.PrintGo(f)
	}
}

BoxYield := class extend BoxReturn
{
	toThis := BoxLabel^
	callSet := BoxExeObj^
	this := !(BoxLabel^ l,BoxExeObj^ rc) -> void
	{
		this."BoxReturn.this"(l,rc)

		yieldVal := CurrentFunc.PutYieldState(this&)
		yVar := CurrentFunc.GetYieldStateParam()

		objs := CheckExeDownList
		objs.Push(yVar.CreateCall())
		objs.Push(GetExeInt(yieldVal))

		callSet = CreateFuncCall(StringSpan("="),objs)
		toThis = new BoxLabel()
	}

	PrintDefaultUse := virtual !(Stream^ f) -> void
	{
		ResultCall?.PrintDefaultUse(f)
		callSet.PrintDefaultUse(f)
		EndLabel.PrintGo(f)
		toThis.PrintCode(f)
	}
	GetLabel := virtual !() -> BoxLabel^
	{
		return toThis
	}
}

ReturnHalfState := class extend BoxExeObj
{
	isYield := bool
	callObj := BoxExeObj^
	returnObj := BoxExeObj^
	errorToken := Token^
	this := !(Token^ erToken,BoxExeObj^ toCall,bool iY) -> void
	{
		errorToken = erToken
		callObj = toCall
		isYield = iY
	}

	ResolveStep := !() -> void
	{
		if callObj != null
		{
			if callObj.GetType() != GTypeVoid //TODO Auto return type
			{
				rRef := CurrentReturns.ResultRef

				callObj2 := BoxExeObj^
				resType := callObj.GetType()
				funcType := CurrentReturns.ResultType
				if rRef
				{
					if not callObj.IsMem()
						errorToken.EmitError("Can not return reference, object does not sits in memory")
				}

				if resType != funcType
				{
					if rRef
					{
						if resType is in TypeClass and funcType is in TypeClass and TypeFight(funcType,resType) == funcType
						{
							callObj2 = GetExchange(new UnrefFuncCall(callObj),funcType.GetPoint())
						}else{
							errorToken.EmitError("result type does not compare with function result")
						}
					}else{
						newObj := GetExchange(callObj,CurrentFunc.ResultVar.GetVarType())
						if newObj == null
						{
							if callObj is BoxExeNull
							{
								newObj = GetExchange2(callObj,CurrentFunc.ResultVar.GetVarType(),false)
							}else{
								errorToken.EmitError("can not convert type to function result")
							}
						}
						callObj = newObj
					}
				}

				if callObj2 == null
				{
					if rRef
					{
						callObj2 = new UnrefFuncCall(callObj)
					}else{
						callObj2 = callObj
					}
				}

				objs := CheckExeDownList
				objs.Push(CurrentReturns.ResultVar.Value.CreateCall())
				objs.Push(callObj2)

				if rRef
				{
					cns := List.{BoxExeConstObj^}
					setPtrFunc := GPointStoreTemplate.GetFunc(objs,cns)
					assert(setPtrFunc != null)
					callObj = setPtrFunc.CreateCall(objs)
				}else{
					callObj = innerTryGetInfixCall(StringSpan("="),objs,errorToken)
					if callObj == null
						errorToken.EmitError("Can not return value, no \"=\" operator")
				}
			}
		}
	 
		if isYield
		{
			returnObj = new BoxYield(CurrentReturns.ExitLabel,callObj)
		}else{
			returnObj = new BoxReturn(CurrentReturns.ExitLabel,callObj)
		}
	}
	GetReturnObj := !() -> BoxExeObj^
	{
		return returnObj
	}
	GetSetType := !() -> Type^
	{
		if callObj == null
			return GTypeVoid
		return callObj.GetType()
	}

	PrintDefaultUse := virtual !(Stream^ f) -> void
	{
		returnObj.PrintDefaultUse(f)
	}
}
